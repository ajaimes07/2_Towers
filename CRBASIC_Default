'Version 00.03 for CR6 + CDM-A116 + IRGASON or CSAT3A & EC150 + slow microclimate sensors, based on EasyFlux_DL for CR3000

'Copyright (c), 2014, 2015, 2016 Campbell Scientific, Inc. All rights reserved.
'This program is intended for use with Campbell Scientific open-path eddy-covariance systems manufactured after Fall 2010 that use an EC150 with CSAT3A or an IRGASON.
'The most common or “best practice” corrections are applied to fluxes in this program.  Consult the manual for details on these corrections.  It is the responsibility
'of the user to determine appropriateness of the corrections used. Campbell Scientific always recommends saving raw time series data in case reprocessing of raw data 
'is warranted. Furthermore, it is the responsibility of the user and associated researchers to determine the quality and fitness of any and all data for a publication,
'regardless of whether said data were processed by this program or another tool.

'Version numbers less than 1.00 of this program are not fully tested or officially released. Campbell Scientific is not responsible for any errors in data collected
'using program versions prior to 1.00.
  
'***********************************************
'*** ABBREVIATIONS IN COMMENTS AND VARIABLES ***
'***********************************************
'AG     analog ground
'amb    ambient 
'CSAT   CSAT3A or sonic anemometer in IRGASON
'CS6XX  CS616, CS650, or CS655
'CS65X  CS650 or CS655
'cumul  cumulative
'dia    diameter
'dig    dignosis
'dir    direction
'dist   distance
'flg    flag
'FP     footprint
'Freq   frequency
'FW     FW05, FW1, or FW3. FW is an abbreviation for Fine Wire thermocouple
'FTPRNT Footprint
'G      ground (i.e. power ground)
'hfp    HFP01 or HFP01SC soil heat flux plate sensor
'intrst interest
'IRGA   EC150 or IRGASON InfraRed Gas Analyzer
'nmbr   number
'pct    percent
'Pyran  pyranometer
'RH     relative humidity
'rng    range
'QC     quality control or quality classification
'shf    soil heat flux
'sig    signal
'strgth strength
'win    within
'wnd    wind
'wtr    water



'*******************************
'*** NOTES AND EXPLAINATIONS ***
'*******************************
'* SIGN CONVENTION
' Positive fluxes away from the ground surface and negative towards the ground surface.

'* SITE AND CALIBRATION CONSTANTS
' Search for the text string "Unique" in this code to find the lines below in this program where unique site constants and sensor calibration values are entered.

'* LAGS
' Instrument scan lag: Before computing online fluxes and writing to the time series data table, an instrument scan lag for each variable is introduced
' to account for the fixed instrument delays so that any pair of variables for covariance are aligned at the time resolution of the scan rate. Scan lags
' depend on instrument settings and/or the datalogger scan interval. In the case of the IRGASON or EC150 with CSAT3A, the instrument delay is determined
' by the bandwidth setting in the EC100 electronics (see appendix A of IRGASON manual, Revision 6/14).  For analog measurements such as FW sensors,
' the measurements are assumed to have no scan delay. After instrument scan lags are applied, the data are recorded in the time series output table.

' Sensing time lag: After the instrument scan lag is applied, an additional lag called the sensing time lag is applied to account for covariance attenuation
' at high frequency due to spatial separation between the scalar sensor (e.g. FW or IRGA) and CSAT. The sensing lag is positive if wind passed the CSAT first
' followed by the scalar sensor; otherwise, the sensing lag is negative. Sensing time lags depend on the wind speed and sensor separation.  An algorithm
' in the program selects a lag that maximizes covariances and is physically possible. The final outputs in the flux output table have sensing time lags applied.
' *** END OF NOTES AND EXPLAINATIONS ***

'************************
'*** UNIT DEFINITIONS ***
'************************
'SYMBOL      UNIT
'C           Celsius
'degrees     angle degrees
'frac_v_wtr  Fraction volumetric water content
'g           grams
'J           Joules
'Hz          Hertz
'kg          kilograms
'kPa         kilopascals
'm           meters
'mg          milligrams
'mmol        millimoles
'mol         moles
'ms          milliseconds
's           seconds
'umol        micromoles
'usec        microseconds
'V           volts
'W           Watts
'*** UNIT DEFINITIONS ***
  

'*******************************************
'*** DEFAULT SETTING FOR CR6 AND PROGRAM ***
'******************************************* 
PipeLineMode
AngleDegrees         'Angle degree used throughout the program
SDMBeginPort(C1)     'Starting port for SDM (valid starting ports: C1, U1, U5, or U9). 
'*** END of DEFAULT SETTING FOR CR6 AND PROGRAM ***

  
'***********************************************************
'*** CONFIGURATION VARIABLES FOR PERIPHERALS AND SENSORS ***
'*********************************************************** 
'* PERIPHERAL
Const PERIPHERAL_CDM_A116 = TRUE 

'* SENSORS
Const SENSOR_IRGASON     = TRUE                   'Unique: IRGASON, if TRUE, SENSOR_CSAT3AEC150 must be set to FALSE
Const SENSOR_CSAT3AEC150 = FALSE                  'Unique: CSAT3A + EC150, if TRUE, SENSOR_IRGASON must be set to FALSE.
Const SENSOR_FW          = FALSE                  'Unique: FW05, FW1, FW3, or other fine wire thermocouple
Const SENSOR_TMPR_RH     = FALSE                  'Unique: HC2S3 or HMP155A: temperature and relative humidity probe
Const SENSOR_NR_LITE     = FALSE                  'Unique: NR Lite2: net radiometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_CS300       = FALSE                  'Unique: CS300: pyranometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_LI200X      = FALSE                  'Unique: LI200X: pyranometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_LI190SB     = FALSE                  'Unique: LI190SB: Quantum, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_SI111       = FALSE                  'Unique: SI111: Infrared radiometer, if true, SENSOR_NR01 and SENSOR_CNR4 must be set to FALSE
Const SENSOR_NR01        = FALSE                  'Unique: NR01: 4-way net radiometer, if true, SENSOR_NR_LITE, SENSOR_CNR4, CS300, LI200X, LI190SB, and SI111 must be set to FALSE
Const SENSOR_CNR4        = FALSE                  'Unique: CNR4: 4-way net radiometer, if true, SENSOR_NR_LITE, SENSOR_NR01, CS300, LI200X, LI190SB, and SI111 must be set to FALSE
Const SENSOR_TE525mm     = FALSE                  'Unique: TE525mm rain gauge
Const SENSOR_TCAV        = FALSE                  'Unique: TCAV: type E thermocouple averaging soil temperature probes
Const SENSOR_CS616       = FALSE                  'Unique: CS616: water content reflectometers for volumetric soil moisture, if true, SENSOR_CS65X must be set to FALSE
Const SENSOR_CS65X       = FALSE                  'Unique: CS650 or CS655: water content reflectometers for volumetric soil moisture, if true, SENSOR_CS616 must be set to FALSE
Const SENSOR_HFP01       = FALSE                  'Unique: HFP01: soil heat flux plates, if true, SENSOR_HFP01SC must be set to FALSE
Const SENSOR_HFP01SC     = FALSE                  'Unique: HFP01SC: self-calibrated soil heat flux plates, if true, SENSOR_HFP01 must be set to FALSE

'* Composite boolean variables for variables above
Const SENSOR_Rn          = ((SENSOR_CNR4) OR (SENSOR_NR01) OR (SENSOR_NR_LITE))
Const SENSOR_HFP         = ((SENSOR_HFP01) OR (SENSOR_HFP01SC))
Const SENSOR_CS6XX       = ((SENSOR_CS616) OR (SENSOR_CS65X))
'*** END OF CONFIGURATION VARIABLES FOR PERIPHERALS AND SENSORS ***


'**************************  
'*** WIRING INSTRUCTIONS ***
'***************************
'*** Beginning of CR6 Wiring *** 
' UNIVERSAL INPUT
#If (SENSOR_CS6XX) Then

Const NMBR_CS6xx = 2                'Unique: number of CS616, CS650, or CS655 sensors (Maximum is 2)

#If (SENSOR_CS616) Then

Const CS616_ANALOG_INPUT = U1       'Starting single-ended analog input channel.
Const CS616_POWER_CTRL   = U3       'Control port for CS616.
'*** Beginning of CS616 wiring ***
'U1      Signal #1 (green)
'U2      Signal #2 (green)
'U3      Enable control #1 (orange)
'        Enable control #2 (orange)
'AG     Signal reference #1 (black)
'        Signal reference #2 (black)
'AG     Shield #1 (clear)
'        Shield #2 (clear)

'12V     Power #1 (red)
'        Power #2 (red)
'G       Power ground #1 (clear)
'        Power ground #2 (clear)
'*** End of CS616 wiring ***
#EndIf
#If (SENSOR_CS65X) Then

Const CS65X_SDI12_PORT      = U3       'SDI port.
Const CS65X_SDI12_Address_1 = 1        'Unique: SDI address for CS655 #1
#If (NMBR_CS6xx = 2) Then
Const CS65X_SDI12_Address_2 = 2        'Unique: SDI address for CS655 #2
#EndIf
'*** Beginning of CS65X wiring ***
'U3      SDI-12 data #1 (green)
'        SDI-12 data #2 (green)
'12V     SDI-12 power #1 (red)
'        SDI-12 power #2 (red)
'G       SDI-12 data/power reference #1 (black)
'        SDI-12 data/power reference #2 (black)
'AG     Shield #1 (clear)
'        Shield #2 (clear)
'*** End of CS65X wiring ***
#EndIf
#EndIf
#If (SENSOR_TE525mm) Then

Const TE525_PULSE_INPUT = U4           'Pulse input channel rain gauge.
Const TE525_MULT        = 0.1          'Unique: multiplier for TE525MM

'*** Beginning of TE525mm wiring ***
'U4      Precipitation signal (black)
'AG     Signal reference (white)
'AG     Shield (clear)
'*** End of TE525mm wiring ***
#EndIf
  
' CPI PORT
' CPI       CDM-A116 CPI PORT (Use a 2-ft CPI cable)
  
'CONTROL PORTS
'C1         SDM C1 in EC100 [EC155 w/CSAT3A or IRGASON SDM Data (green)]
'C2         SDM C2 in EC100 [EC155 w/CSAT3A or IRGASON SDM Clock (white)]
'C3         SDM C3 in EC100 [EC155 w/CSAT3A or IRGASON SDM Enable (brown)]
'G          SDM G EC100 [EC155 w/CSAT3A or IRGASON SDM reference (black)]
'           SDM shield in EC100 [EC155 w/CSAT3A or IRGASON SDM shield (clear)]
  
' POWER TERMINALS
' BAT +     Positive of external power supply 
' BAT -     Negative of external power supply 
   
' CHG +     Positive of charger (AC to DC or solar to DC charger)   
' CHG -     Negative of charger (AC to DC or solar to DC charger)
'*** End of CR6 Wiring *** 
  
'*** Beginning of external power supply *** 
'EXTERNAL POWER SUPPLY
'POS        CSAT3A/EC155 or IRGASON power (red)
'           CR6 (red)
'NEG        CSAT3A/EC155 or IRGASON power reference (black)
'           CR6 (black)
'           CSAT3A/EC155 or IRGASON power shield (clear)
'*** End of external power supply *** 
  
'*** Beginning of EC100 Wiring *** 
' Sonic animometer port    CSAT connector 
' Gas analyzer port        Gas analyzer connector
' Temperature probe port   Temperature sensor connector
' SDM C1                   CR6 C1
' SDM C2                   CR6 C2
' SDM C3                   CR6 C3
' SDM G                    CR6 G
  
' 12V                      Positive of external power supply or BAT + of CR6
' G                        Negative of external power supply or BAT - of CR6    
'*** End of EC100 Wiring *** 

#If (PERIPHERAL_CDM_A116) Then  
'*** Beginning of CDM-A116 Wiring *** 
' CPI port                 CR6 CPI PORT
' 12V                      Positive of external power supply or CR6 BAT +
' G                        Negative of external power supply or CR6 BAT -
'*** End of CDM-A116 Wiring *** 
#EndIf

#If (PERIPHERAL_CDM_A116) Then   
'*** Beginning of Sensor Wiring to CDM-A116  ***
#If (SENSOR_HFP) Then
'Soil heat flux plates
Const SHF_ANALOG_INPUT = 1  'Starting differential analog input channel in CDM-A116.
Const NMBR_HFP = 4         'Unique: number of HFP01 or HFP01SC sensors to measure (Maximum is 4).

Data 1000/62                'Unique: multiplier for HFP #1 (1000/sensitivity).
#If (NMBR_HFP >1) Then     'This conditional statement can avoid the confliction with Data statements for the numerical wTs transfer function from Dijk (2002) if NMBR_HFP < 2

Data 1000/62                'Unique: multiplier for HFP #2 (1000/sensitivity).
#EndIf
#If (NMBR_HFP >2) Then     'This conditional statement can avoid the confliction with Data statements for the numerical wTs transfer function from Dijk (2002) if NMBR_HFP < 3

Data 1000/62
#EndIf                      'Unique: multiplier for HFP #3 (1000/sensitivity).
#If (NMBR_HFP >3) Then     'This conditional statement can avoid the confliction with Data statements for the numerical wTs transfer function from Dijk (2002) if NMBR_HFP < 4

Data 1000/62                'Unique: multiplier for HFP #4 (1000/sensitivity).
#EndIf

#If (SENSOR_HFP01) Then
'*** Beginning of HFP01 wiring ***
'13H  (CDM-A116)   Signal #1 (white)
'13L  (CDM-A116)   Signal reference #1 (green)
'AG   (CDM-A116)   Shield #1 (clear)

'14H  (CDM-A116)   Signal #2 (white)
'14L  (CDM-A116)   Signal reference #2 (green)
'AG   (CDM-A116)   Shield #2 (clear)

'15H  (CDM-A116)   Signal #3 (white)
'15L  (CDM-A116)   Signal reference #3 (green)
'AG   (CDM-A116)   Shield #3 (clear)

'16H  (CDM-A116)   Signal #4 (white)
'16L  (CDM-A116)   Signal reference #4 (green)
'AG   (CDM-A116)   Shield #4 (clear)
'*** End of HFP01 wiring ***
#EndIf
#If (SENSOR_HFP01SC) Then

Const SHF_HEATER_ANALOG_INPUT = 5               'Starting single-ended analog input channel in CDM-A116 to measure the heater of HFP01SC #1.

'*** Beginning of HFP01SC wiring ***
'13H  (CDM-A116)     Signal #1 (white)
'AG (CDM-A116)     Signal reference #1 (green)
'AG (CDM-A116)     Shield #1 (clear)

'13L  (CDM-A116)     Signal #2 (white)
'AG (CDM-A116)     Signal reference #2 (green)
'AG (CDM-A116)     Shield #2 (clear)

'14H  (CDM-A116)     Signal #3 (white)
'AG (CDM-A116)     Signal reference #3 (green)
'AG (CDM-A116)     Shield #3 (clear)

'14L  (CDM-A116)     Signal #4 (white)
'AG (CDM-A116)     Signal reference #4 (green)
'AG (CDM-A116)     Shield #4 (clear)

'15H  (CDM-A116)     Heater resistor signal #1 (yellow)
'AG (CDM-A116)     Heater resistor signal reference #1 (purple)
'SW12-1 (CDM-A116)  Heater power positive #1 (red)
'G (CDM-A116)       Heater power negative #1 (black)
'AG (CDM-A116)     Heater shield #1 (clear)

'15L  (CDM-A116)     Heater resistor signal #2 (yellow)
'AG (CDM-A116)     Heater resistor signal reference #2 (purple)
'SW12-1 (CDM-A116)  Heater power positive #2 (red)
'G (CDM-A116)       Heater power negativ #2 (black)
'AG (CDM-A116)     Heater shield #2 (clear)

'16H  (CDM-A116)     Heater resistor signal #3 (yellow)
'AG (CDM-A116)     Heater resistor signal reference #3 (purple)
'SW12-2 (CDM-A116)  Heater power positive #3 (red)
'G (CDM-A116)       Heater power negativ #3 (black)
'AG (CDM-A116)     Heater shield #3 (clear)

'16L  (CDM-A116)     Heater resistor signal #4 (yellow)
'AG (CDM-A116)     Heater resistor signal reference #4 (purple)
'SW12-2(CDM-A116)   Heater power positive #4 (red)
'G (CDM-A116)       Heater power negativ #4 (black)
'AG (CDM-A116)     Heater shield #4 (clear)
'*** End of HFP01SC wiring ***
#EndIf
#EndIf

#If (SENSOR_Rn) Then
' Net radiations sensors
Const NR_ANALOG_INPUT = 5           '1st differential analog input channel CDM-A116 for a net radiation sensor.

#EndIf
#If (SENSOR_NR_LITE) Then

Const NRLITE_CAL = 1000/16          'Unique: multiplier for NR Lite (1000/sensitivity).
'*** Beginning of NR Lite wiring ***
'5H  (CDM-A116)     Signal (red)
'5L  (CDM-A116)     Signal reference (blue)
'AG (CDM-A116)      Short jumper wire to 5L
'                   Shield (clear)
'*** End of NR Lite wiring ***

#EndIf
#If (SENSOR_FW) Then

Const FW_ANALOG_INPUT = 3              'Differential analog input channel in CDM-A116 for FW (Input channels 2, 3, 6, 7, 10, 11, 14, or 15 are recommended)

'*** Beginning of FW wiring ***
'14H  (CDM-A116)    FW signal (purple)
'14L  (CDM-A116)    FW signal reference (red)
'AG  (CDM-A116)    FW shield (clear)
'*** End of FW wiring ***

#EndIf  

#If (SENSOR_NR01) OR (SENSOR_CNR4) Then

Const T_NR_ANALOG_INPUT = 9            'Differential analog input channel in CDM-A116 to measure body temperature of 4-way radiation sensor. 

#EndIf
#If (SENSOR_NR01) Then

Const T_NR_CURRENT_EXCITATION = "X3"    'Current excitation channel in CDM-A116 (now, 01/30/16, X2 as excitation parameter has not been implemented???).
Const NR01_SW_IN_CAL  = 1000/15         'Unique: multiplier for NR01 shortwave downwelling (incoming) radiation (1000/sensitivity).
Const NR01_SW_OUT_CAL = 1000/15         'Unique: multiplier for NR01 shortware upwelling (outgoing) radiation (1000/sensitivity).
Const NR01_LW_IN_CAL  = 1000/8          'Unique: multiplier for NR01 longwave downwelling (incoming) radiation (1000/sensitivity).
Const NR01_LW_OUT_CAL = 1000/8          'Unique: multiplier for NR01 longwave upwelling (outgoing) radiation (1000/sensitivity).

'*** Beginning of NR01 wiring ***
'5H  (CDM-A116)     Downwelling (incoming) shortwave radiation signal (red)
'5L  (CDM-A116)     Downwelling (incoming) shortwave radiation signal reference (blue)
'AG (CDM-A116)     Shield (clear)

'6H  (CDM-A116)     Upwelling (outgoing) shortwave radiation signal (white)
'6L  (CDM-A116)     Upwelling (outgoing) shortwave radiation signal reference (green/black)

'7H  (CDM-A116)     Downwelling (incoming) longwave radiation signal (brown/gray or orange)
'7L  (CDM-A116)     Downwelling (incoming) longwave radiation signal reference (yellow)

'8H  (CDM-A116)     Upwelling (outgoing) longwave radiation signal (purple or pink/brown)
'8L  (CDM-A116)     Upwelling (outgoing) longwave radiation signal reference (gray/green)

'9H (CDM-A116)     Pt100 signal (white/yellow)
'9L (CDM-A116)     Pt100 signal reference (green)
'AG                Pt100 shield (silver/bare)

'X3 (CDM-A116)      current excitation (red)
'AG (CDM-A116)     current excitation reference (blue/blue)
'*** End of NR01 wiring ***
#EndIf
#If (SENSOR_CNR4) Then

Const T_NR_VOLTAGE_EXCITATION = "X3"  'Voltage excitation channel in CDM-A116 (now, 01/30/16, X2 as excitation parameter has not been implemented).
Const CNR4_SW_IN_CAL  = 1000/15.35    'Unique: multiplier for CNR4 shortwave downwelling (incoming) radiation (1000/sensitivity).
Const CNR4_SW_OUT_CAL = 1000/15.41    'Unique: multiplier for CNR4 shortware upwelling (outgoing) radiation (1000/sensitivity).
Const CNR4_LW_IN_CAL  = 1000/8.50     'Unique: multiplier for CNR4 longwave downwelling (incoming) radiation (1000/sensitivity).
Const CNR4_LW_OUT_CAL = 1000/7.09     'Unique: multiplier for CNR4 longwave upwelling (outgoing) radiation (1000/sensitivity).

'*** Beginning of CNR4 wiring ***
'5H  (CDM-A116)    Downwelling (incoming) shortwave radiation signal (red)
'5L  (CDM-A116)    Downwelling (incoming) shortwave radiation signal reference (blue)
'AG (CDM-A116)     Shield (clear)
'                  short jumper wire to 5L

'6H  (CDM-A116)    Upwelling (outgoing) shortwave radiation signal (white)
'6L  (CDM-A116)    Upwelling (outgoing) shortwave radiation signal reference (black)
'AG (CDM-A116)     short jumper wire to 7L

'7H  (CDM-A116)    Downwelling (incoming) longwave radiation signal (gray)
'7L  (CDM-A116)    Downwelling (incoming) longwave radiation signal reference (yellow)
'AG (CDM-A116)     short jumper wire to 8L

'8H (CDM-A116)     Upwelling (outgoing) longwave radiation signal (brown)
'8L (CDM-A116)     Upwelling (outgoing) longwave radiation signal reference (green)
'AG (CDM-A116)     short jumper wire to 9L

'9H (CDM-A116)     Thermistor signal (white)
'AG (CDM-A116)     Thermistor signal reference (black)
'                  Shield (clear)

'X3 (CDM-A116)     Thermistor excitation (red)
'*** End of CNR4 wiring ***

#EndIf
#If (SENSOR_LI200X) OR (SENSOR_CS300) Then

Const PYRAN_ANALOG_INPUT  = 6     'Differential analog input channel in CDM-A116 for LI200X or CS300 Pyranometer
Const PYRAN_VOLTAGE_RANG  = mV200 'Unique: measurement range of voltage mV20 for LI200 and mV250 for CS300 pyranometer
Const PYRAN_MULT          = 200   'Unique: multiplier for LI200X [200 W/(m^2 * mV)] or CS300 [5 W/(m^2 * mV)] pyranometer .
Const PYRAN_OFFSET        = 0     'Unique: offset for LI200X [0 W/(m^2 * mV)] or CS300 [0 W/(m^2 * mV)] pyranometer.

'*** Beginning of Pyranometer wiring ***
'6H  (CDM-A116)    Pyranometer signal (red)
'6L  (CDM-A116)    Pyranometer signal reference (black)
'AG (CDM-A116)    Shield (clear)

#If (SENSOR_LI200X) Then
'AG     Pyranometer current return (white)
#EndIf

'***     End of pyranometer wiring   ***
#EndIf
#If (SENSOR_LI190SB) Then

Const QUANTUM_ANALOG_INPUT  = 9     'Differential analog input channel in CDM-A116 for quantum PAR sensor
Const QUANTUM_VOLTAGE_RANGE = mV200 'Unique: measurement range of voltage
Const QUANTUM_MULT          = 256   'Unique: multiplier (1000 C) for quantum PAR sensor.
Const QUANTUM_OFFSET        = 0     'Unique: offset for for quantum PAR sensor.

'*** Beginning of quantum wiring ***
'9H  (CDM-A116)    Quantum signal (red)
'9L  (CDM-A116)    Quantum signal reference Jump to AG (black)
'AG (CDM-A116)    Shield (clear)
'***  End of quantum wiring   ***
#EndIf
#If (SENSOR_SI111) Then
  
Const SI111_ANALOG_INPUT   = 7    'Differential analog input channel in CDM_116 for SI-111 sensor
Const SI111_EXCITATION     = "X2" 'Voltage excitation channel for SI-111 sensor

Const m0_SI111 =  1.41970e9       'Unique: calbration m0
Const m1_SI111 =  7.84100e6       'Unique: calbration m1
Const m2_SI111 =  82213           'Unique: calbration m2
Const b0_SI111 = -1.72150e7       'Unique: calbration b0
Const b1_SI111 =  1.85020e5       'Unique: calbration b1
Const b2_SI111 =  13114           'Unique: calbration b2

'*** Beginning of SI-111 precision infrared radiometer wiring***
'7H   (CDM-A116)      SI111 target signal (red)
'7L   (CDM-A116)      SI111 target signal reference. Jump to AG (black)
'AG  (CDM-A116)      SI111 shield (clear)

'8H  (CDM-A116)      SI111 body temperature signal (green)
'AG  (CDM-A116)      SI111 body temperature signal reference (blue)
'X2   (CDM-A116)      SI111 voltage excitation (white)
'***     End of SI-111 precision infrared radiometer   ***
#EndIf
#If (SENSOR_TCAV) Then

Const TCAV_ANALOG_INPUT = 10         'Staring differential analog input channel in CDM-A116 for TCAV.
Const NMBR_TCAV         = 2          'Unique: number of TCAV (Maximum is 2)

'*** Beginning of TCAV wiring ***
'10H (CDM-A116)    Signal #1 (purple)
'10L (CDM-A116)    Signal reference #1 (red)
'AG (CDM-A116)     Shield #1 (clear)

'11H (CDM-A116)    Signal #2 (purple)
'11L (CDM-A116)    Signal reference #2 (red)
'AG (CDM-A116)     Shield #2 (clear)
'*** End of TCAV wiring ***
#EndIf
#If (SENSOR_TMPR_RH) Then

Const TMPR_RH_ANALOG_INPUT = 1     'Starting differential analog input channel in CDM-A116 for temperature and humidity probe.
Const TMPR_T_MULT          = 0.1   'Unique: multiplier for temperature; HC2S3 = 0.1, HMP155A = 0.14, or HMP45C = 0.1.
Const TMPR_T_OFFSET        = -40   'Unique: offset for temperature; HC2S3 = -40, HMP155A = -80, or HMP45C = -40.
Const TMPR_RH_MULT         = 0.1   'Unique: multiplier for RH: HMP155A = 0.1
Const TMPR_RH_OFFSET       = 0     'Unique: offset for RH: HMP155A = 0

'*** Beginning of HC2S3 or HMP wiring ***
'1H (CDM-A116)  Temperature signal (brown/yellow)
'1L (CDM-A116)  Signal reference (yellow/white)

'2H (CDM-A116)  Relative humidity signal (white/blue)
'2L (CDM-A116)  Jumper connecting CDM Diff 2L to CDM Diff 1L (common signal reference for both temp and RH)
'AG (CDM-A116)  Shield (clear/clear)

'12V (CDM-A116) Power (green/red)
'G   (CDM-A116) Power reference (gray/black)
'*** End of HC2S3 or HMP wiring ***
#EndIf
#EndIf  
'*** END OF WIRING INSTRUCTIONS *** 


'*************************************************
'*** BEGINNING STATION CONSTANTS AND VARIABLES ***
'*************************************************
Const SCAN_INTERVAL              = 100           'Unique: measurement rate (ms): 40 ms (25 Hz), 50 ms (20 Hz), 100 ms (10 Hz), 200 ms (5 Hz), or 1000 ms (1 Hz)
Const SLOWSEQUENCE_SCAN_INTERVAL = 3000          'Unique: slow sequence measurement rate (ms) (Note: SDI-12 sensors too slow for sub-second intervals)
Const OUTPUT_INTERVAL            = 30            'Unique: online flux data output interval (minutes).
Const NMBR_DAY_CPU               = 7             'Number of days for flux data to store on the CPU.
Const NMBR_DAY_FLUX_CRD          = 30            'Unique: number of days of Flux_AmeriFluxFormat, Flux_CSFormat, Flux_Notes table data to store in each file on the card.  Number of files stored depends on card size.
Const NMBR_DAY_TIMESERIES_CRD    = 1             'Unique: number of days of Time_Series table data to store in each file on the card (days). Number of files stored depends on card size.
Const SDM_PER                    = 30            'Unique: default SDM clock speed (uS). May need to increase if using long cables and skipped scans are observed.
Const EC100_SDM_ADDR             = 1             'Unique: SDM address for EC100.

Const FIRST_NOTCH_FREQ_SLOW_SEQU = 50            'Unique: slowsequence analog measurement integration time, 60 for 60Hz (e.g. in US, Canada, etc.) or 50 for 50Hz (e.g. in Europe, China, etc.)
Const FIRST_NOTCH_FREQ_MAIN_SCAN = 3750          'Measurement integration frequency. The frequency of 3750 Hz allows CDM-A100 series to perform a 0.2667 ms integration for 20Hz main scan rate

Const OFFSET           = 17                                            'An offset delay (instrument scan lags) introduced to the eddy covariance data used to compute online fluxes.
Const SCAN_BUFFER_SIZE = 290*INT (1000/SCAN_INTERVAL)                  'Compute a 290-second scan buffer (The buffer less than 5 minutes is preferred because of 5-minute interval for data tables used QC.
Const FLUX_SIZE_CPU    = Ceiling ((NMBR_DAY_CPU*1440)/OUTPUT_INTERVAL) 'Size of flux data table on CPU [(days*1440 minutes/day)/(minutes/record)] = records].

Dim stn_conf_array_file      As Long             'Filehandle for the configuration data stored in the CPU.
Dim stn_conf_array_file_size As Long             'Size of the station configuration file stored on the CPU.

Const NMBR_STN_VAR       = (16 - 3*SENSOR_FW -3*((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))))   'Number of station variables below
Public stn_conf_array(NMBR_STN_VAR)              'These station parameters are entered using the datalogger keypad while program is running after compiled.
Alias stn_conf_array(1)  = sonic_azimuth         'Azimuth angle (degrees) (see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
Alias stn_conf_array(2)  = latitude              'Latitude (degrees)
Alias stn_conf_array(3)  = hemisphere_NS         '"1" for north and "-1" for south, following GPS convention
Alias stn_conf_array(4)  = longitude             'Longitude (degrees)
Alias stn_conf_array(5)  = hemisphere_EW         '"1" for east and "-1" for west, following GPS convention
Alias stn_conf_array(6)  = height_measurement    'Measurement height (m)
Alias stn_conf_array(7)  = displacement_user     'User-entered displacement height (m) [If 0 (default), then auto calculate]
Alias stn_conf_array(8)  = height_canopy         'canopy height (m).
Alias stn_conf_array(9)  = surface_type          'crop = 1, grass = 2, forest = 3, shrub = 4, bare land = 5, and water = 6
Alias stn_conf_array(10) = roughness_user        'User-entered roughness length (m) [If 0 (default), then auto calculate and continuously updated by recalculation when netrual stratification]
Alias stn_conf_array(11) = separation_x_irga     'x coordinate of IRGA optical path center along the CSAT x-coordinate axis (m)
Alias stn_conf_array(12) = separation_y_irga     'y coordinate of IRGA optical path center along the CSAT y-coordinate axis (m)
Alias stn_conf_array(13) = dist_intrst_60_300    'Distance of interest for wind directions 0~<=60 and >300~360 degrees in CSAT coordinate system (m)
Alias stn_conf_array(14) = dist_intrst_60_170    'Distance of interest for wind directions >60 and <=170 degrees in CSAT coordinate system (m)
Alias stn_conf_array(15) = dist_intrst_170_190   'Distance of interest for wind directions >170 and <=190 degrees in CSAT coordinate system (m)
Alias stn_conf_array(16) = dist_intrst_190_300   'Distance of interest for wind directions >190 and <=300 degree in CSAT coordinate system (m)

Units sonic_azimuth       = Decimal degrees
Units latitude            = Decimal degrees
Units hemisphere_NS       = adimensional         '"adimensional" indicatses "no unit" or "dimensionelss"
Units longitude           = Decimal degrees
Units hemisphere_EW       = adimensional         '"adimensional" indicatses "no unit" or "dimensionelss"
Units height_measurement  = m
Units displacement_user   = m
Units height_canopy       = m
Units surface_type        = adimensional         '"adimensional" indicatse "no unit" or "dimensionelss"
Units roughness_user      = m
Units separation_x_irga   = m
Units separation_y_irga   = m
Units dist_intrst_60_300  = m
Units dist_intrst_60_170  = m
Units dist_intrst_170_190 = m
Units dist_intrst_190_300 = m

#If (SENSOR_FW) Then
Alias stn_conf_array(17) = separation_x_FW      'Coordinate x of FW junction in the CSAT coordinate system (m)
Alias stn_conf_array(18) = separation_y_FW      'Coordinate y of FW junction in the CSAT coodinate system (m)
Alias stn_conf_array(19) = FW_diameter          'Diameter of fine wire (m)
Units separation_x_FW = m
Units separation_y_FW = m
Units FW_diameter     = m
#EndIf

#If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
Alias stn_conf_array(17 - 3*SENSOR_FW) = soil_bulk_density   'Soil bulk density (kg/m^3)
Alias stn_conf_array(18 - 3*SENSOR_FW) = Cds                 'Specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
Alias stn_conf_array(19 - 3*SENSOR_FW) = thick_abv_HFP      'Thickness of soil above soil heat flux plate (m)
Units soil_bulk_density  = kg/m^3
Units Cds                = J/(kg k)
Units thick_abv_HFP     = m
#EndIf

Dim stn_conf_array_prev(NMBR_STN_VAR)            'Hold previous station parameters to check for new user-entered values

'After a user inputs, used to assign a sign to latitude and longitude
Const HEMISPHERE_NORTH =  1
Const HEMISPHERE_SOUTH = -1
Const HEMISPHERE_EAST  =  1
Const HEMISPHERE_WEST  = -1

'Used to assign a value for surface_type
Const CROP     = 1
Const GRASS    = 2
Const FOREST   = 3
Const SHRUB    = 4
Const BARELAND = 5
Const WATER    = 6
Const ICE      = 7

Dim surface_type_array(7)   As String * 9 = {"Crop", "Grass", "Forest", "Shrub", "Bare land", "Water", "Ice"}
Dim surface_type_text As String * 9   'Used to record the surface type in data table

#If (SENSOR_FW) Then
Const FW05DIA  = 1.27e-5              'Diameter of FW05 fine wire that is selected for FW diameter(m)
Const FW1_DIA  = 2.54e-5              'Diameter of FW1 fine wire that is selected for FW diameter(m)
Const FW2_DIA  = 5.08e-5              'Diameter of FW2 fine wire that is selected for FW diameter(m)
Const FW3_DIA  = 7.62e-5              'Diameter of FW3 fine wire that is selected for FW diameter(m)
#EndIf

Public stn_var_check_count As Long    'Working variable to count loops to check one station variable only every slow sequence scan, whether or not this station variable is changed through keyboard or loggerNet connection.
'*** BEGINNING STATION CONSTANTS AND VARIABLES ***


'*****************************************************************
'*** BEGINNING CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS ***
'*** [Unless noted, see page 467 in Wallace AND Hobbs (2006)]  ***
'*****************************************************************
    
Const Cpd     = 1004               'specific heat of dry air at constant pressure [J/(kg K)]
Const Cpw     = 1952               'specific heat of water vapor at constant pressure [J/(kg K)]
Const Cw      = 4218               'specific heat of liquid water at 0 C [J/(kg K)]
Const epsilon = 18.016/28.97       'molecular mass ratio of water vapor to dry air
Const g0      = 9.81               'acceleration due to gravity at sea level (m/s^2)
Const k       = 0.41               'von Karman constant (Dyer & hicker 1970, Webb 1970)
Const MU_WPL  = 28.97/18.016       'molecular mass ratio of dry air to water vapor (used in WPL correction)
Const Omega   = 7.292e-5           'Angular velocity of the earth for calculation of Coriolis Force (2PI/sidreal_day, where sidereal day = 23 hr 56 min. [rad/s]
Const R       = 8.3143e-3          'Universal gas constant [kPa m^3/(K mol)]
Const Rd      = R/28.97            'Gas constant for dry air [kPa m^3/(K g)]
Const Rv      = R/18.016           'Gas constant for water vapor [kPa m^3/(K g)]
Const PI      = 3.1415926          'Pi (just use the seven digits after decimal, commonly used) 
Const Sigma_SB= 5.6718e-8          'Stefan-Boltzmann constant in air [J/(K^4 m^2 s), see page 336 in McGee (1988)] 
Const T_0C_K  = 273.15             'Temperature in K when it is zero in C

Public Cp                          'specific heat of moist air at constant pressure, calculated using measurements from EC100 data [J/(kg C)]
Units  Cp = J kg-1 deg C-1

Public Lv                          'Latent heat of vaporization, calculated using air temperature [J/g].
Units  Lv = J g-1
'*** END OF CONSTANTS AND VARIABLES FOR ATMOSPHERIC PHYSICS ******


'*******************************************
'*** BEGINNING PROGRAM WORKING VARIABLES ***
'*******************************************
Dim scan_count                As Long        'Number scans executed. Working variable used to judge the scan loop, from which data processing starts.

Dim slowsequence_finished_flg As Boolean     'Flag used to indicate that the slowSequence has finished its scan.
Dim slowsequence_disable_flg  As Boolean     'Flag used to decimate statistics in main scan.

Dim i, i_slow                 As Long        'Index variables for the outmost loop. "i" in main scan and "i_slow" in slow scan sequence
Dim array_index               As Long        'Used for array index that must be calculated using loop index (to simplify expression and reduce computation for array index)

Dim n = 1                                    'Used for counting the number of samples
Units n = samples

Dim dly_data_out(7)                          'Array used to temporarily store the lagged record from the raw data table (hidden)

Dim x_tmp, T_tmp                             'Temporary variable used in intermediate calculations

Dim process_time                             'Used to monitor processing time and reported in flux_notes table
Units process_time = ms                      'Converted from us to ms that is easy to read

Dim buff_depth                               'Used to monitor buffer depth and reported in flux_notes table
Units buff_depth = scans
'*** END OF BEGINNING PROGRAM WORKING VARIABLES ***


'*******************************************************
'*** BEGINNING DATALOGGER SELF-MEASUREMENT VARIABLES ***
'*******************************************************
Public panel_tmpr                                          'CR6 panel temperature 
Units  panel_tmpr = deg C

#If (PERIPHERAL_CDM_A116) Then
'*** Beginning of CDM-A116 pannel temperature ***
Public panel_tmpr_CDM_A116(4)
Alias  panel_tmpr_CDM_A116(1) = panel_tmpr_CDM_A116_1      'CDM-A116 panel tempearture #1
Alias  panel_tmpr_CDM_A116(2) = panel_tmpr_CDM_A116_2      'CDM-A116 panel tempearture #2
Alias  panel_tmpr_CDM_A116(3) = panel_tmpr_CDM_A116_3      'CDM-A116 panel tempearture #3
Alias  panel_tmpr_CDM_A116(4) = panel_tmpr_CDM_A116_4      'CDM-A116 panel tempearture #4
'*** End of CDM-A116 pannel temperature ***      
#EndIf 

Public batt_volt                                           'Voltage of power connected to CR6
Units  batt_volt  = V
'*** END OF DATALOGGER SELF-MEASUREMENT VARIABLES ***
 

'*******************************************************
'*** BEGINNING OF CORRECTION CONSTANTS AND VARIABLES ***
'*******************************************************
' Rotation angles from the instrument to the natural flow coordinate system. Notation is consistent with Wilczak et al (2001)
Public alpha                                'Angle of counterclockwise rotation about y-axis (pich)
Public beta                                 'Angle of counterclockwise rotation about x-axis (roll)
Public gamma                                'Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha = Decimal degrees
Units  beta  = Decimal degrees
Units  gamma = Decimal degrees

Public alpha_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about y-axis (pich)
Public beta_5min                             '5-minute data for data QC. Angle of counterclockwise rotation about x-axis (roll)
Public gamma_5min                            '5-minute data for data QC. Angle of counterclockwise rotation about z-axis (yaw)
Units  alpha_5min = Decimal degrees
Units  beta_5min  = Decimal degrees
Units  gamma_5min = Decimal degrees

' Rotation angles for planar fit rotations
'1) Program chooses planar fit rotation of Wilczak et al. (2001) if one of the following eigtht angles is not zero.
'2) Program chooses conventional rotation of Tanner and Thurtell (1969) if the following eight angles are all zero.
Dim planar_fit_angle_conf_array_file      As Long      'Filehandle for the planar fit angle configuration data stored in the CPU.
Dim planar_fit_angle_conf_array_file_size As Long      'Size of the station configuration file stored on the CPU.
Dim planar_fit_angle_conf_array_prev(4,2)              'Remembering variable: Hold previous angles for Planar Fit

Public planar_fit_angle_conf_array(4,2)                     'Hold angles for Planar Fit in the for sectors as described below
Units  planar_fit_angle_conf_array      = Decimal degrees

' Alpha_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument x-z plane.
Alias planar_fit_angle_conf_array (1,1) = alpha_PF_60_300   'for wind direction of 0~ <=60 and >300~360 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (2,1) = alpha_PF_60_170   'for wind direction of >60   and <=170 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (3,1) = alpha_PF_170_190  'for wind direction of >170  and <=190 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (4,1) = alpha_PF_190_300  'for wind direction of >190  and <=300 degree in the CSAT coordinate system [degrees]

' Betal_PF_xxx_xxx angle between instrument and natural flow z-axis in the instrument y-z plane.
Alias planar_fit_angle_conf_array (1,2) = beta_PF_60_300    'for wind direction of 0~ <=60  and >300~360 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (2,2) = beta_PF_60_170    'for wind direction of >60   and <=170 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (3,2) = beta_PF_170_190   'for wind direction of >170  and <=190 degrees in the CSAT coordinate system [degrees]
Alias planar_fit_angle_conf_array (4,2) = beta_PF_190_300   'for wind direction of >190 and <=300 degree in the CSAT coordinate system [degrees]

Public Planar_Fit_flg As Boolean                       'TRUE if Planar Fit is used (e.g. any element of planar_fit_angle_conf_array() is not zero)

' Atmospheric stability
Public MO_LENGTH                                       'Monin-Obukhov length (m)
Public PBLH                                            'Planetary boundary layer height (m)  
Public d                                               'displacement height (m)
Public z0                                              'roughness length (m)
Public z                                               'aerodynamic height: z = measurement height - d  (m)
Public z_prev                                          'used to judge whether or not the distance of interest needs to be re-evaluated 
Public ZL                                              'atmospheric surface-layer stability (dimensionless)
Public ZL_prev                                         'remembering variable: previous atmospheric Surface-layer stability to remember ZL (dimensionless)
Units  MO_LENGTH  = m
Units  PBLH       = m 
Units  d          = m
Units  z0         = m
Units  z          = m
Units  ZL         = adimensional

' Frequency (freq) correction
Public iteration_FreqFactor As Long          'count iterations while correcting wu, wv, and wTs for accurate Monin-Obukhov length
Public FreqFactor_UW_VW                      'freq correction factor for covariance of vertical with horizontal wind that are measured using CSAT
Public FreqFactor_UW_VW_Prev                 'remembering variable: previous freq correction factor for covariance of vertical with horizontal wind that are measured using CSAT
Public FreqFactor_WT_SONIC                   'freq correction factor for covariance of vertical wind with sonic temperature that are measured using CSAT
Public FreqFactor_WT_SONIC_Prev              'remembering variable: previous freq correction factor for covariance of vertical wind with sonic temperature that are measured using CSAT
Public FreqFactor_WCO2_WH2O                  'freq correction factor for covariance of vertical wind with IRGA h2o or co2 that are measured using a CSI OPEC system 
Units FreqFactor_UW_VW     = adimensional
Units FreqFactor_WT_SONIC  = adimensional
Units FreqFactor_WCO2_WH2O = adimensional

#If (SENSOR_FW) Then
Public FreqFactor_WFW                        'freq correction factor for covariance of vertical wind with temperature that are measured using CSAT and FW
Units  FreqFactor_WFW = adimensional
#EndIf

' Constants used for numerical integration in calculating the freq correction factors
Const START_FREQ           = 10e-6     'Starting cyclic freq for numerical integration of cospectrum times transfer function
Const END_FREQ             = 10000     'Ending cyclic freq for numerical integration of cospectrum times transfer function
Const FREQ_BIN             = 100       'The number of bins for cyclic freq
Const STEP_BASE_FREQ       = EXP((LN(END_FREQ)- LN(START_FREQ))/FREQ_BIN)   'freq interval base for numerical integration of cospectra and transfer functions (e.g. 100 bins from 0.000001 to 10000 Hz).
Const ACCURACY_FREQ_FACTOR = 0.0001    'The accuracy target of freq factor to approach the "true" value (|current freq factor - previous freq factor|) [page 106: Foken et al. (2012)]
Const MAX_LAG              = 2         'Maximum number of lags in scans that is used to maximizing the covariance. This number of 2 is believed to be adequate for CSAT with EC150 and/or FW


' ------ Numerical wTs transfer function Dijk (2002): alternatively kl and transfer function value where k is wavenumber and l is path length ------
' Hold following numerical values of transfer function of line averaging for wTs of CSAT measurements from Table 1 in Dijk (2012)
Public tran_func_LA_data_Dijk(2,35) = {
0.00,0.01,0.10,0.20,0.50,1.00,1.20,1.40,1.60,1.80,2.00,2.20,2.40,2.60,2.80,3.00,4.00,5.00,6.00,7.00,8.00,9.00,10.0,14.0,20.0,30.0,40.0,50.0,60.0,70.0,80.0,90.0,100,300,10000, _
1.00000,1.00000,0.99920,0.99760,0.99000,0.96700,0.95500,0.94170,0.92740,0.91220,0.89620,0.87970,0.86260,0.84520,0.82740,0.80960,0.72010,0.63530, _
0.55880,0.49220,0.43550,0.38790,0.34810,0.24450,0.17000,0.11340,0.08503,0.06802,0.05668,0.04859,0.04251,0.03779,0.03401,1.89888e-2,1.6168e-4}  
' The data points were extended to kl= 300 and 10000 according to the numerical derivative of transfer function with respect to kl from kl= 70 to 100.
' ----------------------------------------- End of numerical wTs transfer function values from Dijk (2002) ------------------------------------------
'*** END OF CORRECTION CONSTANTS AND VARIABLES ***


'******************************************************************************************
'*** BEGINNING OF EC100 CONFIGURE, ZERO, AND SPAN: CONSTANTS, VARIABLES, AND SUBROUTINE ***
'******************************************************************************************
'User preferred 
Const BANDWIDTH             = 20  'Unique: in Hz. For spectral analysis, set to 1/2 sampling freq. Options: 5, 10, 12.5, or 20 Hz. For flux only, set 20 Hz (default) if sampling freq is 10 Hz
Const PRESS_SOURCE_OPTION   = 0   'Unique: 0 = built-in Basic Barometer, 1 = User-added Barometer, 2 = Enhanced Barometer (e.g. CS106)   
Const DIFFERENTIAL_PRESSURE = 0   'Unique: 0 = disabled. Not applicable to an OPEC system. Should be disabled
Const TEMPERATURE_SOURCE    = 0   'Unique: 0 = defaut ambient temperature sensor that gas analyzer has
Const HEATER_OPTION         = -2  'Unique: -1--> heater off, -2--> heater auto
Const SHADOW_CORR_OPTION    = 0   '1 = on, 0 = off

'Constant used to select options in data pad 
Const BB                    = 0   'BB = 0 for EC100 built-in Basic Barometer (EC100 built-in basic pressure transducer)
Const UB                    = 1   'UB = 1 for EC100 User-added Barometer (pressure transducer)
Const EB                    = 2   'EB = 2 for EC100 CS106, Enhanced Barometer (pressure transducer)
Const POWER_ON              = 0   'IRGA power on 
Const POWER_OFF             = 1   'IRGA power off
Const HEATER_OFF            = -1  'Heater off
Const HEATER_AUTO           = -2  'Heater auto
Const CORR_ON               = 1   'ON = apply shadow correction 
Const CORR_OFF              = 0   'OFF = do not apply shadow correction

Public press_source               'Hold current option of pressure tranducer
Public heater                     'Hold current option of heater 
Public IRGA_power_off             'Hold current status of IRGA power
Public shadow_corr                'Hold current option of shadow correction

Public CO2_span_gas               'CO2 standard gas for CO2 span (umol/mol, read from the CO2 gas cylinder bottle)
Public Td_span_gas                'Dew point temperature for H2O span (C, read from the Dew Point generator)

Dim ec100_setting_array(10, 2) = {100, NAN, 102, NAN, 107, NAN, 114, NAN, 115, NAN, 116, NAN, 117, NAN, 118, NAN, 121, NAN, 125, NAN}

'Array used to configue EC100
Dim config_ec100_array (6, 2)  = {0, BANDWIDTH, 2, PRESS_SOURCE_OPTION, 3, DIFFERENTIAL_PRESSURE, 7, TEMPERATURE_SOURCE, 18, HEATER_OPTION, 25, SHADOW_CORR_OPTION}
Dim press_source_array (1, 2)  = {2, NAN}        '1st col 2--> barometer set commend, 2nd col  pressure source, BB=0--> EC100 built-in Basic Barometer, EB=2 Enhanced Barometer.
Dim zero_array         (1, 2)  = {11, 1}         'Used for zeroing operation: 1st col 11--> Zero/Span command, 2nd col 0--> Inactive, 1--> Zero, 2--> SpanCO2, 3--> SpanH2O .
Dim span_CO2_array     (2, 2)  = {12, 0, 11, 2}  'Used for CO2 span operation: 1st col 12->CO2 concentration span, 2nd col CO2 span concentration value (0 as default). 3rd and 4th cols are zero_array above.
Dim span_H2O_array     (2, 2)  = {13, 0, 11, 3}  'Used for H2O span operation: 1st col 13->H2O dew point temperature span, 2nd col span dew point temperature (0 as default). 3rd and 4th cols are zero_array above.
Dim heater_option_array(1, 2)  = {18, NAN}       '1st col 18 control heaters for lenses of gas analyzer, 2nd col HEATER = -1 off, HEATER = -2 auto to set 0 ~ 4.5375 V
Dim IRGA_power_array   (1, 2)  = {21, 0}         'Used for power off IRGA (not for EC100): 1st col 21 control power commend and 2nd col 0 --> power on and 1 --> power off IRGA
Dim shadow_corr_array  (1, 2)  = {25, NAN}       'Apply sonic shadow correction, value read from EC100 on compile.

'Flags to configure EC100 
Dim    config_ec100_flg      As Boolean = TRUE   'Default: Configure EC100 as soon as this program starts
Dim    get_ec100_config_flg  As Boolean = TRUE   'The flag to meet the varoiable needed in SUB Config. Keep it true all time. Actually, it does not a mater whether true or false.  

Public set_press_source_flg As Boolean
Public do_zero_flg          As Boolean
Public do_CO2_span_flg      As Boolean
Public do_H2O_span_flg      As Boolean
Public set_heater_flg       As Boolean
Public set_IRGA_power_flg   As Boolean
Public set_shadow_corr_flg  As Boolean    

Dim    NAN_cnt              As Long

'Setting sub
Sub Config (cmd_array(10, 2), num_cmd As Long, retry_config_f As Boolean)
  Dim i             As Long
  Dim config_result As Long
  Dim save_flash_f  As Boolean

  save_flash_f = FALSE
  
  For i = 1 To num_cmd
    EC100Configure (config_result, EC100_SDM_ADDR, cmd_array(i, 1), cmd_array(i, 2))
    If (config_result = NAN) Then (ExitFor)
    
    If (NOT save_flash_f) AND (cmd_array(i, 1) < 100) Then 
     
     Select Case cmd_array(i,1)                      
            Case 2, 11, 12, 13, 14, 15, 16, 17, 21, 25  
                  '2: pressure source, 11: zeroing, 12: CO2 span, 13: H2O span, 14: CO2 zero value
                  '15:CO2 span value, 16: H2O zero value, 17: H2O span value, 21: IRGA power, 25: shadow correction 

            save_flash_f = TRUE                      
    
     EndSelect 
    
    EndIf
  Next i

  If ((i = num_cmd + 1)  AND (save_flash_f) AND (config_result <> NAN)) Then
   
      EC100Configure (config_result, EC100_SDM_ADDR, 99, 2718)
      retry_config_f = FALSE
 
  EndIf

  SetStatus ("SkippedScan", 0)
EndSub
'*** END OF EC100 CONFIGURE, ZERO, AND SPAN: CONSTANTS, VARIABLES, AND SUBROUTINE ***
  
'**********************************************************************************
'*** BEGINNING OF CSAT SONIC HEAD：CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
'**********************************************************************************
Const PATH_LENGTH_CSAT = 0.1154701       'CSAT path length = 10 cm/sin(2pi/3) (m)

Public sonic(5)                          'Hold CSAT data aligned in scan with data from IRGA and/or
Alias  sonic(1) = Ts
Alias  sonic(2) = Ux
Alias  sonic(3) = Uy
Alias  sonic(4) = Uz
Alias  sonic(5) = diag_sonic
Units  Ts = deg C
Units  Ux      = m s-1
Units  Uy      = m s-1
Units  Uz      = m s-1
Units  diag_sonic = adimensional

Dim U_rslt                                 'Used to calculate Maximum resultant wind speed in an averaging period   


Dim   diag_bits_sonic(6) As Boolean        'Sonic warning flags
Alias diag_bits_sonic(1) = sonic_amp_l_f   'Amplitude low warning flag
Alias diag_bits_sonic(2) = sonic_amp_h_f   'Amplitude high warning flag
Alias diag_bits_sonic(3) = sonic_sig_lck_f 'Poor signal lock warning flag
Alias diag_bits_sonic(4) = sonic_del_T_f   'Delta temperature warning flag
Alias diag_bits_sonic(5) = sonic_aq_sig_f  'Sonic acquiring signals warning flag
Alias diag_bits_sonic(6) = sonic_cal_err_f 'Signature error in reading CSAT sonic head calibration data
Units diag_bits_sonic    = adimensional

Dim sonic_irga_raw(12)                     'Hold the first 12 data of EC100 from CSAT, IRGA, temperature sensor, and barometer (raw data before applying instrument scan lag).

Dim diag_sonic_tmp  As Long                'Working variable used to break out the CSAT sonic head diagnostic bits.
Dim sonic_disable_f As Boolean             'TRUE when any CSAT diagnostic warning flag is on, CSAT has not sent data, or an SDM signature error is reported.
Dim mask            As Long                'Masking the diagnosis code.
Dim Ts_K                                   'Sonic temperature in K.

Dim cov_out_sonic(20)                      'CSAT sonic statistics.
Alias cov_out_sonic(1)  = Ux_Avg               
Alias cov_out_sonic(2)  = Ux_SIGMA          
Alias cov_out_sonic(3)  = UxUy_Cov         
Alias cov_out_sonic(4)  = UxUz_Cov           
Alias cov_out_sonic(5)  = Uy_Avg                
Alias cov_out_sonic(6)  = Uy_SIGMA          
Alias cov_out_sonic(7)  = UyUz_Cov
Alias cov_out_sonic(8)  = Uz_Avg
Alias cov_out_sonic(9)  = Uz_SIGMA
Alias cov_out_sonic(10) = Ts_Avg          'Ts averaged over an averaging interval (AmeriFlux notation) 
Alias cov_out_sonic(11) = Ts_SIGMA        'Ts standard deviation is stored here. Unlike standard deviation of momentum variable, it is not related to coordinate rotation (AmeriFlux notation) 
Alias cov_out_sonic(12) = TsUx_Cov
Alias cov_out_sonic(13) = TsUy_Cov
Alias cov_out_sonic(14) = TsUz_Cov
Alias cov_out_sonic(15) = WS
Alias cov_out_sonic(16) = WS_RSLT         'Result wind speed (AmeriFlux notation) 
Alias cov_out_sonic(17) = WD_SONIC        'wind direction of 0 to 360 degree in the CSAT coordinate system, equal to Gamma in coordination rotation.
Alias cov_out_sonic(18) = WD_SIGMA
Alias cov_out_sonic(19) = WD              'wind direction in compass convention (AmeriFlux notation)
Alias cov_out_sonic(20) = WS_MAX          'Maximum wind speed over an averaging interval (AmeriFlux notation) 
Units Ux_Avg   = m s-1
Units Ux_SIGMA = m s-1
Units UxUy_Cov = m2 s-2
Units UxUz_Cov = m2 s-2
Units Uy_Avg   = m s-1
Units Uy_SIGMA = m s-1
Units UyUz_Cov = m2 s-2
Units Uz_Avg   = m s-1
Units Uz_SIGMA = m s-1
Units Ts_Avg   = deg C
Units Ts_SIGMA = deg C
Units TsUx_Cov = deg C m s-1
Units TsUy_Cov = deg C m s-1
Units TsUz_Cov = deg C m s-1
Units WS       = m s-1
Units WS_RSLT  = m s-1
Units WD_SONIC = Decimal degrees
Units WD_SIGMA = Decimal degrees
Units WD       = Decimal degrees
Units WS_MAX   = m s-1

' Variables after coordinate rotations as indicated by the last letter of "R"
' 3D wind components before coordinate roations are Ux, Uy, and Uz, and afterwards they are referred to as U, V, and W, respectively.
' Sonic temperatiure is denoted by Ts before coordinate roations and by T_SONIC afterwards
Dim USTAR_R                                'Friction velocity after coordinate rotations
Dim U
Dim U_SIGMA
Dim UV_Cov
Dim UW_Cov
Dim V
Dim V_SIGMA
Dim VW_Cov
Dim W
Dim W_SIGMA
Dim T_SONIC        
Dim T_SONIC_SIGMA
Dim UT_SONIC_Cov
Dim VT_SONIC_Cov
Dim WT_SONIC_Cov

Units USTAR_R = m s-1
Units U       = m s-1
Units U_SIGMA = m s-1
Units UV_Cov  = m2 s-2
Units UW_Cov  = m2 s-2
Units V       = m s-1
Units V_SIGMA = m s-1
Units VW_Cov  = m2 s-2
Units W       = m s-1
Units W_SIGMA = m s-1
Units T_SONIC = deg C        
Units T_SONIC_SIGMA = deg C
Units UT_SONIC_Cov  = deg C m s-1
Units VT_SONIC_Cov  = deg C m s-1
Units WT_SONIC_Cov  = deg C m s-1

Public TKE                           'specific turbulence kinetic energy
Units  TKE = m2 s-2                  '[kg (m/s)^2]/kg

' Variables after coordinate rotations (R) and freq corrections (fc):
' 1) as indicated by U for Ux, V for Uy, and W for Uz as well as by "_fc"
' 2) in final output notation (e.g. H is sensible heat flux and TAU is momentum flux, both of which are after coordinate rotations and freq corrections)

Dim TAU                              'Drag force (stress) at surface (momentum flux) after coordinate rotations and freq corrections.
Dim USTAR                            'Friction velocity after coordinate rotations and freq corrections.
Dim WT_SONIC_Cov_fc
Dim UW_Cov_fc
Dim VW_Cov_fc

Units TAU             = Kg m-1 s-2  'Equivalent to (kg/m^3)(m/s)^2
Units USTAR           = m s-1
Units WT_SONIC_Cov_fc = deg C m s-1
Units UW_Cov_fc       = m2 s-2
Units VW_Cov_fc       = m2 s-2

Public WT_SONIC_Cov_fc_SND         'Covariance of sonic temperature with vertical velocity after rotation, freq, and SND corrections
Public TSTAR                       'Scaling temperature
Public H                           'Sensible heat flux: Derived from covariance of sonic temperatur after rotation, freq, and SND corrections

Units  WT_SONIC_Cov_fc_SND = deg C m s-1
Units  TSTAR               = deg C
Units  H                   = W m-2

'*** Data quality classification: Constant and variables
Const OUTPUT_INTERVAL_SST = 5      'Sub-interval to calculate the statistics for Steady State Test (SST) [minutes]

' Steady State Test (SST)
Public RN_UW_VW_cov                'Relative Non-Stationarity (RN) for momentum covariance (UW_Cov and VW_Cov)
Public RN_UW_cov                   'Relative non-Stationarity for UW_Cov. It is also used for the sum of UxUz_Cov_SST from 5-min sub-intervals
Public RN_VW_cov                   'Relative non-Stationarity for VW_Cov. It is also used for the sum of UyUz_Cov_SST from 5-min sub-intervals
Public RN_WT_SONIC_cov             'Relative non-Stationarity for wTs_cov_R. It is also used for the sum of TsUz_Cov_SST from 5-min sub-intervals
Public nmbr_interval_qc_csat       'Number of sub-intervals = (OUTPUT_INTERVAL in min)/(5 min) if not a 1st interval or CR6 starts before 5 min after an individual interval

Dim cov_out_sonic_SST(17)          'CSAT sonic head statistics for Steady State Test (SST)
Alias cov_out_sonic_SST(1)  = Ux_Avg_SST
Alias cov_out_sonic_SST(2)  = Ux_Var_SST
Alias cov_out_sonic_SST(3)  = UxUy_Cov_SST
Alias cov_out_sonic_SST(4)  = UxUz_Cov_SST
Alias cov_out_sonic_SST(5)  = Uy_Avg_SST
Alias cov_out_sonic_SST(6)  = Uy_Var_SST
Alias cov_out_sonic_SST(7)  = UyUz_Cov_SST
Alias cov_out_sonic_SST(8)  = Uz_Avg_SST
Alias cov_out_sonic_SST(9)  = Uz_Var_SST
Alias cov_out_sonic_SST(10) = T_SONIC_Var_SST
Alias cov_out_sonic_SST(11) = TsUx_Cov_SST
Alias cov_out_sonic_SST(12) = TsUy_Cov_SST
Alias cov_out_sonic_SST(13) = TsUz_Cov_SST
Alias cov_out_sonic_SST(14) = WS_SST
Alias cov_out_sonic_SST(15) = WS_RSLT_SST
Alias cov_out_sonic_SST(16) = WD_SONIC_SST       'Wind direction in CSAT coordinate system (0 to 360 degree)
Alias cov_out_sonic_SST(17) = WD_SIGMA_SST

' Steady State Test after coordinate rotations
Dim U_SST
Dim U_Var_SST
Dim UV_Cov_SST
Dim UW_Cov_SST
Dim V_SST
Dim V_Var_SST
Dim VW_Cov_SST
Dim W_SST
Dim W_Var_SST
Dim UT_SONIC_Cov_SST
Dim VT_SONIC_Cov_SST
Dim WT_SONIC_Cov_SST

' Data quality grading
Public TAU_SSITC_TEST                'Results of the Steady State and Integral Turbulence Charactoeristics for TAU according to Foken et al (2004)
Public H_SSITC_TEST                  'Results of the Steady State and Integral Turbulence Charactoeristics for H according to Foken et al (2004)
Units  TAU_SSITC_TEST = adimensional
Units  H_SSITC_TEST   = adimensional

Public TAU_QC                        'Overall grade of data QC for momentum flux (i.e. for variable: TAU) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Public H_QC                          'Overall grade of data QC for sensible heat flux (i.e. for variable: H) [1 (highest) to 9 (lowest)] according to Foken et al (2012)
Units TAU_QC = Grade
Units H_QC   = Grade

'*** Footprint characteristics: Constant and variables ***
' Footprint characteristics
Const  NMBR_INT_INTERV_SEGMENT = 20  'Unique: Base number of numerical integration intervals for footprint characteristics in each integration segment

Public FETCH_MAX                     'Upwind location of source/sink that contributes most to the measured flux
Public FETCH_90                      'Upwind range within which the source/sink contributes 90% to the measured flux
Public FETCH_55                      'Upwind range within which the source/sink contributes 55% to the measured flux
Public FETCH_40                      'Upwind range within which the source/sink contributes 40% to the measured flux
Public UPWND_DIST_INTRST             'Upwind distant of interest
Public FTPRNT_DIST_INTRST            'Cumulative footprint of measured scalar flux within upwind range of interest

Units FETCH_MAX = m
Units FETCH_90  = m
Units FETCH_55  = m
Units FETCH_40  = m
Units UPWND_DIST_INTRST = m
Units FTPRNT_DIST_INTRST = %

Public FTPRNT_EQUATION As String * 14   '"Kljun et al" or "KormannMeixner"
Units  FTPRNT_EQUATION = authors

'Raw data table
DataTable (delay_3d, TRUE, OFFSET)
  TableHide
  Sample (5, sonic_irga_raw(1), IEEE4)             'Sonic data: Ux, Uy, Uz, Ts, and diag_sonic 
EndTable

' 5-minute covariance of CSAT data for steady state tests
DataTable (comp_cov_3d_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 1)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4, sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4, sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4, sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4, sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from CSAT data.
  Average    (1,Uz, IEEE4, sonic_disable_f)       'Using sonic(4)
  Covariance (1,Uz, IEEE4, sonic_disable_f, 1)    'Using sonic(4)

  'Compute covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Covariance (4, Ts, IEEE4, sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
EndTable

' 30-minute covariance of CSAT data
DataTable (comp_cov_3d, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  'Compute Ux mean and covariance of Ux with Ux, Uy, and Uz from CSAT data.
  Average    (1, Ux, IEEE4,sonic_disable_f)      'Using sonic(2)
  Covariance (3, Ux, IEEE4,sonic_disable_f, 3)   'Using sonic(2), sonic(3), and sonic(4)

  'Compute Uy mean and covariance of Uy with, Uy, Uz from CSAT data.
  Average    (1, Uy, IEEE4,sonic_disable_f)      'Using sonic(3)
  Covariance (2, Uy, IEEE4,sonic_disable_f, 2)   'Using sonic(3) and sonic(4)

  'Compute Uz mean and covariance of Uz with Uz from CSAT data.
  Average    (1, Uz, IEEE4,sonic_disable_f)      'Using sonic(4)
  Covariance (1, Uz, IEEE4,sonic_disable_f, 1)   'Using sonic(4)

  'Compute Ts mean and covariance of Ts with Ts, Ux, Uy, and Uz from CSAT data.
  Average    (1, Ts, IEEE4,sonic_disable_f)      'Using sonic(1)
  Covariance (4, Ts, IEEE4,sonic_disable_f, 4)   'Using sonic(1), sonic(2), sonic(3), sonic(4)

  WindVector (1, Uy, Ux, IEEE4, sonic_disable_f, 0, 1, 2)
  
  'Compute the maximum of wind speed in an averaging interval 
  Maximum (1, U_rslt, IEEE4, sonic_disable_f, False)

EndTable
'*** END OF CSAT SONIC HEAD：CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
  

'************************************************************************
'*** BEGINNING OF IRGA： CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***
'************************************************************************
Const DELAY_EC100               = INT ((4000/BANDWIDTH)/SCAN_INTERVAL) 'Automatically compute the electronic instrument lag of EC100 data in scan number
Const EC100_REC_BCK             = OFFSET - DELAY_EC100                 'Number of records back for aligning EC100 data with other sensor data in scan
Const PATH_LENGTH_IRGA          = 0.1531                               'IRGA path length (m).
Const CO2_SIG_STRGTH_THRESHOULD = 0.7                                  'Unique: CO2 signal strength threshold below which the CO2 data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const H2O_SIG_STRGTH_THRESHOULD = 0.7                                  'Unique: H2O signal strength threshold below which the H2O data are not used in instructions of AVERAGE and COVARIANCE, but kept in time series data table
Const CO2_RNG_TOP_LIMIT         = 1527                                 'Unique: CO2 top range in mg/m^3. given IRGA calibrated in range of 0 ~ 1000 ppm CO2 in dry air at 25 C of air temperature in lab and at 86 kPa of pressure in Logan 
Const H2O_RNG_TOP_LIMIT         = 45.8                                 'Unique: H2O top range in g/m^3. given IRGA calibrated in range to dew point temperature at 25 C of air temperature in lab and at 86 kPa of pressure in Logan 

' Variables for separation corrections
Public separation_lat_dist_irga    'Effective separation distance (m) in direction normal to wind direction. Used for separation correction
Public separation_lag_dist_irga    'Effective separation distance (m) along wind direction. Used for lag maximization of covariance
Public separation_lag_scan_irga    'Lag of wind passing over IRGA (scans) after (+ lag) or before (- lag) passing CSAT. Its unit is a scan number, but not necessary to use an integer

Units  separation_lat_dist_irga  =  m
Units  separation_lag_dist_irga  =  m
Units  separation_lag_scan_irga  =  scans

' Data from IRGA
Public irga(22)                     'Hold IRGA data
Alias irga(1)  = CO2_density
Alias irga(2)  = H2O_density
Alias irga(3)  = diag_irga
Alias irga(4)  = amb_tmpr           'Air temperature measured by 107 temperature probe connected to EC100
Alias irga(5)  = amb_press          'Pressure measured by a barometer connected to EC100
Alias irga(6)  = CO2_sig_strgth
Alias irga(7)  = H2O_sig_strgth
Alias irga(8)  = amb_RH             'Relative humidity (%): derived from amb_tmpr, H2O, and amb_press
Alias irga(9)  = amb_T_DP           'Dew point temperature (C): derived from amb_tmpr, H2O, and amb_press
Alias irga(10) = amb_e_sat          'Saturation vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias irga(11) = amb_e              'Vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias irga(12) = amb_rho_d          'Dry air density (g/m^3): derived from amb_tmpr, H2O, and amb_press
Alias irga(13) = amb_rho_a          'Moist air density (kg/m^3): derived from amb_tmpr, H2O, and amb_press
Alias irga(14) = Tc                 'Air temperature (C), found from IRGASON Ts, H2O_density, and amb_press
Alias irga(15) = RH                 'Relative humidity (%): derived from Tc, H2O, and amb_press
Alias irga(16) = T_DP               'Dew point temperature (C): derived from Tc, H2O, and amb_press
Alias irga(17) = e_sat              'Saturation vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias irga(18) = e                  'Vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias irga(19) = rho_d              'Dry air density (g/m^3): derived from Tc, H2O, and amb_press
Alias irga(20) = rho_a              'Moist air density (g/m^3): derived from Tc, H2O, and amb_press
Alias irga(21) = CO2_mixratio       'CO2 mixing ratio
Alias irga(22) = H2O_mixratio       'H2O mixing ratio
Units CO2_density     = mg m-3
Units H2O_density     = g m-3
Units diag_irga       = adimensional
Units amb_tmpr        = deg C
Units amb_press       = kPa
Units CO2_sig_strgth  = fraction
Units H2O_sig_strgth  = fraction
Units amb_RH          = %
Units amb_T_DP        = deg C
Units amb_e_sat       = kPa
Units amb_e           = kPa
Units amb_rho_d       = g m-3
Units amb_rho_a       = kg m-3
Units Tc              = deg C
Units RH              = %
Units T_DP            = deg C
Units e_sat           = kPa
Units e               = kPa
Units rho_d           = g m-3
Units rho_a           = kg m-3
Units CO2_mixratio    = umol/mol
Units H2O_mixratio    = mmol/mol

Dim diag_bits_irga(22) As Boolean                'Gas analyzer warning flags
Alias diag_bits_irga(1)  = irga_bad_data_f       'EC150 bad data warning flag
Alias diag_bits_irga(2)  = irga_gen_fault_f      'General fault warning flag
Alias diag_bits_irga(3)  = irga_startup_f        'Gas analyzer starting up warning flag
Alias diag_bits_irga(4)  = irga_motor_spd_f      'EC150 motor speed out of bounds warning flag
Alias diag_bits_irga(5)  = irga_tec_tmpr_f       'Thermoelectric cooler temperature out of bounds warning flag
Alias diag_bits_irga(6)  = irga_src_pwr_f        'Gas analyzer source power out of bounds warning flag
Alias diag_bits_irga(7)  = irga_src_tmpr_f       'Gas analyzer source temperature out of bounds warning flag
Alias diag_bits_irga(8)  = irga_src_curr_f       'Gas analyzer source current out of bounds warning flag
Alias diag_bits_irga(9)  = irga_off_f            'Gas analyzer head is powered down
Alias diag_bits_irga(10) = irga_sync_f           'Gas analyzer not synchronized with home pulse warning flag
Alias diag_bits_irga(11) = irga_amb_tmpr_f       'Invalid ambient temperature warning flag
Alias diag_bits_irga(12) = irga_amb_press_f      'Invalid ambient pressure warning flag
Alias diag_bits_irga(13) = irga_CO2_I_f          'CO2 I out of bounds warning flag
Alias diag_bits_irga(14) = irga_CO2_Io_f         'CO2 Io out of bounds warning flag
Alias diag_bits_irga(15) = irga_H2O_I_f          'H2O I out of bounds warning flag
Alias diag_bits_irga(16) = irga_H2O_Io_f         'H2O Io out of bounds warning flag
Alias diag_bits_irga(17) = irga_CO2_Io_var_f     'CO2 Io moving variation out of bounds warning flag
Alias diag_bits_irga(18) = irga_H2O_Io_var_f     'H2O Io moving variation out of bounds warning flag
Alias diag_bits_irga(19) = irga_CO2_sig_strgth_f 'CO2 signal strength warning flag
Alias diag_bits_irga(20) = irga_H2O_sig_strgth_f 'H2O signal strength warning flag
Alias diag_bits_irga(21) = irga_cal_err_f        'Gas analyzer calibration data signature error
Alias diag_bits_irga(22) = irga_htr_ctrl_off_f   'Gas analyzer heater control disabled by EC100
Units diag_bits_irga     = adimensional

'Working variables
Dim divisor                                 'Temporary variable used to find molar mixing ratio.
Dim diag_irga_tmp  As Long                  'Temporary variable used to break out the EC150 diagnostic bits.
Dim irga_disable_f As Boolean               'TRUE when EC150 sends bad data.

Dim sigma_wpl                               'Webb et al. sigma = density of water vapor/density of dry air.
Dim Td_gu, Tc_K                             'Working variables: Dew point temperature for general use (gu) and Tc in K.
Dim Enhance_Factor1, Enhance_Factor2        'Enhancement factors, both used for calculations of dew point temperature

' CO2: Lag maximization
Dim cov_array_CO2(2* MAX_LAG+1, 5)          'Arrays used to hold the CO2 data with -2, -1, 0, 1, or 2 scan lags relative to CSAT data in order to find
'the lag that maximizes the covariance of CO2 with w. Once the optimum lag is found, it is also applied to
'H2O to find the maximum covariance of H2O with w because CO2 and H2O are measured using the same IRGA.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -2, -1, 0, 1, 2 scans. Columns used for CO2_density, Ux, Uy, Uz, and CO2 (umolCO2 mol-1).

Dim irga_bad_data_flg_array (2* MAX_LAG + 1) As Boolean
Dim CO2_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if CO2 out of range or CO2 signal strength below the CO2 signal strength threshould
Dim H2O_bad_rng_sig_array (2* MAX_LAG + 1)   As Boolean    'Set high if H2O out of range or H2O signal strength below the H2O signal strength threshould

Dim Cov_out_CO2(7*(2*MAX_LAG + 1))                     'CO2 variable and CO2-related covariance variables
'b2 indicates backward 2 scans.
Alias Cov_out_CO2(1)  = CO2_Avg_lag_b2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(2)  = CO2_Var_lag_b2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(3)  = CO2_density_Avg_lag_b2         'CO2 in mg m-3  
Alias Cov_out_CO2(4)  = CO2_density_Var_lag_b2         'CO2 in mg m-3  
Alias Cov_out_CO2(5)  = UxCO2_Cov_lag_b2               'CO2 in mg m-3  
Alias Cov_out_CO2(6)  = UyCO2_Cov_lag_b2               'CO2 in mg m-3   
Alias Cov_out_CO2(7)  = UzCO2_Cov_lag_b2               'CO2 in mg m-3  
'b1 indicates backward 1 scan
Alias Cov_out_CO2(8)  = CO2_Avg_lag_b1                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(9)  = CO2_Var_lag_b1                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(10) = CO2_density_Avg_lag_b1         'CO2 in mg m-3                
Alias Cov_out_CO2(11) = CO2_density_Var_lag_b1         'CO2 in mg m-3  
Alias Cov_out_CO2(12) = UxCO2_Cov_lag_b1               'CO2 in mg m-3  
Alias Cov_out_CO2(13) = UyCO2_Cov_lag_b1               'CO2 in mg m-3  
Alias Cov_out_CO2(14) = UzCO2_Cov_lag_b1               'CO2 in mg m-3  
'0 indicates neither backward nor forward. 
Alias Cov_out_CO2(15) = CO2_Avg_lag_0                  'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(16) = CO2_Var_Lag_0                  'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(17) = CO2_density_Avg_lag_0          'CO2 in mg m-3      
Alias Cov_out_CO2(18) = CO2_density_Var_lag_0          'CO2 in mg m-3
Alias Cov_out_CO2(19) = UxCO2_Cov_lag_0                'CO2 in mg m-3
Alias Cov_out_CO2(20) = UyCO2_Cov_lag_0                'CO2 in mg m-3
Alias Cov_out_CO2(21) = UzCO2_Cov_lag_0                'CO2 in mg m-3
'f1 indicates forward 1 scan. 
Alias Cov_out_CO2(22) = CO2_Avg_lag_f1                 'CO2 in umolCO2 mol-1 
Alias Cov_out_CO2(23) = CO2_Var_lag_f1                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(24) = CO2_density_Avg_lag_f1         'CO2 in mg m-3            
Alias Cov_out_CO2(25) = CO2_density_Var_lag_f1         'CO2 in mg m-3
Alias Cov_out_CO2(26) = UxCO2_Cov_lag_f1               'CO2 in mg m-3
Alias Cov_out_CO2(27) = UyCO2_Cov_lag_f1               'CO2 in mg m-3
Alias Cov_out_CO2(28) = UzCO2_Cov_lag_f1               'CO2 in mg m-3
'f2 indicates forward 2 scans
Alias Cov_out_CO2(29) = CO2_Avg_lag_f2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(30) = CO2_Var_lag_f2                 'CO2 in umolCO2 mol-1
Alias Cov_out_CO2(31) = CO2_density_Avg_f2             'CO2 in mg m-3              
Alias Cov_out_CO2(32) = CO2_density_Cov_lag_f2         'CO2 in mg m-3
Alias Cov_out_CO2(33) = UxCO2_Cov_lag_f2               'CO2 in mg m-3
Alias Cov_out_CO2(34) = UyCO2_Cov_lag_f2               'CO2 in mg m-3
Alias Cov_out_CO2(35) = UzCO2_Cov_lag_f2               'CO2 in mg m-3

' Variables after coordinate rotations as indicated by W for Uz
Dim   WCO2_Cov_lag (2*MAX_LAG + 1)                     'Hold covariance of scan-lagged CO2 with W after coordinate rotation. Used for MaxSpa instruction
Alias WCO2_Cov_lag (1) = WCO2_Cov_lag_b2               'b2 indicates backward 2 scans.
Alias WCO2_Cov_lag (2) = WCO2_Cov_lag_b1               'b1 indicates backward 1 scans.
Alias WCO2_Cov_lag (3) = WCO2_Cov_lag_0                '0 indicates 0 lag in scans.
Alias WCO2_Cov_lag (4) = WCO2_Cov_lag_f1               'f1 indicates forward 1 scans.
Alias WCO2_Cov_lag (5) = WCO2_Cov_lag_f2               'f2 indicates forward 2 scans.

Dim wCO2_Cov_major_sign                                'Summarize the direction of CO2 flux (positive: up and negative: down)

Dim   UCO2_VCO2_Cov_lag(2*MAX_LAG + 1, 2)              'Hold the covariance of scan-lagged CO2 with u or v after coordinate rotation
Alias UCO2_VCO2_Cov_lag(1, 1) = UCO2_Cov_lag_b2        'b2 indicates backward 2 scans. 
Alias UCO2_VCO2_Cov_lag(1, 2) = VCO2_Cov_lag_b2
Alias UCO2_VCO2_Cov_lag(2, 1) = UCO2_Cov_lag_b1        'b1 indicates backward 1 scans.
Alias UCO2_VCO2_Cov_lag(2, 2) = VCO2_Cov_lag_b1
Alias UCO2_VCO2_Cov_lag(3, 1) = UCO2_Cov_lag_0         '0 indicates 0 lag in scans.
Alias UCO2_VCO2_Cov_lag(3, 2) = VCO2_Cov_lag_0
Alias UCO2_VCO2_Cov_lag(4, 1) = UCO2_Cov_lag_f1        'f1R indicates forward 1 scans.
Alias UCO2_VCO2_Cov_lag(4, 2) = VCO2_Cov_lag_f1
Alias UCO2_VCO2_Cov_lag(5, 1) = UCO2_Cov_lag_f2        'f2R indicates forward 2 scans.
Alias UCO2_VCO2_Cov_lag(5, 2) = VCO2_Cov_lag_f2
Units UCO2_VCO2_Cov_lag       = mg m-2 s-1

Dim   WCO2_Cov_lag_max (2)                  'Array used in MaxSpa instruction to hold the max covariance and the location of the max covariance in array: wCO2_Cov_lag_R()
Alias WCO2_Cov_lag_max (1) = WCO2_Cov       'Max covariance found from lagged covariance array [.i.e. wCO2_cov_lag_R()] and will be used for CO2 flux after freq correction
Alias WCO2_Cov_lag_max (2) = lag_irga       'Lag in number of scans, also used for sequential number in array index of lag wCO2_Cov_lag_R() and uCO2_vCO2_Cov_lag_R()
Units WCO2_Cov             = mg m-2 s-1
Units lag_irga             = scans

' H2O: Lag maximization
Dim cov_array_H2O(2* MAX_LAG+1, 5)          'Arrays used to hold the H2O data with -2, -1, 0, 1, or 2 scan lags relative to CSAT data. The optimum lag_irga found during maximization
'of covariance of CO2 with w is assumed to also be the optimum lag for H2O data since the same IRGA measures both CO2 and H2O.
'Data are held in an array for more convenient calculation of covariances.
'Row used for lag of -2, -1, 0, 1, 2 scans. Columns used for H2O_density, Ux, Uy, and Uz, H2O (mmolH2O mol-1).

Dim Cov_out_H2O(7*(2*MAX_LAG + 1))          'H2O variables and H2O-related covariances
'b2 indicates backward 2 scans
Alias Cov_out_H2O(1)  = H2O_Avg_lag_b2                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(2)  = H2O_Var_lag_b2                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(3)  = H2O_density_Avg_lag_b2           'H2O in g m-3
Alias Cov_out_H2O(4)  = H2O_density_Var_lag_b2           'H2O in g m-3
Alias Cov_out_H2O(5)  = UxH2O_Cov_lag_b2                 'H2O in g m-3
Alias Cov_out_H2O(6)  = UyH2O_Cov_lag_b2                 'H2O in g m-3
Alias Cov_out_H2O(7)  = UzH2O_Cov_lag_b2                 'H2O in g m-3
'b1 indicates backward 1 scan
Alias Cov_out_H2O(8)  = H2O_Avg_lag_b1                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(9)  = H2O_Var_lag_b1                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(10) = H2O_density_Avg_lag_b1           'H2O in g m-3    
Alias Cov_out_H2O(11) = H2O_density_Var_lag_b1           'H2O in g m-3
Alias Cov_out_H2O(12) = UxH2O_Cov_lag_b1                 'H2O in g m-3
Alias Cov_out_H2O(13) = UyH2O_Cov_lag_b1                 'H2O in g m-3
Alias Cov_out_H2O(14) = UzH2O_Cov_lag_b1                 'H2O in g m-3
'0 indicates neither backward nor forward
Alias Cov_out_H2O(15) = H2O_Avg_lag_0                    'H2O in mmolH2O mol-1
Alias Cov_out_H2O(16) = H2O_Var_lag_0                    'H2O in mmolH2O mol-1
Alias Cov_out_H2O(17) = H2O_density_Avg_lag_0            'H2O in g m-3    
Alias Cov_out_H2O(18) = H2O_density_Var_lag_0            'H2O in g m-3
Alias Cov_out_H2O(19) = UxH2O_Cov_lag_0                  'H2O in g m-3
Alias Cov_out_H2O(20) = UyH2O_Cov_lag_0                  'H2O in g m-3
Alias Cov_out_H2O(21) = UzH2O_Cov_lag_0                  'H2O in g m-3
'f1 indicates forward 1 scan
Alias Cov_out_H2O(22) = H2O_Avg_lag_f1                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(23) = H2O_Var_lag_f1                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(24) = H2O_density_Avg_lag_f1           'H2O in g m-3    
Alias Cov_out_H2O(25) = H2O_density_Var_lag_f1           'H2O in g m-3
Alias Cov_out_H2O(26) = UxH2O_Cov_lag_f1                 'H2O in g m-3
Alias Cov_out_H2O(27) = UyH2O_Cov_lag_f1                 'H2O in g m-3
Alias Cov_out_H2O(28) = UzH2O_Cov_lag_f1                 'H2O in g m-3
'f2 indicates forward 2 scans
Alias Cov_out_H2O(29) = H2O_Avg_lag_f2                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(30) = H2O_Var_lag_f2                   'H2O in mmolH2O mol-1
Alias Cov_out_H2O(31) = H2O_density_Avg_lag_f2           'H2O in g m-3    
Alias Cov_out_H2O(32) = H2O_density_Var_lag_f2           'H2O in g m-3
Alias Cov_out_H2O(33) = UxH2O_Cov_lag_f2                 'H2O in g m-3
Alias Cov_out_H2O(34) = UyH2O_Cov_lag_f2                 'H2O in g m-3
Alias Cov_out_H2O(35) = UzH2O_Cov_lag_f2                 'H2O in g m-3

' Before coordinate rotations. Lag due to separation was applied if measured by EC150 +CSAT3A
Dim Cov_out_cs(29)                                       'IRGA statistics.
Alias Cov_out_cs(1)  = CO2                               'Average CO2 mixing ratio in umolCO2 mol-1
Alias Cov_out_cs(2)  = CO2_SIGMA                         'CO2 mixing ratio standard deviation in umolCO2 mol-1
Alias Cov_out_cs(3)  = CO2_density_Avg                   'Average CO2 mass density in mg m-3
Alias Cov_out_cs(4)  = CO2_density_SIGMA                 'CO2 mass density standard deviation in mg m-3
Alias Cov_out_cs(5)  = UxCO2_Cov                         'Covariance of CO2 mass density with Ux in mg m-2 s-1
Alias Cov_out_cs(6)  = UyCO2_Cov                         'Covariance of CO2 mass density with Uy in mg m-2 s-1
Alias Cov_out_cs(7)  = UzCO2_Cov                         'Covariance of CO2 mass density with Uz in mg m-2 s-1
Alias Cov_out_cs(8)  = H2O                               'Average H2O mixing ratio in mmolH2O mol-1
Alias Cov_out_cs(9)  = H2O_SIGMA                         'H2O mixing ratio standard deviation in mmolH2O mol-1
Alias Cov_out_cs(10) = H2O_density_Avg                   'Average H2O mass density in g m-3
Alias Cov_out_cs(11) = H2O_density_SIGMA                 'H2O mass density standard deviation in g m-3
Alias Cov_out_cs(12) = UxH2O_Cov                         'Covariance of H2O mass density with Ux in g m-2 s-1
Alias Cov_out_cs(13) = UyH2O_Cov                         'Covariance of H2O mass density with Uy in g m-2 s-1
Alias Cov_out_cs(14) = UzH2O_Cov                         'Covariance of H2O mass density with Uz in g m-2 s-1
Alias Cov_out_cs(15) = TA_1_1_1                          'Average temperature from 107-probe connected to EC100
Alias Cov_out_cs(16) = RH_1_1_1                          'Average relative humidity (%): derived from 107 probe temperature ( amb_tmpr), H2O, and amb_press
Alias Cov_out_cs(17) = T_DP_1_1_1                        'Average dew point temperature (C): derived from 107 probe temperature (amb_tmpr), H2O, and amb_press
Alias Cov_out_cs(18) = amb_e_sat_Avg                     'Average saturation vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(19) = amb_e_Avg                         'Average vapor pressure (kPa): derived from amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(20) = amb_rho_d_Avg                     'Density of dry air (g/m^3). calculated using the average data of amb_tmpr, H2O, and amb_press
Alias Cov_out_cs(21) = amb_rho_a_Avg                     'Density of moist air (kg/m^3). calculated using the average data ofamb_tmpr, H2O, and amb_press
Alias Cov_out_cs(22) = TA_2_1_1                          'Average air temperature (C), found from IRGASON sonic temperature, H2O, and amb_press
Alias Cov_out_cs(23) = RH_2_1_1                          'Average relative humidity (%): derived from IRGASON sonic temperature, H2O, and amb_press
Alias Cov_out_cs(24) = T_DP_2_1_1                        'Average dew point tempearture (C): derived from IRGASON sonic temperature, H2O, and amb_press
Alias Cov_out_cs(25) = e_sat_Avg                         'Average saturation vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias Cov_out_cs(26) = e_Avg                             'Average vapor pressure (kPa): derived from Tc, H2O, and amb_press
Alias Cov_out_cs(27) = rho_d_Avg                         'Density of dry air (g/m^3). calculated using the average data of Tc, H2O, and amb_press
Alias Cov_out_cs(28) = rho_a_Avg                         'Density of moist air (kg/m^3). calculated using the average data of Tc, H2O, and amb_press
Alias Cov_out_cs(29) = PA                                'Average atmospheric pressure 
Units CO2               = umolCO2 mol-1
Units CO2_SIGMA         = umolCO2 mol-1
Units CO2_density_Avg   = mg m-3
Units CO2_density_SIGMA = mg m-3
Units UxCO2_Cov         = mg m-2 s-1
Units UyCO2_Cov         = mg m-2 s-1
Units UzCO2_Cov         = mg m-2 s-1
Units H2O               = mmolH2O mol-1
Units H2O_SIGMA         = mmolH2O mol-1
Units H2O_density_Avg   = g m-3
Units H2O_density_SIGMA = g m-3
Units UxH2O_Cov         = g m-2 s-1
Units UyH2O_Cov         = g m-2 s-1
Units UzH2O_Cov         = g m-2 s-1
Units TA_1_1_1          = deg C
Units RH_1_1_1          = %
Units T_DP_1_1_1        = deg C
Units amb_e_sat_Avg     = kPa
Units amb_e_Avg         = kPa
Units amb_rho_d_Avg     = g m-3
Units amb_rho_a_Avg     = kg m-3
Units TA_2_1_1          = deg C
Units RH_2_1_1          = %
Units T_DP_2_1_1        = deg C
Units e_sat_Avg         = kPa
Units e_Avg             = kPa
Units rho_d_Avg         = g m-3
Units rho_a_Avg         = kg m-3
Units PA                = kPa

Public VPD                                               'ambient water vapor pressure deficit
Units  VPD = hPa

'After coordinate rotations as indicated by U for Ux, V for Uy and W for Uz
Dim UCO2_Cov
Dim VCO2_Cov
'For WCO2_Cov, see WCO2_Cov_lag_max (1)
Units UCO2_Cov  = mg m-2 s-1
Units VCO2_Cov  = mg m-2 s-1

Dim UH2O_Cov
Dim VH2O_Cov
Dim WH2O_Cov                                            'found using lag_irga that was found while WCO2_cov was found
Units UH2O_Cov  = g m-2 s-1
Units VH2O_Cov  = g m-2 s-1
Units WH2O_Cov  = g m-2 s-1

' After coordinate rotations and freq corrections as indicated by "fc"
Dim WCO2_Cov_fc
Dim WH2O_Cov_fc
Units WCO2_Cov_fc = mg m-2 s-1
Units WH2O_Cov_fc = g m-2 s-1

' WPL correction terms after coordinate rotations and freq corrections as indicated by "fc"
Dim CO2_E_WPL_fc                    'Carbon dioxide flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim CO2_T_WPL_fc                    'Carbon dioxide flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Dim H2O_E_WPL_fc                    'Water vapor flux, WPL term due to water vapor flux (covariance of water vapor with vertical velocity)
Dim H2O_T_WPL_fc                    'Water vapor flux, WPL term due to temperature flux (covariance of temperature with vertical velocity)
Units CO2_E_WPL_fc = mg m-2 s-1
Units CO2_T_WPL_fc = mg m-2 s-1
Units H2O_E_WPL_fc = g m-2 s-1
Units H2O_T_WPL_fc = g m-2 s-1

' After coordinate rotations, freq corrections, and WPL correction
Public FC                            'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in umol/m^2 s
Public FC_mass                       'Carbon dioxide flux after coordinate rotation, freq, and WPL corrections in mg/m^2 s
Public LE                            'Latent heat flux after coordinate rotation, freq, and WPL corrections
Units FC      = umolCO2 m-2 s-1
Units FC_mass = mg m-2 s-1
Units LE      = W m-2

Public Bowen_ratio
Units  Bowen_ratio = fraction

'*** Variables for data QC
' Steady State Test
Public RN_WCO2_Cov             'Relative Non-stationarity (RN) for wCO2_cov_R.
Public RN_WH2O_Cov             'Relative non-stationarity for wH2O_cov_R.
Public nmbr_interval_qc_irga   'Number of sub-intervals = (OUTPUT_INTERVAL in min)/(5 min) if not a 1st interval or CR6 starts before 5 min after an individual interval

Dim cov_out_irga_SST(8)        'IRGA statistics for Steady State Test (SST)
Alias cov_out_irga_SST(1) = CO2_density_var_SST
Alias cov_out_irga_SST(2) = UxCO2_Cov_SST
Alias cov_out_irga_SST(3) = UyCO2_Cov_SST
Alias cov_out_irga_SST(4) = UzCO2_Cov_SST
Alias cov_out_irga_SST(5) = H2O_density_var_SST
Alias cov_out_irga_SST(6) = UxH2O_Cov_SST
Alias cov_out_irga_SST(7) = UyH2O_Cov_SST
Alias cov_out_irga_SST(8) = UzH2O_Cov_SST

' After coordinate rotations
Dim UCO2_Cov_SST
Dim VCO2_Cov_SST
Dim WCO2_Cov_SST
Dim UH2O_Cov_SST
Dim VH2O_Cov_SST
Dim WH2O_Cov_SST

' Overall grade of data quality for CO2 and H2O fluxes
Public FC_SSITC_TEST                  'Results of the Steady State and Integral Turbulence Charactoeristics for FC according to Foken et al (2004)
Public LE_SSITC_TEST                  'Results of the Steady State and Integral Turbulence Charactoeristics for LE according to Foken et al (2004)
Units  FC_SSITC_TEST = adimensional
Units  LE_SSITC_TEST = adimensional

Public FC_QC              'Overall grade of data quality for CO2 flux (i.e. for variable: FC and FC_mass) [1 (highest) to 9 (lowest)]
Public LE_QC              'Overall grade of data quality for latent heat flux (i.e. for variable: LE) [1 (highest) to 9 (lowest)]
Units  FC_QC = Grade
Units  LE_QC = Grade

'Data table for delayed data from IRGA
DataTable (delay_cs, TRUE, (OFFSET + MAX_LAG))
  TableHide
  Sample (7,sonic_irga_raw(6),IEEE4)          'CO2, H2O, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, H2O_sig_strgth
EndTable

' 5-minute statistics
DataTable (comp_cov_cs_5min, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL_SST, Min, 1)
  
  Covariance (4, cov_array_CO2((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR CO2_bad_rng_sig_array(MAX_LAG+1)),4)
  Covariance (4, cov_array_H2O((MAX_LAG + 1), 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(MAX_LAG + 1) OR H2O_bad_rng_sig_array(MAX_LAG+1)),4)

EndTable

'Compute covariance of CO2 against CSAT wind data.
DataTable (comp_cov_CO2, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average    (1, cov_array_CO2(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(1, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),1)   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)))
  Covariance (4, cov_array_CO2(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR CO2_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_CO2(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(2, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),1)   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)))
  Covariance (4, cov_array_CO2(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR CO2_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_CO2(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(3, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),1)   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)))
  Covariance (4, cov_array_CO2(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR CO2_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_CO2(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(4, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),1)   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)))
  Covariance (4, cov_array_CO2(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR CO2_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_CO2(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))                        'CO2 in umolCO2 mol-1
  Covariance (1, cov_array_CO2(5, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),1)   'CO2 in umolCO2 mol-1
  Average    (1, cov_array_CO2(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)))
  Covariance (4, cov_array_CO2(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR CO2_bad_rng_sig_array(5)),4)
EndTable

'Compute covariance of H2O against CSAT wind data.
DataTable (comp_cov_H2O, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average    (1, cov_array_H2O(1, 5), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(1, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),1)   'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(1, 1), IEEE4, (irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)))
  Covariance (4, cov_array_H2O(1, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(1) OR H2O_bad_rng_sig_array(1)),4)

  Average    (1, cov_array_H2O(2, 5), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(2, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),1)   'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(2, 1), IEEE4, (irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)))
  Covariance (4, cov_array_H2O(2, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(2) OR H2O_bad_rng_sig_array(2)),4)

  Average    (1, cov_array_H2O(3, 5), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(3, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),1)   'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(3, 1), IEEE4, (irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)))
  Covariance (4, cov_array_H2O(3, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(3) OR H2O_bad_rng_sig_array(3)),4)

  Average    (1, cov_array_H2O(4, 5), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(4, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),1)   'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(4, 1), IEEE4, (irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)))
  Covariance (4, cov_array_H2O(4, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(4) OR H2O_bad_rng_sig_array(4)),4)

  Average    (1, cov_array_H2O(5, 5), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))                        'H2O in mmolH2O mol-1
  Covariance (1, cov_array_H2O(5, 5), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),1)   'H2O in mmolH2O mol-1
  Average    (1, cov_array_H2O(5, 1), IEEE4, (irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)))
  Covariance (4, cov_array_H2O(5, 1), IEEE4, (sonic_disable_f OR irga_bad_data_flg_array(5) OR H2O_bad_rng_sig_array(5)),4)
EndTable

'Compute Tc-related data.
DataTable (comp_mean, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)
  Average (1, amb_tmpr, IEEE4, irga_amb_tmpr_f)
  Average (1, amb_RH,   IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR (amb_RH > 100) OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (5, amb_T_DP, IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1))                      'amb_T_DP, amb_e_sat, amb_e, amb_rho_d, amb_rho_a
  
  Average (1, Tc,       IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (1, RH,       IEEE4, (irga_disable_f OR sonic_disable_f OR (RH > 100) OR H2O_bad_rng_sig_array(MAX_LAG +1))
  Average (5, T_DP,     IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1))                      'T_DP, e_sat, e, rho_d, rho_a

  Average (1, amb_press, IEEE4, irga_amb_press_f)

EndTable
'*** END OF IRGA： CONSTANTS, VARIABLES, AND WORKING DATA TABLES ***

#If (PERIPHERAL_CDM_A116) Then
  
'**********************************************
'*** BEGINNING OF CDM_A100 SERIES CONSTANTS ***
'**********************************************
Const CDM_SN                  = 0000                   'Unique: CDM-A116 serial number 
Const CPI_ADDR_CDM            = 2                      'Unique: CPI address for CDM-A116
Const CPI_DEVICE_DSCRPTN      = "EasyFlux_CDM_A116"    'Unique: CDM Module name or identifier 
Const CDM_MODEL               = CDM_A116               'CDM Model
Const CDM_1ST_PANEL_TMPR_CHAN = 1                      'Starting terminal group for CDM panel temperature measurement 
Const NMBR_PANEL_TMPR_CDM     = 4                      'Number of terminal groups (and terminal panel temperature measurements): 4 for CDM-A116  
'*** END OF CDM_A100 SERIES CONSTANTS ***      
#EndIf 
#If (SENSOR_FW) Then  


'*********************************************************************
'*** BEGINNING OF FW: CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
'*********************************************************************
Public time_const_FW = 0.001            'Default value (seconds). It will be recalculated inside the program
Units  time_const_FW = s

Public FW                               'Air temperature measured using fine wire thermocouple
Units  FW = deg C

'Raw and not lagged FW data.
Dim FW_raw                              'Air temperature measured using fine wire thermocouple
Dim diag_FW_raw                         'Boolean type is not used because this variable is an element of numerical array: dly_data_out() 
Dim dly_data_FW_out(2)                  'Array used to temporarily store the lagged record from the raw data table for FW measurements (hidden)

Public separation_lat_dist_FW           'effective separation distance in direction normal to wind direction. Used for separation correction.    
Public separation_lag_dist_FW           'effective separation distance along wind direction. Used for time lag maximization.  
Public separation_lag_scan_FW           'lag in scan number. Wind passing FW1 after (+) or before (-) passing CSAT. Not necessary to use an integer.
Units  separation_lat_dist_FW = m 
Units  separation_lag_dist_FW = m
Units  separation_lag_scan_FW = scans

Dim Cov_array_FW(2* MAX_LAG + 1, 4)      'Arrays used to hold the FW data with -2, -1, 0, 1, 2 in sacn lags relative to CSAT data in order 
                                         'to find the max covariance of FW with Uz using lag_FW found in maximization for covariance of FW with Uz
                                         'In form of array for use in the COVARIANCE instructions. 
                                         'Row for lag -2, -1, 0, 1, 2 scans, column: FW, Ux, Uy, and Uz.   
Dim FW_bad_data_flg (2* MAX_LAG + 1) As Boolean

Dim Cov_out_FW(6*(2*MAX_LAG + 1))                'FW statistics and FW-related covariance
'b2 indicates backward 2 scans 
Alias Cov_out_FW(1)  = FW_Avg_lag_b2                 
Alias Cov_out_FW(2)  = FW_Var_lag_b2   
Alias Cov_out_FW(3)  = UxFW_Cov_lag_b2
Alias Cov_out_FW(4)  = UyFW_Cov_lag_b2
Alias Cov_out_FW(5)  = UzFW_Cov_lag_b2
Alias Cov_out_FW(6)  = nmbr_smpl_FW_lag_b2
'b1 indicates backward 1 scan 
Alias Cov_out_FW(7)  = FW_Avg_lag_b1                
Alias Cov_out_FW(8)  = FW_Var_lag_b1   
Alias Cov_out_FW(9)  = UxFW_Cov_lag_b1
Alias Cov_out_FW(10) = UyFW_Cov_lag_b1
Alias Cov_out_FW(11) = UzFW_Cov_lag_b1
Alias Cov_out_FW(12) = nmbr_smpl_FW_lag_b1
'0 indicates neither backward nor forward 
Alias Cov_out_FW(13) = FW_Avg_lag_0                 
Alias Cov_out_FW(14) = FW_Var_lag_0    
Alias Cov_out_FW(15) = UxFW_Cov_lag_0
Alias Cov_out_FW(16) = UyFW_Cov_lag_0
Alias Cov_out_FW(17) = UzFW_Cov_lag_0
Alias Cov_out_FW(18) = nmbr_smpl_FW_lag_0
'f1 indicates forward 1 scan lag
Alias Cov_out_FW(19) = FW_Avg_lag_f1                 
Alias Cov_out_FW(20) = FW_Var_lag_f1   
Alias Cov_out_FW(21) = UxFW_Cov_lag_f1
Alias Cov_out_FW(22) = UyFW_Cov_lag_f1
Alias Cov_out_FW(23) = UzFW_cov_lag_f1
Alias Cov_out_FW(24) = nmbr_smpl_FW_lag_f1
'f2 indicates forward 2 scans
Alias Cov_out_FW(25) = FW_Avg_lag_f2                 
Alias Cov_out_FW(26) = FW_Var_lag_f2   
Alias Cov_out_FW(27) = UxFW_Cov_lag_f2
Alias Cov_out_FW(28) = UyFW_Cov_lag_f2
Alias Cov_out_FW(29) = UzFW_Cov_lag_f2
Alias Cov_out_FW(30) = nmbr_smpl_FW_lag_f2

' Variables after coordinate rotations as indicated by U for Ux, V for Uy, and W for Uz 
Dim   WFW_Cov_lag (2*MAX_LAG + 1)               'Used for instruction of MaxSpa
Alias WFW_Cov_lag (1) = WFW_Cov_lag_b2          'b2 indicates backward 2 scans   
Alias WFW_Cov_lag (2) = WFW_Cov_lag_b1          'b1 indicates backward 1 scan  
Alias WFW_Cov_lag (3) = WFW_Cov_lag_0           '0 indicates neither backward nor forward   
Alias WFW_Cov_lag (4) = WFW_Cov_lag_f1          'f1 indicates forward 1 scan    
Alias WFW_Cov_lag (5) = WFW_Cov_lag_f2          'f2 indicates forward 2 scans  
Units WFW_Cov_lag     = deg C m s-1

Dim   WFW_cov_major_sign                        'Summarize the sign of wFW1_cov: From above array, chose max if positive (up) and min if negative (down)  

Dim   UFW_VFW_Cov_lag(2*MAX_LAG + 1, 2)         'Hold the covariance of lagged FW with U or V after coordinate rotation  
Alias UFW_VFW_Cov_lag(1, 1) = UFW_Cov_lag_b2    'b2 indicates backward 2 scans  
Alias UFW_VFW_Cov_lag(1, 2) = VFW_Cov_lag_b2
Alias UFW_VFW_Cov_lag(2, 1) = UFW_Cov_lag_b1    'b1 indicates backward 1 scan  
Alias UFW_VFW_Cov_lag(2, 2) = VFW_Cov_lag_b1
Alias UFW_VFW_Cov_lag(3, 1) = UFW_Cov_lag_0     '0 indicates neither backward nor forward   
Alias UFW_VFW_Cov_lag(3, 2) = VFW_Cov_lag_0
Alias UFW_VFW_Cov_lag(4, 1) = UFW_Cov_lag_f1    'f1 indicates forward 1 scan    
Alias UFW_VFW_Cov_lag(4, 2) = VFW_Cov_lag_f1
Alias UFW_VFW_Cov_lag(5, 1) = UFW_Cov_lag_f2    'f2 indicates forward 2 scans  
Alias UFW_VFW_Cov_lag(5, 2) = VFW_Cov_lag_f2
Units UFW_VFW_Cov_lag       = deg C m s-1

'Variables found from Cov_out_fw(), WFW_Cov_lag_R(), and UFW_VFW_Cov_lag_R() according to the lag  
Dim   WFW_Cov_lag_max (2)
Alias WFW_Cov_lag_max (1) = WFW_Cov                 'Max covariance among lagged covariance values and will be used for sensible heat flux after freq correction    
Alias WFW_Cov_lag_max (2) = lag_FW                  'Lag in number of scans, also used for sequential number in an array index for lag WFW_Cov_lag() and UFW_VFW_cov_lag()    
Units WFW_Cov             = deg C m s-1
Units lag_FW              = scans 

Dim   FW_Avg                                         'Selected from cov_out_FW() according to lag maximization using lag_FW    
Dim   FW_SIGMA                                       'Selected from cov_out_FW() according to lag maximization using lag_FW   
Units FW_Avg   = deg C  
Units FW_SIGMA = deg C

Dim   UxFW_Cov                                       'Selected from cov_out_FW() according to lag maximization using lag_FW  
Dim   UyFW_Cov                                       'Selected from cov_out_FW() according to lag maximization using lag_FW   
Dim   UzFW_Cov                                       'Selected from cov_out_FW() according to lag maximization using lag_FW  
Units UxFW_Cov  = deg C m s-1
Units UyFW_Cov  = deg C m s-1
Units UzFW_Cov  = deg C m s-1

Dim nmbr_smpl_FW                                     'Number of samples used for flux statistics related to FW 
Units nmbr_smpl_FW = Samples

Dim   UFW_Cov                                        'Selected from UFW_VFW_cov_lag() according to lag maximization using lag_FW  
Dim   VFW_Cov                                      'Selected from UFW_VFW_cov_lag() according to lag maximization using lag_FW
'For "WFW_Cov", see "wFW_Cov_lag_max (1)"  
Units UFW_Cov = deg C m s-1
Units VFW_Cov = deg C m s-1

' Variables after coordinate rotations and freq corrections as indicated by "fc"
Dim   WFW_Cov_fc
Units WFW_Cov_fc = deg C m s-1
 
' Sensible heat flux 
Public H_FW
Units  H_FW = W m-2

'Delay table for high frequency data
DataTable (delay_fw, TRUE, (OFFSET + MAX_LAG))   ' + MAX_LAG. Add more records of MAX_LAG for use in finding a lag for FW 
  TableHide
  Sample (1, FW_raw,      IEEE4)
  Sample (1, diag_FW_raw, IEEE4)
EndTable

'Compute covariance of FW against CSAT wind data over an output interval
DataTable (comp_cov_fw, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average    (1, Cov_array_FW(1, 1), IEEE4, FW_bad_data_flg(1))
  Covariance (4, Cov_array_FW(1, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(1)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(1)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b2")
  
  Average    (1, Cov_array_FW(2, 1), IEEE4, FW_bad_data_flg(2))
  Covariance (4, Cov_array_FW(2, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(2)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(2)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_b1")
   
  Average    (1, Cov_array_FW(3, 1), IEEE4, FW_bad_data_flg(3))
  Covariance (4, Cov_array_FW(3, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(3)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(3))))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_0")  

  Average    (1, Cov_array_FW(4, 1), IEEE4, FW_bad_data_flg(4))
  Covariance (4, Cov_array_FW(4, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(4)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(4)))       'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f1")

  Average    (1, Cov_array_FW(5, 1), IEEE4, FW_bad_data_flg(5))
  Covariance (4, Cov_array_FW(5, 1), IEEE4, (sonic_disable_f OR FW_bad_data_flg(5)),4)
  Totalize   (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg(5)))        'Totalize the number of samples for statistic values related to FW sonic data 
  FieldNames ("nmbr_smpl_FW_lag_f2")
EndTable
'*** END OF FW: CONSTANTS, VARIABLES, AND WORKING DATA TABLE *** 
#EndIf    
#If (SENSOR_TMPR_RH) Then

'************************************************************************************************
'*** BEGINNING OF TEMPERATURE AND HUMIDITY PROBE CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
'************************************************************************************************
Public tmpr_rh(7)
Alias tmpr_rh(1) = T_probe                    'Temperature/humidity probe: Temperature
Alias tmpr_rh(2) = RH_probe                   'Temperature/humidity probe: Relative humidity
Alias tmpr_rh(3) = T_DP_Probe                 'Temperature/humidity probe: Dew point temperaure 
Alias tmpr_rh(4) = e_probe                    'Temperature/humidity probe: vapor pressure
Alias tmpr_rh(5) = e_sat_probe                'Temperature/humidity probe: Saturate vapor pressure
Alias tmpr_rh(6) = H2O_probe                  'Temperature/humidity probe: Water vapor density 
Alias tmpr_rh(7) = rho_d_probe                'Temperature/humidity probe: Dry air density 
Units T_probe     = C
Units RH_probe    = %
Units T_DP_Probe  = C
Units e_probe     = kPa
Units e_sat_probe = kPa  
Units H2O_probe   = g/m^3
Units rho_d_probe = g/m^3
    
Dim Enhance_factor1_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Enhance_factor2_probe                     'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim x_tmp_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature
Dim Td_gu_probe                               'Temperature/humidity probe: Intermediate variable for calculation of dew point temperature

Dim stats_out_tmpr_rh(8)                      'Temperature/humidity probe: statistics
Alias stats_out_tmpr_rh(1) = TA_3_1_1         'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(2) = RH_3_1_1         'Average temperature measured using temperature/humidity probe
Alias stats_out_tmpr_rh(3) = T_DP_3_1_1       'Average dew point temperaure measured using temperature/humidity probe 
Alias stats_out_tmpr_rh(4) = e_probe_Avg      'Average vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(5) = e_sat_probe_Avg  'Average saturation vapor pressure measured using temperature/humidity probe
Alias stats_out_tmpr_rh(6) = H2O_probe_Avg    'Average vapor density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(7) = rho_d_probe_Avg  'Average dry air density measured using temperature/humidity probe
Alias stats_out_tmpr_rh(8) = rho_a_probe_Avg  'Average moist air density measured using Temperature/humidity probe
Units TA_3_1_1        = deg C
Units RH_3_1_1        = %
Units T_DP_3_1_1      = deg C
Units e_probe_Avg     = kPa
Units e_sat_probe_Avg = kPa
Units H2O_probe_Avg   = g m-3
Units rho_d_probe_Avg = g m-3
Units rho_a_probe_Avg = kg m-3

DataTable (stats_tmpr_rh,TRUE,1)
  TableHide
  DataInterval (0,OUTPUT_INTERVAL,Min,1)

  Average (7, T_probe, IEEE4, slowsequence_disable_flg)

EndTable
'*** END OF TEMPERATURE AND HUMIDITY PROBE CONSTANTS, VARIABLES, AND WORKING DATA TABLE ***
#EndIf
#If (SENSOR_TE525mm) Then


'*****************************************************
'*** BEGINNING OF TE525MM: CONSTANTS AND VARIABLES ***
'*****************************************************
Public P
Units  P = mm
'*** END OF TE525MM: CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_Rn) Then

'********************************************************************
'*** BEGINNING OF NET RADIOMETER: CONSTANTS, VARIABLES, AND TABLE ***
'********************************************************************
Public Rn_raw                                           'Net radiation: Measured time series data

Public nr_mean(1-6*(SENSOR_NR01 OR SENSOR_CNR4))        'Radiation components measured from a 4-way net radiometer.
Alias nr_mean(1) = Rn                                   'Net radation: mean over an averaging interval
Units  Rn = W m-2

#If (SENSOR_NR_LITE) Then

'*** Beginning of NR Lite constants and variables ***
Const NMBR_WND_SAMPLES = 3000/SCAN_INTERVAL             'Number of measurements to compute a three second mean of horizontal wind to correct measured Rn_meas as Rn
Public Rn_meas                                          'Measured Rn that is not corrected by horizontal wind speed
Units  Rn_meas = W m-2

Dim hor_wind_raw                                        'Used for running average for hor_wind
Dim hor_wind                                            'Running average of hor_wind_raw over three seconds of hor_wind_raw
Dim hor_wind_diag                                       'Diagnosis code: non-zero if any of recent sonic_irga_raw(5) last 30 second
'*** End of NR Lite constants and variables ***
#EndIf
#If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then

'*** Beginning of 4-way net radiometer constants and variables ****
Public nr(8)                       'Radiation components measured from a 4-way net radiometer.
Alias nr(1) = albedo
Alias nr(2) = R_SW_in              'Incoming (downwelling) short wave radiation
Alias nr(3) = R_SW_out             'Outgoing (upwelling) short wave radiation
Alias nr(4) = R_LW_in              'Incoming (downwelling) long wave radiation
Alias nr(5) = R_LW_out             'Outgoing (upwelling) long wave radiation
Alias nr(6) = T_nr                 'Sensor body temperature
Alias nr(7) = R_LW_in_meas         'Measured signal of incoming (downwelling) long wave radiation
Alias nr(8) = R_LW_out_meas        'Measured signal of outgoing (upwelling) long wave radiation
Units albedo        = %
Units R_SW_in       = W m-2
Units R_SW_out      = W m-2
Units R_LW_in       = W m-2
Units R_LW_out      = W m-2
Units T_nr          = Klvin
Units R_LW_in_meas  = W m-2
Units R_LW_out_meas = W m-22

' See declaration above for nr_mean()  
Alias nr_mean(2) = ALB               'albedo
Alias nr_mean(3) = SW_IN_net_rdmtr   'Incoming (downwelling) short wave radiation (This variable should be SW_IN, 
                                     'being name this way for the evetual of use of SW_IN if other sensor is used for Incoming SW radiation 
Alias nr_mean(4) = SW_OUT            'Outgoing (upwelling) short wave radiation
Alias nr_mean(5) = LW_IN             'Incoming (downwelling) long wave radiation
Alias nr_mean(6) = LW_OUT            'Outgoing (upwelling) long wave radiation
Alias nr_mean(7) = T_nr_Avg          'Sensor body temperature
Units ALB             = %
Units SW_IN_net_rdmtr = W m-2
Units SW_OUT          = W m-2
Units LW_IN           = W m-2
Units LW_OUT          = W m-2
Units T_nr_Avg        = Klvin
'*** End of NR01/CNR4 constants and variables ***

#If (SENSOR_CNR4) Then

'YSI 44031 Steinhart-Hart coefficients fit through -40 degrees C (239800 ohms), 20 degrees C (12260 ohms), and 80 degrees C (1458 ohms).
Const A_SHH = 1.0295e-3           'Steinhart-Hart A coefficient (from Kipp & Znen through email April 16 2015).
Const B_SHH = 2.3910e-4           'Steinhart-Hart B coefficient (from Kipp & Znen through email April 16 2015).
Const C_SHH = 1.5680e-7           'Steinhart-Hart C coefficient (from Kipp & Znen through email April 16 2015).
Dim X_cnr4
Dim ln_R
#EndIf

'*** End of 4-way net radiometer constants and variables ****
#EndIf

DataTable (stats_net_radiation, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)

  Average (1, Rn_raw, IEEE4, slowsequence_disable_flg)

  #If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Average (6, albedo, IEEE4, slowsequence_disable_flg)  
  #EndIf
EndTable
'*** END OF NET RADIOMETER: CONSTANTS, VARIABLES, AND TABLE ***
#EndIf
#If (SENSOR_HFP) Then
'*************************************************************
'*** BEGINNING OF HFP01 OR HFP01SC CONSTANTS AND VARIABLES ***
'*************************************************************
Dim shf_plate_cal(NMBR_HFP)             'Hold calibiration of soil heat flux plates

Public shf_plate(NMBR_HFP)              'Soil heat flux through soil heat flux plates
Units shf_plate = W m-2

Public shf_plate_avg(NMBR_HFP)          'Mean soil heat flux through soil heat flux plates
Alias shf_plate_avg(1) = G_PLATE_1_1_1
#If (NMBR_HFP > 1) Then 
Alias shf_plate_avg(2) = G_PLATE_2_1_1
#EndIf 
#If (NMBR_HFP > 2) Then 
Alias shf_plate_avg(3) = G_PLATE_3_1_1
#EndIf   
#If (NMBR_HFP > 3) Then 
Alias shf_plate_avg(4) = G_PLATE_4_1_1
#EndIf 
Units shf_plate_avg = W m-2

#If (SENSOR_HFP01SC) Then
'*** Beginning of HFP01SC constants and variables ***
Const CAL_INTERVAL = 1440                'Unique:  HFP01SC insitu calibration interval (minutes).
Const END_CAL      = OUTPUT_INTERVAL - 1 'End HFP01SC insitu calibration one minute before the next output.
Dim shf_mV(NMBR_HFP)                    'Voltage measured from soil heat flux plates
Dim shf_mV_run(NMBR_HFP)                'Running mean of shf_mV
Dim shf_mV_0(NMBR_HFP)                  'Running mean of shf_mV at the beginning of calibration
Dim shf_mV_180(NMBR_HFP)                'Running mean of shf_mV after 180 seconds since the beginning of calibration
Dim shf_mV_end(NMBR_HFP)                'Running mean of shf_mV at the end of calibration
Dim V_Rf(NMBR_HFP)                      'Reference voltage
Dim V_Rf_run(NMBR_HFP)                  'Running mean of reference voltage
Dim V_Rf_180(NMBR_HFP)                  'Running mean of reference voltage after 180 seconds since the beginning of calibration
Dim shf_cal_on_f As Boolean
Dim cdm_sw12_state As Boolean              'State of the switched 12Vdc port 1.
'*** End of HFP01SC constants and variables ***
#EndIf

DataTable (stats_SHF, TRUE, 1)
  TableHide
  DataInterval (0, OUTPUT_INTERVAL, Min, 1)
  #If (SENSOR_HFP01) Then
    
  Average (NMBR_HFP, shf_plate(1), IEEE4, slowsequence_disable_flg)
  #EndIf
  #If (SENSOR_HFP01SC) Then

  Average (NMBR_HFP, shf_plate(1), IEEE4, (shf_cal_on_f OR slowsequence_disable_flg))
  #EndIf
EndTable
'*** END OF HFP01 OR HFP01SC CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_TCAV) Then

'*************************************************
'*** BEGINNING OF TCAV CONSTANTS AND VARIABLES ***
'*************************************************
Public Tsoil(NMBR_TCAV)                 'TCAV soil temperature.
Units Tsoil = deg C
'*** END OF TCAV CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_CS6XX) Then 


'**************************************************
'*** BEGINNING OF CS6xx CONSTANTS AND VARIABLES ***
'**************************************************
#If (SENSOR_CS616) Then
'*** Beginning of CS616 constants and variables ***
Public cs616_wcr(NMBR_CS6xx)            'Water content reflectometer period.
Units cs616_wcr = usec

#If ((SENSOR_CS616) AND (NOT SENSOR_TCAV)) Then
Public soil_wtr(NMBR_CS6xx)             'Volumetric soil water content without temperature correction.
Units soil_wtr = frac_v_wtr
#EndIf

#If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
Dim Tsoil_for_CS616_correct(NMBR_CS6xx) 'Soil temperature used for CS616 temperature correction. This variable is defined in case: NMBR_TCAV <> NMBR_CS6xx
Dim cs616_T(NMBR_CS6xx)                 'Water content reflectometer period with temperature correction.

Public soil_wtr_T(NMBR_CS6xx)           'Volumetric soil water content with temperature correction.
Units soil_wtr_T = frac_v_wtr
#EndIf
'*** End of CS616 constants and variables ***
#EndIf
#If (SENSOR_CS65X) Then
'*** Beginning of CS65X constants and variables ***
Public cs65x_wc(NMBR_CS6xx)            'Volumetric soil water content.
Public cs65x_ec(NMBR_CS6xx)            'Electrical conductivity.
Public cs65x_tmpr(NMBR_CS6xx)          'CS65X probe temperature.
Dim cs65x_raw(3)                       'Hold CS65X raw variables
Units cs65x_wc = %
Units cs65x_ec = dS m-1
Units cs65x_tmpr = C
'*** End of CS65X constants and variables ***
#EndIf
'Soil water contents measured using CS655 OR CS616 w/ or w/o soil temperature correction will be moved to this aray  
Dim SWC_array(NMBR_CS6xx)              'Soil water contents measured from                
Alias SWC_array(1) = SWC_1_1_1
#If (NMBR_CS6xx > 1) Then 
Alias SWC_array(2) = SWC_2_1_1
#EndIf 
Units SWC_array = % 
'*** END OF CS6xx CONSTANTS AND VARIABLES ***
#EndIf
#If ((SENSOR_CS65X) OR (SENSOR_TCAV)) Then 
  
 
'************************************************************
'*** BEGINNING OF ADDITIONAL VARIABLES FOR CS65X AND TCAV ***
'************************************************************
Dim TS_array(2)                                                                'Soil Temperature measured from TCAV or CS655                
Alias TS_array(1) = TS_1_1_1
Alias TS_array(2) = TS_2_1_1                                                   'The use of this variable depends on the NUMBR_TCAV or NUMBR_CS6xx
Units TS_array = Deg C   
'*** END OF ADDITIONAL VARIABLES FOR CS65X AND TCAV ***
#EndIf
#If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then


'********************************************************************************
'*** BEGINNING OF VARIABLES FOR CALCULATION OF SOIL HEAT FLUX AT SOIL SURFACE ***
'********************************************************************************
Const NMBR_SOIL_T_WTR_DEL_SAMPLES = (60*1000)/SLOWSEQUENCE_SCAN_INTERVAL       'Number of measurements to compute a one-minute mean of soil temperature and water

Public G_surface                        'Soil heat flux at the ground surface
Units  G_surface = W m-2

'Used to calculate the change in heat storage in soil
Public Tsoil_prev_Avg = NaN             'Tsoil mean of last one-minute measurements in the previous averaging interval

Dim Tsoil_current (2)                   'Indididual Tsoil means of last one-minute measurements in the current averaging interval
Public Tsoil_current_Avg                'Averaged from Tsoil_current() 

Public soil_wtr_prev_Avg = NaN          'soil_wtr_T mean of last one-minute measurements in the previous averaging interval
Dim soil_wtr_current(NMBR_CS6xx)        'soil_wtr_T mean of last one-minute measurements in the current averaging interval
Public soil_wtr_current_Avg             'soil_wtr_current() 
' Notes for NaN: After compiling, Tsoil_prev_avg and soil_wtr_prev_Avg will be NaN but will be replaced with the current measured
' values. On subsequent averaging intervals, *_prev_Avg will be taken from the mean of the last minute of the previous averaging interval.

Public SG                              'Heat storage in the soil above the soil heat flux plates at the end of average interval (Used by AmeriFlux)                 
Units SG = W m-2  
Public SG_delta                        'The soil heat flux into soil as heat storage above soil heat flux plates over an averaging interval
Units  SG_delta = W m-2 s-1

' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
Dim realtime_array(9)                  'Hold real time data
Dim Offset_intv_delta_ht_storage       'time interval offset
'*** BEGINNING OF VARIABLES FOR CALCULATION OF SOIL HEAT FLUX AT SOIL SURFACE ***
#EndIf
#If ((SENSOR_Rn) AND (SENSOR_HFP) AND (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then


'***********************************************************
'*** BEGINNING OF ENERGY BALANCE CONSTANTS AND VARIABLES ***
'***********************************************************
Public energy_closure                  '(LE + H)/(Rn-G_surface)
Units  energy_closure = Fraction
'*** END OF ENERGY BALANCE CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_LI200X) OR (SENSOR_CS300) Then

'*** BEGINNING OF PYRANOMETER CONSTANTS AND VARIABLES ***
Public SW_IN_pyran
Units  SW_IN_pyran = W m-2
'*** BEGINNING OF PYRANOMETER CONSTANTS AND VARIABLES ***
#EndIf

#If (SENSOR_LI200X) OR (SENSOR_CS300) OR (SENSOR_NR01) OR (SENSOR_CNR4) Then 
'*************************************************************************
'*** BEGINNING OF ADDITIONAL VARIABLE FOR SHORT WAVE RADIATION SENSORS ***
'*************************************************************************
Public SW_IN
Units  SW_IN = W m-2
#EndIf 
'*** BEGINNING OF ADDITIONAL VARIABLE FOR SHORT WAVE RADIATION SENSORS ***
#If (SENSOR_LI190SB) Then


'****************************************************
'*** BEGINNING OF QUANTUM CONSTANTS AND VARIABLES ***
'****************************************************
Public PPFD_IN
Units  PPFD_IN = umolPhoton m-2 s-1
'*** END OF QUANTUM CONSTANTS AND VARIABLES ***
#EndIf
#If (SENSOR_SI111) Then

'****************************************************************
'*** BEGINNING OF INFRARED RADIOMETER CONSTANTS AND VARIABLES ***
'****************************************************************
Public T_CANOPY              'Temperature of surface that SI111 targets. we consider it as canopy temperature 
Public T_SI111_body          'Temperature of SI111 sensor body
Units  T_CANOPY      = deg C
Units  T_SI111_body  = deg C

Dim m_SI111, b_SI111         'Multipler and offset in equation to calculate temperature of targeted surface using measured voltage and SI111 body temperature
'*** END OF INFRARED RADIOMETER CONSTANTS AND VARIABLES ***
#EndIf

'******************************
'*** BEGINNING DISPLAY MENU ***
'******************************
DisplayMenu ("System Control", TRUE)
  SubMenu ("Site Var Settings")
    MenuItem ("Surf Type", surface_type)
      MenuPick (CROP, GRASS, FOREST, SHRUB, BARELAND, WATER, ICE)
    MenuItem ("d, 0 = auto",   displacement_user)                        'if 0, zero displacement is automatically calculated in the program
    MenuItem ("z0,0 = auto",   roughness_user)                           'if 0, roughness length is automatically calculated in the program
    MenuItem ("Meas Height",   height_measurement)
    MenuItem ("Canopy Height", height_canopy)

    #If ((SENSOR_HFP) AND (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    MenuItem ("Bulk Density", soil_bulk_density)
    MenuItem ("C_dry_soil",   Cds)
    MenuItem ("HFP Depth",    thick_abv_HFP)
    #EndIf

    MenuItem ("IRGA Coord x", separation_x_irga)
    MenuItem ("IRGA Coord y", separation_y_irga)

    #If (SENSOR_FW) Then
    MenuItem ("FW Coord x",  separation_x_FW)
    MenuItem ("FW Coord y",  separation_y_FW)
    MenuItem ("FW Dim",      FW_diameter)
      MenuPick (FW05DIA, FW1_DIA, FW2_DIA, FW3_DIA)
    #EndIf

    MenuItem ("Sonic Azmth", sonic_azimuth)
    MenuItem ("Latitude",    latitude)
    MenuItem ("Hemisph_Eq",  hemisphere_NS)
  MenuPick (HEMISPHERE_NORTH, HEMISPHERE_SOUTH)
    MenuItem ("Longitude",   longitude)
    MenuItem ("Hemisph_Me",  hemisphere_EW)
  MenuPick (HEMISPHERE_EAST, HEMISPHERE_WEST)

    SubMenu ("Planar Fit Alpha")
      MenuItem ("<60 or >300",  alpha_PF_60_300)                               'Angle in CSAT coordinate system
      MenuItem (">60 & <=170",  alpha_PF_60_170)
      MenuItem (">170 & <190",  alpha_PF_170_190)
      MenuItem (">=190 & <300", alpha_PF_190_300)
    EndSubMenu

    SubMenu ("Planar Fit Beta")
      MenuItem ("<60 or >300",  beta_PF_60_300)
      MenuItem (">60 & <=170",  beta_PF_60_170)
      MenuItem (">170 & <190",  beta_PF_170_190)
      MenuItem (">=190 & <300", beta_PF_190_300)
    EndSubMenu

    SubMenu ("Footprint Dis Intrst")
      MenuItem ("<60 or >300",  dist_intrst_60_300)
      MenuItem (">60 & <=170",  dist_intrst_60_170)
      MenuItem (">170 & <190",  dist_intrst_170_190)
      MenuItem (">=190 & <300", dist_intrst_190_300)
    EndSubMenu
  
  EndSubMenu
  
  SubMenu ("Instrument settings")

    SubMenu ("Change Press Source")
      MenuItem ("Select Srce", press_source)
        MenuPick (BB, UB, EB)
      MenuItem ("Set Source",  set_press_source_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Switch IRGA Power")
      MenuItem ("IRGA Power", IRGA_power_array(1, 2))
        MenuPick (POWER_ON, POWER_OFF)
      MenuItem ("Set IRGA Power", set_IRGA_power_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Heater Control")
      MenuItem ("Select Heater Control", heater)
        MenuPick (HEATER_OFF, HEATER_AUTO)
      MenuItem ("Set Heater Control", set_heater_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu
    
    SubMenu ("Shadow Correction")
      MenuItem ("Correction", shadow_corr)
        MenuPick (CORR_ON, CORR_OFF)
      MenuItem ("Set Corr", set_shadow_corr_flg)
        MenuPick (TRUE, FALSE)
    EndSubMenu

   EndSubMenu

   SubMenu ("On Site Zero & Span")
    SubMenu ("Span Concentrations")
      MenuItem ("CO2",CO2_span_gas)
      MenuItem ("T_DP", Td_span_gas)
    EndSubMenu

    MenuItem ("Set Zero", do_zero_flg)
  MenuPick (TRUE, FALSE)
    MenuItem ("Set CO2 Span", do_CO2_span_flg)
  MenuPick (TRUE, FALSE)
    MenuItem ("Set H2O Span", do_H2O_span_flg)
  MenuPick (TRUE, FALSE)
    DisplayValue ("CO2_mixratio", CO2_mixratio)
    DisplayValue ("H2O_mixratio", H2O_mixratio)
    DisplayValue ("T_DP deg C", T_DP)
    #If (SENSOR_TMPR_RH) Then
    DisplayValue ("T_DP_Probe deg C", T_DP_Probe)
    #EndIf

  EndSubMenu
EndMenu
'*** BEGINNING DISPLAY MENU ***
  

'***********************************************'
'*** FLUX TABLE IN AmeriFlux VARIABLE FORMAT ***'
'***********************************************'
DataTable (Flux_AmeriFluxFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTERVAL, Min, 10)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Flux_AmeriFluxFormat", 64, -1, 0, NMBR_DAY_FLUX_CRD, Day, 0, 0)
  
  '***GASES
  Sample (2, CO2,           IEEE4)  'CO2 and CO2_SIGMA
  Sample (2, H2O,           IEEE4)  'H2O and H2O_SIGMA     
  Sample (1, FC,            IEEE4)  'CO2 flux in umol/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, FC_SSITC_TEST, IEEE4)  'Results of the Steady State and Integral Turbulence Charactoeristics for FC according to Foken et al (2004)
  
  '***HEAT  
  Sample (1, LE,            IEEE4)  'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_SSITC_TEST, IEEE4)  'Results of the Steady State and Integral Turbulence Charactoeristics for LE according to Foken et al (2004)
  Sample (1, H,             IEEE4)  'Sensible heat flux (derived from sonic temperature flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_SSITC_TEST,  IEEE4)  'Results of the Steady State and Integral Turbulence Charactoeristics for LE according to Foken et al (2004)   
  
  #If ((SENSOR_HFP) AND  (SENSOR_CS6XX)) AND ((SENSOR_TCAV) OR (SENSOR_CS65X)))  Then
  Sample (1, G_surface,     IEEE4)  'Soil heat flux at the ground surface
  FieldNames ("G")  
  Sample (1, SG,            IEEE4)  'Heat storage in the soil above the soil heat flux plates at the end of average interval 
  #EndIf

  '***FOOTPRINT 
  Sample (1, FETCH_MAX,     IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FETCH_90,      IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FETCH_55,      IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FETCH_40,      IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux  
  
  '***MET_WIND
  Sample (1, WD,             IEEE4)  'Wind direction.
  Sample (1, WS,             IEEE4)  'Resultant wind speed.
  Sample (1, WS_MAX,         IEEE4)  'Maximum wind speed.
  Sample (1, USTAR,          IEEE4)  'Friction velocity after coordinate rotations and freq corrections
  Sample (1, ZL,             IEEE4)  'Atmospheric boundary-layer stability.  
  Sample (1, TAU,            IEEE4)  'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_SSITC_TEST, IEEE4)  'Results of the Steady State and Integral Turbulence Charactoeristics for TAU according to Foken et al (2004)    
  Sample (1, MO_LENGTH,      IEEE4)  'Monin-Obukhov length
  Sample (1, U,              IEEE4)  'Average wind speed in stream-wise direction after coordinate rotation   
  Sample (1, U_SIGMA,        IEEE4)  'Standard deviation of wind speed in stream-wise wind direction after coordinate rotation   
  Sample (1, V,              IEEE4)  'Average wind speed in cross-stream direction after coordinate rotation  
  Sample (1, V_SIGMA,        IEEE4)  'Standard deviation of wind speed in cross-stream direction after coordinate rotation  
  Sample (1, W,              IEEE4)  'Average vertical wind speed after coordinate rotation  
  Sample (1, W_SIGMA,        IEEE4)  'Standard deviation of vertical wind after coordinate rotation 
 
  '*** MET_ATM
  Sample (1, PA,             IEEE4)  'Atmospheric pressure 
  Sample (1, TA_1_1_1,       IEEE4)  'Air temperature from EC100 107 temperature probe
  Sample (2, RH_1_1_1,       IEEE4)  'RH_1_1_1 and T_DP_1_1_1. Calculated from 107 temperature, H2O, and pressure. 

  Sample (1, TA_2_1_1,       IEEE4)  'Air temperature calculated from sonic temperature, water vapor density, and pressure
  Sample (2, RH_2_1_1,       IEEE4)  'RH_2_1_1 and T_DP_2_1_1. Calculated from sonic temperature, H2O, and pressure. 
     
  #If (SENSOR_TMPR_RH) Then
  Sample  (3, TA_3_1_1,      IEEE4)  'Measured from temperaure and humidity probe: TA_3_1_1, RH_3_1_1, and T_DP_3_1_1
  #EndIf

  Sample (1, VPD,            IEEE4)  'Air vapor pressure deficit
  Sample (1, T_SONIC,        IEEE4)  'Average soinc temperature (Ts_Avg)  
  Sample (1, T_SONIC_SIGMA,  IEEE4)  'Standard deviation of sonic temperature.
  Sample (1, PBLH,           IEEE4)  'Planetary boundary layer height.

  #If (SENSOR_CS6XX OR SENSOR_TCAV) Then 
   'MET_SOIL
  #EndIf 
    
  #If (SENSOR_CS616) Then
  #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
  Average (NMBR_CS6xx, SWC_1_1_1, IEEE4, slowsequence_disable_flg)        'Measured using CS616. Volumetric soil water w/ temperature correction
  #EndIf

  #If ((SENSOR_CS616)) AND (NOT SENSOR_TCAV) Then
  Average (NMBR_CS6xx, SWC_1_1_1, IEEE4, slowsequence_disable_flg)        'Measured using CS616. Volumetric soil water w/o temperature correction
  #EndIf
  #EndIf

  #If ((SENSOR_CS65X)  AND (NOT SENSOR_CS616)) Then
  Average (NMBR_CS6xx, SWC_1_1_1, IEEE4, slowsequence_disable_flg)        'Measured using CS65x. Volumetric soil water w/ temperature correction
  #EndIf

  #If (SENSOR_TCAV) Then
  Average (NMBR_TCAV, TS_1_1_1, IEEE4, slowsequence_disable_flg)          'soil temperature from TCAV
  #EndIf

  #If ((NOT SENSOR_TCAV) AND SENSOR_CS65X)  Then
  Average (NMBR_CS6xx, TS_1_1_1, IEEE4, slowsequence_disable_flg)         'Soil temperature from CS65x
  #EndIf    

  #If (SENSOR_Rn OR SENSOR_LI200X OR SENSOR_CS300 OR SENSOR_LI190SB) Then 
  'MET_RAD
  #EndIf 
  #If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Sample  (1, ALB,   IEEE4)                                               'Albedo
  #EndIf

  #If (SENSOR_LI190SB) Then
  Average  (1, PPFD_IN, IEEE4, slowsequence_disable_flg)
  #EndIf    

  #If ((SENSOR_LI200X) OR (SENSOR_CS300) OR (SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Average  (1, SW_IN, IEEE4, slowsequence_disable_flg)                    'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
  #EndIf

  #If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Sample  (3, SW_OUT, IEEE4)                                              'SW_OUT, LW_IN, and LW_OUT
  #EndIf
   
  #If (SENSOR_TE525mm) Then
  'MET_PRECIP  
  Totalize (1, P, IEEE4, 0)
  #EndIf
  
  #If (SENSOR_SI111) Then
  'BIOLOGY  
  Average  (1, T_CANOPY, IEEE4, slowsequence_disable_flg)                 'Measured using SI111
  #EndIf
  
EndTable  

' Setting constant how to construct the hourly or datal   
Const ONE_FULL_TABLE = FALSE         'Unique: TRUE if all half-hourly or hourly data in CSI variable format are stored in one table
                                     '        FALSE if hourly or half-hourly data in CSI variable format are stored in two tables
                                     '              Table: Flux_CSFormat for variables that are directly used 
                                     '              Table: Flux_Notes for variables that are are used for reference and check    

'*****************************************'
'*** FLUX TABLE IN CSI VARIABLE FORMAT ***'
'*****************************************'
DataTable (Flux_CSFormat, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTERVAL, Min, 10)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Flux_CSFormat", 64, -1, 0, NMBR_DAY_FLUX_CRD, Day, 0, 0)
    
  '*** flux and quality classification data 
  Sample (1, FC_mass, IEEE4)    'Carbon dioxide flux in mg/(m^2 s) after coordinate rotations, freq corrections, and WPL correction
  Sample (1, FC_QC,   UINT2)    'Overall grade of data quality for carbon dioxide flux (i.e. for variables: Fc_mass) according to Foken et al. (2012)
  Totalize (1, n, IEEE4, (sonic_disable_f OR irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for CO2 flux
  FieldNames ("FC_samples_Tot")

  Sample (1, LE,      IEEE4)    'Latent heat flux after coordinate rotations, freq corrections, and WPL correction
  Sample (1, LE_QC,   UINT2)    'Overall grade of data quality for latent heat flux (i.e. for variable: LE) according to Foken et al. (2012)
  Totalize (1, n, IEEE4, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))    'Totalize the number of samples for latent heat flux
  FieldNames ("LE_samples_Tot")
        
  Sample (1, H,       IEEE4)    'Sensible heat flux (derived from sonic heat flux with SND correction after coordinate rotations and freq corrections)
  Sample (1, H_QC,    UINT2)    'Overall grade of data quality for sensible heat flux (i.e. for variable: H) according to Foken et al. (2012)
  Totalize (1, n, IEEE4, (sonic_disable_f OR irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))  'Totalize the number of samples for sensible heat flux
  FieldNames ("H_samples_Tot")

  #If (SENSOR_FW) Then
  Sample (1, H_FW, IEEE4)       'Sensible heat flux measured using fine wire thermocouple (FW) after coordinate rotations and freq corrections
  Totalize (1, n, IEEE4, (sonic_disable_f OR FW_bad_data_flg))    'Totalize the number of samples for FW-measured sensible heat flux
  FieldNames ("H_FW_samples_Tot")
  #EndIf
      
  #If (SENSOR_Rn) Then
  Sample (1, Rn, IEEE4)
  #EndIf

  #If ((SENSOR_HFP) AND  (SENSOR_CS6XX)) AND ((SENSOR_TCAV) OR (SENSOR_CS65X)))  Then
  Sample (1, G_surface,IEEE4)           'Soil heat flux at the ground surface
  FieldNames ("G")
  Sample (1, SG,       IEEE4)           'Heat storage in the soil above the soil heat flux plates at the end of average interval 
  Sample (1, SG_delta, IEEE4)           'The soil heat flux into soil as heat storage above soil heat flux plates over an averaging interval 
  #EndIf

  Sample (1, TAU,      IEEE4)           'Momentum flux after coordinate rotations and freq corrections,
  Sample (1, TAU_QC,   UINT2)           'Overall grade of data quality for momentum flux (i.e. for variable: tau) according to Foken et al. (2012)
  
  #If ((SENSOR_Rn) AND (SENSOR_HFP) AND (SENSOR_CS6XX) AND  ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
  Sample (1, energy_closure,IEEE4)     'Energy closure
  #EndIf

  Sample (1, Bowen_ratio,   IEEE4)

  '*** Turbulence characteristic variables
  Sample (1, USTAR,         IEEE4)      'Friction velocity after coordinate rotations and freq corrections
  Sample (1, TSTAR,         IEEE4)      'Scaling temperature after coordinate rotations and freq corrections
  Sample (1, TKE,           IEEE4)      'Specific turbulence kinetic enegrgy after coordinate rotations

  '*** Air temperature and humidity 
  Sample (1, TA_1_1_1,      IEEE4)      'Air temperature from EC100 107 temperature probe
  Sample (4, RH_1_1_1,      IEEE4)      'RH_1_1_1, T_DP_1_1_1, amb_e_sat_Avg, amb_e_Avg. Calculated from 107 temperature (TA_1_1_1, H2O, and pressure.

  Sample (1, TA_2_1_1,      IEEE4)      'Air temperature calculated from IRASON measurements of sonic temperature, water vapor density, and pressure
  Sample (4, RH_2_1_1,      IEEE4)      'RH_2_1_1, T_DP_2_1_1, e_sat_Avg, e_Avg. Calculated from sonic temperature and H2O, and pressure.
  
  #If (SENSOR_TMPR_RH) Then
  '*** Temperature and humidity probe data   
  Sample (1, TA_3_1_1,      IEEE4)      'Measured from temperaure and humidity probe: TA_3_1_1, RH_3_1_1, T_DP_3_1_1
  Sample (5, RH_3_1_1,      IEEE4)      'Measured from temperaure and humidity probe: RH_3_1_1, T_DP_3_1_1, e_probe_Avg, e_sat_probe_Avg, and H2O_probe_Avg
  #EndIf
 
  Sample (1, PA,            IEEE4)      'PA
  Sample (1, VPD,           IEEE4)      'Air vapor pressure deficit

  '*** CSAT sonic head data 
  Sample (2, Ux_Avg,        IEEE4)      'Ux_avg and Ux_SIGMA before coordinate rotations
  Sample (2, Uy_Avg,        IEEE4)      'Uy_avg and Uy_SIGMA before coordinate rotations
  Sample (2, Uz_Avg,        IEEE4)      'Uz_avg and Uz_SIGMA before coordinate rotations
  Sample (1, T_SONIC,       IEEE4)      'Average soinc temperature (i.e. Ts_Avg)  
  Sample (1, T_SONIC_SIGMA, IEEE4)      'Standard deviation of sonic temperature. 
  Sample (1, sonic_azimuth, IEEE4)      'Sonic_azimuth, (see Section 3.2.1 CSAT3A Azimuth in the OPEC manual).
  Sample (6, WS,            IEEE4)      'The last 5 elements in array of cov_out_sonic: WS, WS_RSLT, WD_SONIC, WD_SIGMA, WD, WS_MAX.

  '*** Gas data 
  Sample (2, CO2_density_Avg, IEEE4)    'CO2_density_Avg and CO2_density_SIGMA
  #If (SENSOR_IRGASON) Then
  Average(1, CO2_mixratio, IEEE4, (irga_disable_f OR sonic_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf
  #If (NOT SENSOR_IRGASON) Then
  Average(1, CO2_mixratio, IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf
    
  Sample (2, H2O_density_Avg, IEEE4)            'H2O_density_Avg, and H2O_density_SIGMA
  #If (SENSOR_IRGASON) Then
  Average(1, H2O_mixratio, IEEE4, (irga_disable_f OR sonic_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf
  #If (NOT SENSOR_IRGASON) Then
  Average(1, H2O_mixratio, IEEE4, (irga_disable_f OR irga_amb_tmpr_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  #EndIf  

  Minimum (1, CO2_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("CO2_sig_strgth_Min")
  Minimum (1, H2O_sig_strgth, IEEE4, irga_disable_f, FALSE)
  FieldNames ("H2O_sig_strgth_Min")

  #If (SENSOR_FW) Then
  '*** Fine wire thermocouple data
  Sample (1, FW_Avg,     IEEE4)
  Sample (1, FW_SIGMA,   IEEE4)
  #EndIf
   
  #If (SENSOR_TE525mm) Then
  '*** Rain gauge data
  Totalize (1, P, IEEE4, 0)                 'Precipitation
  #EndIf
  
  #If (SENSOR_Rn OR SENSOR_LI200X OR SENSOR_CS300 OR SENSOR_LI190SB) Then 
  '*** Radiometer data 
  #EndIf 
  #If (SENSOR_NR_LITE) Then
  Average (1, Rn_meas, IEEE4, slowsequence_disable_flg)
  #EndIf

  #If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Sample  (1, ALB, IEEE4)                                                 'Albedo
  #EndIf

  #If ((SENSOR_LI200X) OR (SENSOR_CS300) OR (SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Average  (1, SW_IN, IEEE4, slowsequence_disable_flg)                    'For use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
  #EndIf
  
  #If ((SENSOR_NR01) OR (SENSOR_CNR4)) Then
  Sample  (4, SW_OUT, IEEE4)                                              'SW_OUT, LW_IN, LW_OUT, and T_nr_Avg
  Average (2, R_LW_in_meas, IEEE4, slowsequence_disable_flg)              'R_LW_in_meas and R_LW_out_meas
  #EndIf

  #If (SENSOR_LI190SB) Then
  Average  (1, PPFD_IN, IEEE4, slowsequence_disable_flg)
  #EndIf

  #If (SENSOR_SI111) Then
  '*** Surface temperature (i.e. canopy temperature) 
  Average  (1, T_CANOPY,     IEEE4, slowsequence_disable_flg)
  Average  (1, T_SI111_body, IEEE4, slowsequence_disable_flg)
  #EndIf

  #If(SENSOR_TCAV OR SENSOR_CS65X)  Then
  '*** Soil temperature
  #EndIf      
  #If (SENSOR_TCAV) Then
  Average (NMBR_TCAV, TS_1_1_1, IEEE4, slowsequence_disable_flg)          'Soil temperature from TCAV
  #EndIf

  #If ((NOT SENSOR_TCAV) AND SENSOR_CS65X)  Then
  Average (NMBR_CS6xx, TS_1_1_1, IEEE4, slowsequence_disable_flg)         'Soil temperature from CS65x
  #EndIf

  #If (SENSOR_CS6XX) Then
  'Soil moisture 
  #EndIf      
  #If (SENSOR_CS616) Then

  #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
  Average (NMBR_CS6xx, SWC_1_1_1,    IEEE4, slowsequence_disable_flg)     'CS616 volumetric soil water w/ temperature correction
  #EndIf

  #If ((SENSOR_CS616)) AND (NOT SENSOR_TCAV) Then
  Average (NMBR_CS6xx, SWC_1_1_1,    IEEE4, slowsequence_disable_flg)     'CS616 volumetric soil water w/o temperature correction
  #EndIf

  Average (NMBR_CS6xx, cs616_wcr(1), IEEE4, slowsequence_disable_flg)     'CS616 period.
  #EndIf
    
  #If (SENSOR_CS65X) Then
  Average (NMBR_CS6xx, SWC_1_1_1,    IEEE4, slowsequence_disable_flg)     'CS65xx volumetric soil water content.
  Average (NMBR_CS6xx, cs65x_ec(1),  IEEE4, slowsequence_disable_flg)     'Electrical conductivity.
  #EndIf

  #If (SENSOR_HFP) Then
  '*** soil heat flux plat data 
  Sample (NMBR_HFP, shf_plate_avg(1), IEEE4)                             'Heat flux through a soil heat flux plate
  #EndIf
    
  #If (SENSOR_HFP01SC) Then
  Sample (NMBR_HFP, shf_plate_cal(1), IEEE4)                             'Calibrations of self-calibrated soil heat flux plate
  #EndIf

  '*** Footprint characteristics 
  Sample (1, FETCH_MAX,            IEEE4)  'Upwind location of source/sink that contributes most to the measured flux
  Sample (1, FETCH_90,             IEEE4)  'Upwind range within which sources/sinks contributes 90% the measured flux
  Sample (1, FETCH_55,             IEEE4)  'Upwind range within which sources/sinks contributes 55% the measured flux
  Sample (1, FETCH_40,             IEEE4)  'Upwind range within which sources/sinks contributes 40% the measured flux
  Sample (1, UPWND_DIST_INTRST,    IEEE4)  'User-entered upwind distance of interest for the average upwind direction in this averaging interval
  Sample (1, FTPRNT_DIST_INTRST,   IEEE4)  'Percentage of measured scalar flux from upwind range of interest

  Sample (1, FTPRNT_EQUATION,     String)  'Type of footprint equation: Kljun et al or KormannMeixner

  #If (NOT (ONE_FULL_TABLE)) Then
EndTable
'*** End of FLUX_CSFormat Table ****

'*** BEGINNING OF FLUX_NOTES TABLE *****
DataTable (Flux_Notes, TRUE, FLUX_SIZE_CPU)
  DataInterval (0, OUTPUT_INTERVAL, Min, 10)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Flux_NOTES_", 64, -1, 0,NMBR_DAY_FLUX_CRD, Day, 0, 0)
  #EndIf

  '*** Beginning of CSAT sonic head data ***  
  '*** Before coordinate rotation
  Sample (2, UxUy_Cov,  IEEE4)    'UxUy_Cov and UxUz_Cov.
  Sample (1, UyUz_Cov,  IEEE4)
  Sample (3, TsUx_Cov,  IEEE4)    'TsUx_Cov, TsUy_Cov, and TsUz_Cov

  '** After coordinate rotations
  '   Ux is represented by U, Uy by V, Uz by W, ans Ts by T_SONIC, if this rule is not applicable, _R is added for the indication of coordinate-rotated variable. 
  Sample (1, USTAR_R,  IEEE4)    'Friction velocity after coordinate rotations.
  Sample (1, U,        IEEE4)  
  Sample (1, U_SIGMA,  IEEE4)
  Sample (1, V,        IEEE4)
  Sample (1, V_SIGMA,  IEEE4)
  Sample (1, W,        IEEE4)
  Sample (1, W_SIGMA,  IEEE4)
  Sample (1, UV_Cov,   IEEE4)
  Sample (1, UW_Cov,   IEEE4)
  Sample (1, VW_Cov,   IEEE4)
  Sample (1, UT_SONIC_Cov, IEEE4)
  Sample (1, VT_SONIC_Cov, IEEE4)
  Sample (1, WT_SONIC_Cov, IEEE4)

  '*** _fc indicates after frequency corrections
  Sample (1, UW_Cov_fc,       IEEE4)
  Sample (1, VW_Cov_fc,       IEEE4)
  Sample (1, WT_SONIC_Cov_fc, IEEE4)

  '** After coordinate rotations, freq corrections, and SND correction as indicated by WT_SONIC, fc, and SND.
  Sample (1, WT_SONIC_Cov_fc_SND,  IEEE4)
  
  '** Summary of diagnosis flags of CSAT
  Totalize (1, n, IEEE4, diag_sonic <> -1)
  FieldNames ("no_sonic_head_Tot")
  Totalize (1, n, IEEE4, diag_sonic <> NAN)
  FieldNames ("no_new_sonic_data_Tot")
  Totalize (1, n, IEEE4, sonic_amp_l_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_l_f_Tot")
  Totalize (1, n, IEEE4, sonic_amp_h_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_amp_h_f_Tot")
  Totalize (1, n, IEEE4, sonic_sig_lck_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_sig_lck_f_Tot")
  Totalize (1, n, IEEE4, sonic_del_T_f   IMP (diag_sonic = NAN))
  FieldNames ("sonic_del_T_f_Tot")
  Totalize (1, n, IEEE4, sonic_aq_sig_f  IMP (diag_sonic = NAN))
  FieldNames ("sonic_aq_sig_f_Tot")
  Totalize (1, n, IEEE4, sonic_cal_err_f IMP (diag_sonic = NAN))
  FieldNames ("sonic_cal_err_f_Tot")
  '*** End of CSAT3A sonic data ***

  '*** Beginning of IRGA output data ***
  '** Before coordinate rotation
  Sample  (3, UxCO2_Cov, IEEE4)    'UxCO2_Cov, UyCO2_Cov, UzCO2_Cov
  Sample  (3, UxH2O_Cov, IEEE4)    'UxH2O_Cov, UyH2O_Cov, UzH2O_Cov

  '** After coordinate rotations 
  '   Ux is represented by U, Uy by V, and Uz by W.
  Sample (1, UCO2_Cov,   IEEE4)
  Sample (1, VCO2_Cov,   IEEE4)
  Sample (1, WCO2_Cov,   IEEE4)

  Sample (1, UH2O_Cov,   IEEE4)
  Sample (1, VH2O_Cov,   IEEE4)
  Sample (1, WH2O_Cov,   IEEE4)

  '*** _fc indicates after frequency corrections based on coordinate rotated variables   
  Sample (1, WCO2_Cov_fc,  IEEE4)
  Sample (1, WH2O_Cov_fc,  IEEE4)
  Sample (1, CO2_E_WPL_fc, IEEE4)    'CO2 flux, WPL term due to water vapor flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, CO2_T_WPL_fc, IEEE4)    'CO2 flux, WPL term due to temperature flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_E_WPL_fc, IEEE4)    'H2O flux, WPL term due to water vapor flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)
  Sample (1, H2O_T_WPL_fc, IEEE4)    'H2O flux, WPL term due to temperature flux (WPL here denots "WPL term for WPL correction" instead of WPL correction)

  '** Summary of diagnosis flags of IRGA
  Totalize (1, n, IEEE4, (irga_disable_f OR CO2_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("CO2_samples_Tot")
  Totalize (1, n, IEEE4, (irga_disable_f OR H2O_bad_rng_sig_array(MAX_LAG +1)))
  FieldNames ("H2O_samples_Tot")

  Totalize (1, n, IEEE4, diag_irga <> -1)
  FieldNames ("no_irga_head_Tot")
  Totalize (1, n, IEEE4, diag_irga <> NAN)
  FieldNames ("no_new_irga_data_Tot")
  Totalize (1, n, IEEE4, irga_bad_data_f       IMP (diag_irga = NAN))
  FieldNames ("irga_bad_data_f_Tot")
  Totalize (1, n, IEEE4, irga_gen_fault_f      IMP (diag_irga = NAN))
  FieldNames ("irga_gen_fault_f_Tot")
  Totalize (1, n, IEEE4, irga_startup_f        IMP (diag_irga = NAN))
  FieldNames ("irga_startup_f_Tot")
  Totalize (1, n, IEEE4, irga_motor_spd_f      IMP (diag_irga = NAN))
  FieldNames ("irga_motor_spd_f_Tot")
  Totalize (1, n, IEEE4, irga_tec_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_tec_tmpr_f_Tot")
  Totalize (1, n, IEEE4, irga_src_pwr_f        IMP (diag_irga = NAN))
  FieldNames ("irga_src_pwr_f_Tot")
  Totalize (1, n, IEEE4, irga_src_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_tmpr_f_Tot")
  Totalize (1, n, IEEE4, irga_src_curr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_src_curr_f_Tot")
  Totalize (1, n, IEEE4, irga_off_f            IMP (diag_irga = NAN))
  FieldNames ("irga_off_f_Tot")
  Totalize (1, n, IEEE4, irga_sync_f           IMP (diag_irga = NAN))
  FieldNames ("irga_sync_f_Tot")
  Totalize (1, n, IEEE4, irga_amb_tmpr_f       IMP (diag_irga = NAN))
  FieldNames ("irga_amb_tmpr_f_Tot")
  Totalize (1, n, IEEE4, irga_amb_press_f      IMP (diag_irga = NAN))
  FieldNames ("irga_amb_press_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_I_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_I_f          IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_I_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_Io_f         IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_Io_var_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_Io_var_f     IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_Io_var_f_Tot")
  Totalize (1, n, IEEE4, irga_CO2_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_CO2_sig_strgth_f_Tot")
  Totalize (1, n, IEEE4, irga_H2O_sig_strgth_f IMP (diag_irga = NAN))
  FieldNames ("irga_H2O_sig_strgth_f_Tot")
  Totalize (1, n, IEEE4, irga_cal_err_f        IMP (diag_irga = NAN))
  FieldNames ("irga_cal_err_f_Tot")
  Totalize (1, n, IEEE4, irga_htr_ctrl_off_f   IMP (diag_irga = NAN))
  FieldNames ("irga_htr_ctrl_off_f_Tot")
  '*** End of IRGA output data ***

  #If (SENSOR_FW) Then
  '*** Beginning of FW output data ***
  '** Before coordinate rotation
  Sample (1, UxFW_Cov, IEEE4)
  Sample (1, UyFW_Cov, IEEE4)
  Sample (1, UzFW_Cov, IEEE4)

   '** After coordinate rotations, Ux is represented by U, Uy by V, and Uz by W.
  Sample (1, UFW_Cov, IEEE4)
  Sample (1, VFW_Cov, IEEE4)
  Sample (1, WFW_Cov, IEEE4)

  ' ** _fc indicates after and freq corrections based on coordinate-rotated data  
  Sample (1, WFW_Cov_fc,     IEEE4)
   '*** End of FW output data ***
  #EndIf
 
  ' *** Variables used for correction ***
  '** Rotation-related variables
  Sample (1, alpha, IEEE4)                   'Pitch angle
  Sample (1, beta,  IEEE4)                   'Roll angle
  Sample (1, gamma, IEEE4)                   'Yaw angle

  '** Stability-related variables
  Sample (1, height_measurement,    IEEE4)   'Measurement height (m)
  Sample (1, height_canopy,         IEEE4)   'Canopy height (m).
  Sample (1, surface_type_text,    String)   'Crop, Grass, Forest, Shrub, Bare Land, or Water, or Ice
  Sample (1, displacement_user,     IEEE4)   'Displacement height input by a user (0 is fefault and d is auto calculated and is used)
  Sample (1, d,                     IEEE4)   'Displacement height used by program (d = displacement_user if displacement_user <> 0; otherwise, it is auto calculated)
  Sample (1, roughness_user,        IEEE4)   'Roughness length input by a user (0 is fefault and z0 is auto calculated and is used)
  Sample (1, z0,                    IEEE4)   'Roughness length used by program z0 = displacement_user if roughness_user <> 0; otherwise, it is auto calculated
  Sample (1, z,                     IEEE4)   'Aerodynamic height
  Sample (1, MO_LENGTH,             IEEE4)   'Monin-Obukhov length
  Sample (1, ZL,                    IEEE4)   'Atmospheric boundary-layer stability.
  Sample (1, iteration_FreqFactor,  UINT2)   'Iteration number in calculation of freq correction factor for U'W', V'W', and Ts'W'
  Sample (1, latitude,              IEEE4)
  Sample (1, longitude,             IEEE4)

  '** Freq correction related variables
  ' IRGA separation variables
  Sample (2, separation_x_irga,        IEEE4)  'The 11st to 12nd elements of stn_conf_array: separation_x_irga, separation_y_irga
  Sample (1, separation_lat_dist_irga, IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_irga, IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_irga, IEEE4)  'Lag in scan number as the wind passes IRGA after passing CSAT. not neccessarily to use integer

  #If (SENSOR_FW) Then
  Sample (3, separation_x_FW,          IEEE4)  'The 17th, 18th, and 19th elements of stn_conf_array: separation_x_FW, separation_y_FW, and FW_diameter
  Sample (1, separation_lat_dist_FW,   IEEE4)  'Separation distance in direction normal to wind direction. Used for separation correction
  Sample (1, separation_lag_dist_FW,   IEEE4)  'Separation distance along wind direction. Used for lag maximization
  Sample (1, separation_lag_scan_FW,   IEEE4)  'Lag in scan number the wind passes FW after pass CSAT. not neccessary to use integer
  Sample (1, time_const_FW,            IEEE4)
  #EndIf
  
  Sample (1, MAX_LAG,  UINT2)
  FieldNames ("MAX_LAG")
  Sample (1, lag_irga, IEEE4)

  #If (SENSOR_FW) Then
  Sample (1, lag_FW,   IEEE4)
  #EndIf
 
  Sample (1, FreqFactor_UW_VW,     IEEE4)  'Frequency correction factor for WU and WV
  Sample (1, FreqFactor_WT_SONIC,  IEEE4)  'Frequency correction factor for WT_SONIC
  Sample (1, FreqFactor_WCO2_WH2O, IEEE4)  'Frequency correction factor for covariance of CSI (CS) open-path (OPEC) vertical wind with h2o and co2

  #If (SENSOR_FW) Then
  Sample (1, FreqFactor_WFW,       IEEE4)  'Frequency correction factor for covariance of CSAT vertical wind with fine thermocouple (FW) Temperature
  #EndIf
  ' *** End of correction related variables ***

  ' *** Output air properties calculated using measurements ***
  Sample (2, amb_rho_d_Avg,    IEEE4)      'Density of dry air (g/m^3) and density of moist air (kg/m^3). Calculated from 107 temperature, H2O, and pressure   
  Sample (2, rho_d_Avg,        IEEE4)      'Density of dry air (g/m^3) and density of moist air (kg/m^3). Calculated from sonic temperature, H2O, and pressure  
  
  #If (SENSOR_TMPR_RH) Then
  '*** Temperature and humidity probe data   
  Sample  (2, rho_d_probe_Avg, IEEE4)      'Density of dry air (g/m^3) and density of moist air (kg/m^3). Measured from temperaure and humidity probe
  #EndIf

  Sample (1, Cp,               IEEE4)      'Specific heat of moist air at constant pressure, calculated using measurements from IRGA and sonic [J/(kg K)]
  Sample (1, Lv,               IEEE4)      'Latent heat of vaporization [J/g].
  ' *** End of output atmospheric constants ***

  '*** Beginning of other output data ***
  Average(1, panel_tmpr, IEEE4, FALSE)

  #If (PERIPHERAL_CDM_A116) Then
  '*** Beginning of CDM-A116 pannel temperature ***
  Average  (NMBR_PANEL_TMPR_CDM, panel_tmpr_CDM_A116_1, IEEE4, FALSE)
  '*** End of CDM-A116 pannel temperature ***      
  #EndIf   

  Average  (1, batt_volt,  IEEE4, slowsequence_disable_flg)
  Totalize (1, n,          IEEE4, slowsequence_disable_flg)
  FieldNames ("slowsequence_Tot")
  '*** End of other output data ***

  ' *** Beginning of variables to monitor datalogger performance ***
  Average  (1, process_time, IEEE4, FALSE)
  Maximum  (1, process_time, IEEE4, FALSE, FALSE)
  FieldNames ("process_time_Max")
  Maximum  (1, buff_depth,   IEEE4, FALSE, FALSE)
  FieldNames ("buff_depth_Max")
  ' *** End of variables to monitor datalogger performance ***

EndTable

'******************************
'*** TIME SERIES DATA TABLE ***
'******************************
DataTable (Time_Series, TRUE, -1)
  DataInterval (0, SCAN_INTERVAL, mSec, 100)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".Time_Series_", 64, -1, 0, NMBR_DAY_TIMESERIES_CRD, Day, 0, 0)

  '*** Beginning of CSAT time series output ***
  Sample (3, Ux, IEEE4)
  FieldNames ("Ux,Uy,Uz")
  Sample (1, Ts, IEEE4)
  FieldNames ("Ts")
  Sample (1, diag_sonic, IEEE4)
  FieldNames ("diag_sonic")
  '*** End of CSAT time series output ***

  '*** Beginning of IRGA time series output ***
  Sample (3, irga(1),IEEE4)
  FieldNames ("CO2,H2O,diag_irga")

  #If (SENSOR_IRGASON) Then
  Sample (1, Tc, IEEE4)
  FieldNames ("Tc")
  #EndIf

  Sample (4, amb_tmpr,IEEE4)
  FieldNames ("amb_tmpr,amb_press,CO2_sig_strgth,H2O_sig_strgth")
  '*** End of IRGA time series output ***

  #If (SENSOR_FW) Then
  '*** Beginning of FW time series output ***
  Sample (1, FW, IEEE4)
  FieldNames ("FW")
  '*** End of FW time series output ***
  #EndIf
EndTable

'***********************
'*** DIAGNOSTIC DATA ***
'***********************
DataTable (diagnostic, TRUE, 1)
  Sample (6, sonic_amp_l_f,    Boolean)
  Sample (22, irga_bad_data_f, Boolean)
EndTable

'*************************
'*** EC100 SETTING LOG ***
'*************************
DataTable (EC100_Config, TRUE, 1)
  TableFile ("CRD:"&Status.SerialNumber(1,1)&".ec100_config_", 64, -1, 0, 365, Day, 0, 0)
  Sample (1, ec100_setting_array(1, 2), IEEE4)
  FieldNames ("bandwidth_freq")
  Sample (1, ec100_setting_array(2, 2), IEEE4)
  FieldNames ("press_source")
  Sample (1, ec100_setting_array(3, 2), IEEE4)
  FieldNames ("tmpr_source")
  Sample (1, ec100_setting_array(4, 2), IEEE4)
  FieldNames ("CO2_zero_coeff")
  Sample (1, ec100_setting_array(5, 2), IEEE4)
  FieldNames ("CO2_span_coeff")
  Sample (1, ec100_setting_array(6, 2), IEEE4)
  FieldNames ("H2O_zero_coeff")
  Sample (1, ec100_setting_array(7, 2), IEEE4)
  FieldNames ("H2O_span_coeff")
  Sample (1, ec100_setting_array(8, 2), IEEE4)
  FieldNames ("Heater_control")
  Sample (1, ec100_setting_array(9, 2), IEEE4)
  FieldNames ("IRGA_power")
  Sample (1, ec100_setting_array(10, 2), IEEE4)
  FieldNames ("Shadow_corr")
EndTable
'*** End of output data tables ***


'*******************'
'*** SUBROUTINES ***'
'*******************'

'*** Subroutnes for coordinate rotation corrections  ***
' 1. Two Subroutnes for Double Rotations
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum with scalar variables

' Definition of double rotation: the 1st AND 2nd rotations in Tanner & Thurtell (1969)
'      a. Counterclockwise about the instrument z-axis for Gamma degrees
'      b. Counterclockwise about the intermediate y-axis for Alpha degrees
'         [Originally clockwise. Following Wilczak et al. (2001), counterclockwise rotation is used]

'  SUBROUTINE                     MAIN PROGRAM
'  alph                           alpha 
'  bet                            beta
'  gamm                           gamma
'  U_mean, V_mean, W_mean         Ux_Avg, Uy_Avg, Uz_Avg
'  UU_cov, VV_cov, WW_cov         Ux_Var, Uy_Var, Uz_Var
'  UVcov,  UWcov,  VWcov          UxUy_cov, UxUz_cov, UyUz_cov         
'  Umean_R, Vmean_R, Wmean_R      U, V, W
'  UUcov_R, VVcov_R, WWcov_R      U_Var, V_Var, W_Var
'  UVcov_R, UWcov_R, VWcov_R      UV_Cov, UW_Cov, VW_Cov  
'  SU_cov,  SV_cov, SW_cov        SUx_cov,  SUy_cov, SUz_cov   where S is a scalar varible (e.g. CO2, H2O, or T_SONIC)   
'  SUcov_R, SVcov_R, SWcov_R      SU_cov, SV_cov, SW_cov       where S is a scalar varible (e.g. CO2, H2O, or T_SONIC) 
     
' Sub: Rotation12_Momentum (where "12" indicates the 1st and 2nd rotations)
'      Transform the expression of momentum variables in the instrument coordinate system to the natural wind coordinate system.
Sub Rotation12_Momentum(alph, gamm, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For effiecient calculations, effiecient use of memory, and shorter expressions in the following equations, the variables of "UWcov_R" and
  ' "VWcov_R" are used first as intermediate variables before both variables are needed for their own roles.
  UWcov_R =  UU_cov*COS(gamm)*COS(gamm) + VV_cov*SIN(gamm)*SIN(gamm)
  VWcov_R =  UWcov*COS(gamm) + VWcov*SIN(gamm)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = COS(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) - W_mean*SIN(alph)
  Vmean_R = 0
  Wmean_R = SIN(alph)*(U_mean*COS(gamm) + V_mean*SIN(gamm)) + W_mean*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = COS(alph)*COS(alph)*UWcov_R + _
  WW_cov*SIN(alph)*SIN(alph) + UVcov*COS(alph)*COS(alph)*SIN(2*gamm) - _
  SIN(2*alph)*VWcov_R

  VVcov_R = UU_cov*SIN(gamm)*SIN(gamm) + VV_cov*COS(gamm)*COS(gamm) - UVcov*SIN(2*gamm)

  WWcov_R = SIN(alph)*SIN(alph)*UWcov_R  + _
  WW_cov*COS(alph)*COS(alph) + UVcov*SIN(alph)*SIN(alph)*SIN(2*gamm) + _
  SIN(2*alph)*VWcov_R

  'b. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = -0.5*(UU_cov - VV_cov)*COS(alph)*SIN(2*gamm) + _
  UVcov*COS(alph)*COS(2*gamm) + _
  SIN(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

  UWcov_R =  0.5*SIN(2*alph)*(UWcov_R - WW_cov + UVcov*SIN(2*gamm)) + COS(2*alph)*VWcov_R

  VWcov_R = -SIN(alph)*(0.5*(UU_cov - VV_cov)*SIN(2*gamm)-UVcov*COS(2*gamm))- _
  COS(alph)*(UWcov*SIN(gamm) - VWcov*COS(gamm))

EndSub

' Sub: Rotation12_Scalar_Covariance [where "12" indicates the 1st and 2nd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of variance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in x and y.

Sub Rotation12_Scalar_Covariance(alph, gamm, SU_cov,  SV_cov, SW_cov, SUcov_R, SVcov_R, SWcov_R)

  SUcov_R =  COS(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) - SW_cov*SIN(alph)

  SVcov_R = -SU_cov*SIN(gamm) + SV_cov*COS(gamm)

  SWcov_R =  SIN(alph)*(SU_cov*COS(gamm) + SV_cov*SIN(gamm)) + SW_cov*COS(alph)

EndSub

' 2. Sub-programs for Planar Fit Rotations [Wilczak et al. (2001)]
'    a. Rotations for momentum covariance
'    b. Rotations for covariance of momentum variable with scalar variables

'    Planar Fit Rotations
'      a. Counterclockwise rotation about the instrument y-axis for Alph degrees  [2nd rotation in Tanner and Thurtell (1969), clockwise]
'      b. Counterclockwise rotation about the intermediate x-axis for Beta degrees [3rd rotation in Tanner and Thurtell (1969)]

' Sub: Rotation23_Momentum [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
Sub Rotation23_Momentum(alph, bet, _
  U_mean,  V_mean,  W_mean,  UU_cov,  VV_cov,  WW_cov,  UVcov,   UWcov,   VWcov, _
  Umean_R, Vmean_R, Wmean_R, UUcov_R, VVcov_R, WWcov_R, UVcov_R, UWcov_R, VWcov_R )

  ' For efficient calculations, efficient use of memory, and shorter expressions in the following equations, the four variables of Wmean_R, UVcov_R,
  ' UWcov_R, and VWcov_R are used first as intermediate variables for repeated terms before the four variables are needed for their own roles.
  Wmean_R =  V_mean*SIN(bet) - W_mean*COS(bet)
  UVcov_R =  VV_cov*SIN(bet)*SIN(bet) - VWcov*SIN(2*bet) + WW_cov*COS(bet)*COS(bet)
  UWcov_R =  UVcov*SIN(bet) - UWcov*COS(bet)
  VWcov_R =  UVcov*COS(bet) + UWcov*SIN(bet)

  ' a. ROTATIONS FOR MEAN TERMS
  Umean_R = U_mean*COS(alph) +  Wmean_R*SIN(alph)
  Vmean_R = V_mean*COS(bet)  +  W_mean *SIN(bet)
  Wmean_R = U_mean*SIN(alph) -  Wmean_R*COS(alph)

  ' b. ROTATIONS FOR VARIANCE TERMS
  UUcov_R = UU_cov*COS(alph)*COS(alph) + UVcov_R*SIN(alph)*SIN(alph) + UWcov_R*SIN(2*alph)

  VVcov_R = VV_cov*COS(bet)*COS(bet)   + VWcov*SIN(2*bet)           + WW_cov*SIN(bet)*SIN(bet)

  WWcov_R = UU_cov*SIN(alph)*SIN(alph) + UVcov_R*COS(alph)*COS(alph) - UWcov_R*SIN(2*alph)

  'b. ROTATIONS FOR COVARIANCE TERMS
  UVcov_R = SIN(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)- VWcov*COS(2*bet)) + COS(alph)*VWcov_R

  UWcov_R = 0.5*SIN(2*alph)*(UU_cov - VV_cov*SIN(bet)*SIN(bet) -WW_cov*COS(bet)*COS(bet)+ VWcov*SIN(2*bet))- COS(2*alph)*UWcov_R

  VWcov_R = -COS(alph)*(0.5*(VV_cov - WW_cov)*SIN(2*bet)-VWcov*COS(2*bet))+SIN(alph)*VWcov_R

EndSub

' Sub: Rotation23_Scalar_Covariance [where "23" indicates the 2nd and 3rd rotations in Tanner & Thurtell (1969)]
'      Transform the expression of covariance of scalar with momentum variables in the instrument coordinate system
'      to the natural wind coordinate system in z.

Sub Rotation23_Scalar_Covariance(alph, bet, _
  SU_cov,   SV_cov,   SW_cov, _
  SU_cov_R, SV_cov_R, SW_cov_R)

  SU_cov_R =  SU_cov*COS(alph) + SIN(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

  SV_cov_R =  SV_cov*COS(bet)  + SW_cov*SIN(bet)

  SW_cov_R =  SU_cov*SIN(alph) - COS(alph)*(SV_cov*SIN(bet) - SW_cov*COS(bet))

EndSub
'*** End of subroutnes for coordinate rotation corrections  ***


'*** Subroutine to calculate displacement height, roughness length, and aerodynamic height ***

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' S_type                 Surface_type
' d_user                 displacement_user
' z0_user                Roughness_user
' h_canopy               height_canopy
' h_measurement          height_measurement
' displacement           d
' Roughness              z0
' h_aerodynamic          z (sensing height above the ground - d)

Sub  Displacement_roughness_heights (S_type, d_user, z0_user, h_canopy, h_measurement, displacement, roughness, h_aerodynamic)
  ' Calculate displacement height, roughness length, and aerodynamic height
  If ((S_type = CROP) OR (S_type = GRASS)) Then            'Crop and grass

    Select Case h_canopy
    Case Is = 0
      displacement = 0                                     'Default w/o canopy
      roughness    = 0.01                                  'Default w/o canopy
    Case Is >0
      displacement = 10^(0.979*LOG10(h_canopy)-0.154)      'Crop or grass canopy, Eq. 4.5, page 138 in Rosenberg et al. (1983)
      roughness    = 10^(0.977*LOG10(h_canopy)-0.883)      'Crop or grass canopy, Eq. 4.4, page 137 in Rosenberg et al. (1983)
    EndSelect

  EndIf

  If ((S_type = FOREST) OR (S_type = SHRUB)) Then          'Forest and Shrub
    displacement = 2*h_canopy/3                            'Forest canopy, 2/3 rule, page 116, Oke, 1987
    roughness    = 0.06*h_canopy                           'Forest canopy, Jarvis et al. (1976) ans Raupach et al. (1991)
  EndIf

  If ((S_type = BARELAND) OR (S_type = WATER) OR (S_type = ICE)) Then   'Bare land and water
    displacement = 0                                                    'Default w/o canopy
    roughness    = 0.01                                                 'Default w/o canopy
  EndIf

  If (d_user <> 0)  Then displacement = d_user             'User preferred has a priority
  If (z0_user <> 0) Then roughness    = z0_user            'User preferred has a priority

  h_aerodynamic = h_measurement - displacement
EndSub
'*** End of subroutine to calculate displacement height, roughness length, and aerodynamic height ***


'*** Subroutines for freq correction factors ***

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' freq_factor            FreqFactor_uw_vw

' *** Freq factor for UW and VW
Sub FreqFactorCSAT_UW_VW_BA_LA (height_aerodynamic, stability, U_total, freq_factor)
  'Variables used inside subrotine
  Dim cosp_uw                       'Cospectrum of U or V with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_uu               'Transfer function of line averaging for UU or VV

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of U or V with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of U or V with W
  Dim weight                        'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The uppercase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Define intermediate variables to reduce the repeat computation inside iteration loops
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*PI*pu_csat*freq
  Dim A_uw, B_uw                    'Parameters in the cospectrum of U with W for stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0

    'Prepair calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of U with W for stable condition
    Select Case stability
    Case Is > 0 AND Is <= 4
      A_uw =  0.124*((1 + 7.9*stability)^0.75)       'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1 + 7.9*stability)^(-0.825))   'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of stabilty from -2 to 2 (pgs 17, 28, 41~43, Kaimal & Finnigan 1994). Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_uw =  0.124*((1 + 7.9*4.0)^0.75)             'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_uw = 23.252*((1 + 7.9*4.0)^(-0.825))         'a parameter in eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    ' Calculate correction factor
    For J = 0 To FREQ_BIN
      freq  = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2*PI*pu_csat*freq

      '** Cospectrum
      If stability > 0 Then
        cosp_uw = freq*zu/(A_uw + B_uw*(freq*zu)^2.1)             'Eq. 21 in Moore (1986), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (freq*zu)                                     'Eq. 26 in Moore (1986), eqs. 17 & 18 in Moncrieff et al (1997), eq. 2.85 in Dijk (2002)
        Case Is < 0.24
          cosp_uw = 20.78*freq*zu/((1 + 31*freq*zu)^1.575)
        Case Is >= 0.24
          cosp_uw = 12.66*freq*zu/((1 + 9.6*freq*zu)^2.4)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2   'Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Inside SIN(), angle degrees must be used.
      tran_func_LA_uu = (SIN (180*pu_csat*freq)/(PI*pu_csat*freq))^2                            'Eq. 2.70 in DijK (2002)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww = (4/PI2_pu_freq_csat)*(1+ (PI2_pu_freq_csat+3)/(2*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3/(2*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww = 1 'Due to single precision in CR6, this term cannot be calculated when the 2*Pi*dimensiless_freq < 0.01. This is an approximation. The error in the approximation < 0.001
      EndIf

      ' Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_uw

      freq_factor_denominator += weight*cosp_uw*tran_func_BA*SQR(tran_func_LA_uu*tran_func_LA_ww)

    Next J

    '** correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1
  EndIf
EndSub

' *** Frequency factor for wTs

'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
' height_aerodynamic     z
' Stability              ZL
' U_total                WS_rslt
' tran_func_LA_Dijk()    tran_func_LA_data_Dijk()
' freq_factor            FreqFactor_WT_SONIC

Sub FreqFactorCSAT_wTs_BA_LA (height_aerodynamic, stability, U_total, tran_func_LA_Dijk(2,35), freq_factor)
  'Variables used inside subrotine
  Dim cosp_wTs                 'Copectrum of Ts with W
  Dim tran_func_BA             'Transfer function of block averaging for covariance
  Dim Tran_func_LA_wTs         'Transfer function of line averaging for WT_SONIC

  Dim freq                     'Cyclic frequency
  Dim freq_factor_numerator    'Numerator to calculate the freq correction factor for covariance of T_SONIC with W
  Dim freq_factor_denominator  'Denominator to calculate the freq correction factor for covariance of T_SINIC with W
  Dim weight                   'Weight factor in numerical integration of Composite Simpson's Rule
  Dim J  As Long               'Index for the outmost iteration. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  Dim jj As Long               'Index for the iteration inside the outmost iteration
  Dim Prev_jj As Long

  'Define following variables for saving computation time by calculating these once outside iteration loops or reduce the repeat computations
  Dim zu                       'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                  'PATH_LENGTH_CSAT/U_total
  Dim PI2_pu_freq_csat         'Intermediate variable 2*PI*pu_csat*freq
  Dim A_wTs, B_wTs             'Parameters in the cospectrum of T_SONIC with W in a stable condition

  If ((stability <> NaN) AND (U_total <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0
    Prev_jj                 = 1

    'Prepair calculations
    zu      = height_aerodynamic/U_total
    pu_csat = PATH_LENGTH_CSAT/U_total

    'Calculate parameters in the cospectrum of W with T_SONIC for stable condition
    Select Case stability
    Case Is > 0 AND Is <= 4
      A_wTs = 0.2840*((1 + 6.4*stability)^0.75)               'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1 + 6.4*stability)^(-0.825))           'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4  'Similarity functions are defined in a range of stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994).  Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_wTs = 0.2840*((1 + 6.4*4.0)^0.75)                     'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      B_wTs = 9.3447*((1 + 6.4*4.0)^(-0.825))                 'a parameter in Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = 2*PI*pu_csat*freq

      '**Cospectrum
      If stability > 0 Then
        cosp_wTs   = zu*freq/(A_wTs + B_wTs*(zu*freq)^2.1)      'Eq.21 in Moore (1986), eqs.12 & 13 in Moncrieff et al. (1997), eq.2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (zu*freq)                                   'Eq.25 in Moore (1986), eqs.15 & 16 in Moncrieff et al. (1997), eq.2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wTs = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wTs =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)     '4.378 from original source Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '**Transfer function
      tran_func_BA = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2   'Eq.4 in Kaimal et al (1989), Eq.3 in Massman (2000)

      For jj = Prev_jj To 34
        If  (PI2_pu_freq_csat >= tran_func_LA_Dijk(1,jj)) AND  (PI2_pu_freq_csat < tran_func_LA_Dijk(1, jj+1)) Then

          Tran_func_LA_wTs = tran_func_LA_Dijk(2,jj) + (PI2_pu_freq_csat-tran_func_LA_Dijk(1,jj))*(tran_func_LA_Dijk(2,jj+1) _
                             -tran_func_LA_Dijk(2,jj))/(tran_func_LA_Dijk(1,jj+1) - tran_func_LA_Dijk(1,jj))
          Prev_jj = jj

          ExitFor
        EndIf
      Next jj

      If PI2_pu_freq_csat >= tran_func_LA_Dijk(1, 35) Then Tran_func_LA_wTs = tran_func_LA_Dijk(2, 35)

      'Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in sequential order.

      freq_factor_numerator   += weight*cosp_wTs
      freq_factor_denominator += weight*cosp_wTs*tran_func_BA*Tran_func_LA_wTs

    Next J

    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1
  EndIf
EndSub

' *** Freq factor of CSAT + CSI IRGA for WCO2 and WH2O
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' separation_lat_dis     separation_lat_dist_IRGA
' Freq_factor            FreqFactor_wco2_wh2o

Sub FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (height_aerodynamic, stability, U_total, separation_lat_dis, freq_factor)
  'Variables used inside subrotine
  Dim cosp_wco2_wh2o                'Cospectrum of CO2 or H2O with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_LA_co2_h2o          'Transfer function of line averaging for variance of CO2 or H2O
  Dim Tran_func_SP_wco2_wh2o        'Transfer function of lateral separation (normal to the wind direction) between CSAT for W and IRGA for CO2 or H2O

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of CO2 or H2O with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of CO2 or H2O with W
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule
  Dim J As Long                     'Iteration index. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computations
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim pu_csat                       'path_length_cast/U_total
  Dim pu_irga                       'path_length_irga/U_total
  Dim du_irga                       'Ratio of effective lateral separation distance (normal to wind) to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*pu_csat
  Dim PI2_pu_irga                   'Intermediate variable 2*Pi*pu_irga
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*pu_csat*freq
  Dim PI2_pu_freq_irga              'Intermediate variable 2*Pi*pu_irga*freq
  Dim A_wco2_wh2o, B_wco2_wh2o      'Parameters in the cospectrum of scalar (e.g. CO2 or H2O) with W

  If ((stability <> NaN) AND (U_total <> NaN) AND (separation_lat_dis <> NaN)) Then

    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0

    'Prepair calculations
    zu       = height_aerodynamic/U_total
    pu_csat  = PATH_LENGTH_CSAT/U_total
    pu_irga  = PATH_LENGTH_IRGA/U_total
    du_irga  = ABS(separation_lat_dis)/U_total
    PI2_pu_csat  = 2*PI*pu_csat
    PI2_pu_irga  = 2*PI*pu_irga

    'Calculate parameters in the cospectrum of W with CO2 or H2O for stable condition
    Select Case stability
    Case Is > 0 AND Is <= 4
      A_wco2_wh2o = 0.2840*((1 + 6.4*stability)^0.75)         'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1 + 6.4*stability)^(-0.825))     'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4   'Similarity functions are defined in a range of Stability (ZL) from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994). Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_wco2_wh2o = 0.2840*((1 + 6.4*4.0)^0.75)               'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wco2_wh2o = 9.3447*((1 + 6.4*4.0)^(-0.825))           'Parameter in Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Start calculations for correction factors
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat  = PI2_pu_csat*freq
      PI2_pu_freq_irga  = PI2_pu_irga*freq

      '**Cospectrum
      If stability > 0 Then
        cosp_wco2_wh2o = zu*freq/(A_wco2_wh2o + B_wco2_wh2o*(zu*freq)^2.1)    'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (freq*zu)                                                 'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wco2_wh2o = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wco2_wh2o =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)             '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer functions
      tran_func_BA = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2   'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be used insoide SIN().

      Tran_func_SP_wco2_wh2o = EXP(-9.9*(du_irga*freq)^1.5)                                  'Spatial separation: Eq. 4.8 in Foken et al. (2012)

      If PI2_pu_freq_csat >= 0.01 Then                                                       'Line averaging
        tran_func_LA_ww  = (4/PI2_pu_freq_csat)*(1+ (PI2_pu_freq_csat+3)/(2*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3/(2*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_ww  = 1       'Due to sigle precision in CR6, this term cannot be calculated when the 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      If PI2_pu_freq_irga >= 0.01 Then
        tran_func_LA_co2_h2o = (1/PI2_pu_freq_irga)*(3+ (PI2_pu_freq_irga+4)/(PI2_pu_freq_irga*EXP(PI2_pu_freq_irga)) -4/PI2_pu_freq_irga)      'Eq. 7 in Moore (1986), page 610 in Moncrieff et al (1997)
      Else
        tran_func_LA_co2_h2o  = 1   'Due to sigle precision in CR6, this term cannot be calculated when the normalized frequency < 0.01 Hz. This is an approximation with an error < 0.001
      EndIf

      'Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator    += weight*cosp_wco2_wh2o

      freq_factor_denominator  += weight*cosp_wco2_wh2o*tran_func_BA*SQR(tran_func_LA_ww*tran_func_LA_co2_h2o)*Tran_func_SP_wco2_wh2o

    Next J

    '** Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
  Else
    freq_factor = 1
  EndIf

EndSub


#If (SENSOR_FW) Then  
' *** Frequency factor of CSAT + FW for WT_FW (T_FW is the temperature measured using fine wire thermocouple of FW05, FW1, FW2, or FW3)  
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
' height_aerodynamic     z
' stability              ZL
' U_total                WS_rslt
' separation_lat_dis     separation_lat_dist_FW
' time_const             time_const_FW
' Freq_factor            FreqFactor_wFW

Sub FreqFactorCSATFW_wT_BA_LA_TC_SP (height_aerodynamic, stability, U_total, separation_lat_dis, time_const, freq_factor)
  'Variables used inside subroutine
  Dim cosp_wT                       'Cospectrum of T with W
  Dim tran_func_BA                  'Transfer function of block averaging for covariance
  Dim tran_func_LA_ww               'Transfer function of line averaging for WW
  Dim tran_func_TC_TT               'Transfer function of time constant for TT
  Dim Tran_func_SP_wT               'Transfer function of lateral separation between CSAT3 w and FW T
  Dim A_wT, B_wT                    'Parameters in the cospectrum of scalar (e.g. CO2 or H2O) with W in the stable condition

  Dim freq                          'Cyclic frequency
  Dim freq_factor_numerator         'Numerator to calculate the freq correction factor for covariance of T with W
  Dim freq_factor_denominator       'Denominator to calculate the freq correction factor for covariance of T with W
  Dim weight                        'Weight factor in the numerical integration of Composite Simpson's Rule.
  Dim J As Long                     'Iteration index. The upcase letter J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
         
  'Define following variables for saving computation time by calculating these once outside iteration loops or by reducing repeat computation
  Dim zu                            'z/U_total, ratio of aerodynamic height to total horizontal velocity
  Dim du_FW                         'The ratio of effective lateral separation distance to total wind speed
  Dim PI2_pu_csat                   'Intermediate variable 2*Pi*path_length_csat/U_total
  Dim PI2_pu_freq_csat              'Intermediate variable 2*Pi*(path_length_csat/U_total)*freq

  If ((stability <> NaN) AND (U_total <> NaN) AND (separation_lat_dis <> NaN)) Then
    'Reset variables
    freq_factor_numerator   = 0
    freq_factor_denominator = 0

    'Prepair calculations
    zu          = height_aerodynamic/U_total
    PI2_pu_csat = 2*PI*PATH_LENGTH_CSAT/U_total
    du_FW       = ABS(separation_lat_dis)/U_total

    'Calculate the parameters in the cospectrum of scalar with W for a stable surface-layer condition
    Select Case stability
    Case Is > 0 AND Is <= 4.0
      A_wT = 0.2840*((1 + 6.4*stability)^0.75)        'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1 + 6.4*stability)^(-0.825))    'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)

    Case Is > 4  'Similarity functions are defined in a range of ZL from -2 to 2 (pgs 28, 41~43, Kaimal & Finnigan 1994). Extened to 4 as shown in Fig 5.23 in Stull (1988)
      A_wT = 0.2840*((1 + 6.4*4.0)^0.75)              'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      B_wT = 9.3447*((1 + 6.4*4.0)^(-0.825))          'a parameter in eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
    EndSelect

    'Calculate correction factor
    For J = 0 To FREQ_BIN
      freq = START_FREQ*(STEP_BASE_FREQ^J)

      PI2_pu_freq_csat = PI2_pu_csat*freq

      '** Cospectrum
      If (stability > 0) Then
        cosp_wT   = zu*freq/(A_wT + B_wT*(zu*freq)^2.1)          'Eq. 21 in Moore (1986), eqs. 12 & 13 in Moncrieff et al. (1997), eq. 2.80 & Table 2.1 in Dijk (2002)
      Else
        Select Case (freq*zu)                                    'Eq. 25 in Moore (1986), eqs. 15 & 16 in Moncrieff et al. (1997), eq. 2.84 in Dijk (2002)
        Case Is < 0.54
          cosp_wT = 12.92*zu*freq/((1 + 26.7*zu*freq)^1.375)
        Case Is >= 0.54
          cosp_wT =  4.378*zu*freq/((1 + 3.8*zu*freq)^2.4)       '4.378 from original source of Eq.25 in Moore (1986)
        EndSelect
      EndIf

      '** Transfer function
      tran_func_BA    = 1 - (SIN (10800*OUTPUT_INTERVAL*freq)/(PI*60*OUTPUT_INTERVAL*freq))^2     'Block averaging: Eq. 4 in Kaimal et al. (1989), Eq. 3 in Massman (2000). Angle degree must be sued inside SIN().
      Tran_func_SP_wT = EXP(-9.9*(du_FW*freq)^1.5)                                                'Spatial separation: Eq. 4.8 in Foken et al. (2012)
      tran_func_TC_TT = 1/(1+(2*PI*time_const*freq)^2)                                            'Time constant: Eq. 5 Horst (1997)

      If PI2_pu_freq_csat >= 0.01 Then
        tran_func_LA_ww  = (4/PI2_pu_freq_csat)*(1+ (PI2_pu_freq_csat+3)/(2*PI2_pu_freq_csat*EXP(PI2_pu_freq_csat)) -3/(2*PI2_pu_freq_csat))   'Eq. 9 in Moore (1986), pg. 610 in Moncrieff et al. (1997)
      Else
        tran_func_LA_ww  = 1   'Due to sigle precision in CR6, this term cannot be calculated when 2PI*dimensionless_frequency < 0.01. This is an approximation with an error < 0.001.
      EndIf

      'Composite Simpson's Rule
      weight = 2 + 2*(J MOD 2) + (J = 0) + (J = FREQ_BIN)  'In Composite Simpson's Rule, weight factor "1" for 1st and last terms, "2" for even, and "4" for odd terms in a sequential order.

      freq_factor_numerator   += weight*cosp_wT
      freq_factor_denominator += weight*cosp_wT*tran_func_BA*SQR(tran_func_LA_ww*tran_func_TC_TT) *Tran_func_SP_wT
    Next J
    
    '**Correction factor
    freq_factor = freq_factor_numerator/freq_factor_denominator
    
  Else

    freq_factor = 1
  EndIf
EndSub
#EndIf
'*** End of subroutines for freq correction factors ***

'*** Beginning of subroutines for data quality classification ***
'a. Data quality grading for momentum flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system   
'   Foken et al. (2012)
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  Sigma_u               U_SIGMA
'  Sigma_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  QC                    TAU_QC            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Momentum (Planar_Fit As Boolean, stability, Sigma_u, Sigma_w, U_star, lat, wnd_dir, RNS, QC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Chracteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCuu                      'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCww                      'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_uu_ww              'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_uu_ww_max_seq      'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occurrence   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occurrence   'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Momentum_1st_Occurrence   'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The upcase J is used to keep the editor's auto-correct feature 
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
 
 'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.15)
  RNS_category(2) = ((RNS >= 0.15) AND (RNS < 0.30))
  RNS_category(3) = (RNS  < 0.30)
  RNS_category(4) = ((RNS >= 0.30) AND (RNS < 0.75))
  RNS_category(5) = (RNS  < 0.75)
  RNS_category(6) = ((RNS >= 0.75) AND (RNS < 1.00))
  RNS_category(7) = ((RNS >= 1.00) AND (RNS  < 2.50))
  RNS_category(8) = ((RNS >= 2.50) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Chracteristic
  Coriolis_parameter = 2*Omega*SIN(lat)                    'Omega: earth anglular velocity

  Select Case stability
  Case Is <= -0.032
    ITCuu = 4.15*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)
    ITCww = 2.00*ABS(stability)^0.125                      'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITCuu = 2.7                                            'Table 4.2 (Foken et al. 2012)
    ITCww = 1.3                                            'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITCuu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 4.3 (Foken et al. 2012)
    ITCww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITCuu = -(Sigma_u/U_star)/9.1                          'Model unavailiable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCww = -(Sigma_w/U_star)/9.1                          'Model unavailiable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCuu = ABS((ITCuu - (Sigma_u/U_star))/ITCuu)            'In fraction
  ITCww = ABS((ITCww - (Sigma_w/U_star))/ITCww)            'In fraction

  If (NOT (Planar_Fit)) Then
    'If double rotation, both the max of ITC_uu and ITC_ww is used as ITC_uu_ww.
    MaxSpa(ITC_uu_ww, 2, ITCuu)                            'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_ww is used as ITC_uu_ww.
    ITC_uu_ww = ITCww
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_uu_ww < 0.30)
  ITC_category(2) = (ITC_uu_ww < 0.30)
  ITC_category(3) = ((ITC_uu_ww >= 0.30) AND (ITC_uu_ww < 0.75))
  ITC_category(4) = (ITC_uu_ww < 0.30)
  ITC_category(5) = ((ITC_uu_ww >= 0.30) AND (ITC_uu_ww < 1.00))
  ITC_category(6) = ((ITC_uu_ww >= 0.75) AND (ITC_uu_ww < 1.00))
  ITC_category(7) = ((ITC_uu_ww >= 1.00) AND (ITC_uu_ww < 2.50))
  ITC_category(8) = ((ITC_uu_ww >= 2.50) AND (ITC_uu_ww < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151) OR (wnd_dir >= 209)) Then
    Wnd_Momentum_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151) AND (wnd_dir <= 170)) OR ((wnd_dir >= 190) AND (wnd_dir < 209)))
    Wnd_Momentum_1st_Occurrence = 7
  ElseIf ((wnd_dir > 170) AND (wnd_dir < 190))
    Wnd_Momentum_1st_Occurrence = 0
  EndIf

  '1st case
  If  (RNS_Momentum_1st_Occurrence = 0) OR (ITC_Momentum_1st_Occurrence =0) OR (Wnd_Momentum_1st_Occurrence = 0) Then        'Any in category 9 (0 used for 9 now)
    QC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Momentum_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_uu_ww = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN

EndSub

'b. Data quality grading for momentum flux using steady state test and integral turbulence characteristics.
'   Foken et al. (2004).    
  
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  Planar_fit            Planar_Fit_flg
'  stability             ZL
'  Sigma_u               U_SIGMA
'  Sigma_w               W_SIGMA
'  U_star                USTAR
'  lat                   latitude
'  RNS                   RN_UW_VW_cov      RNS: Relative Non-Stationarity
'  TAU_SSITC             TAU_SSITC_TEST    Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit As Boolean, stability, Sigma_u, Sigma_w, U_star, lat, RNS, TAU_SSITC)
  ' Test on turbulence conditions in development
  Dim    ITC_uw(2)                              'ITC: Integral Turbulence Chracteristic. This array is used in instruction MaxSpa to select max
  Alias  ITC_uw(1) = ITCu                       'ITC for variance of horizontal velocity
  Alias  ITC_uw(2) = ITCw                       'ITC for variance of vertical velocity

  Dim    ITC_uw_max(2)                          'for use of instruction MaxSpa. Hold the max and the index of max location
  Alias  ITC_uw_max(1) = ITC_u_w                'ITC for momentum flux
  Alias  ITC_uw_max(2) = ITC_u_w_max_seq        'the index of max location

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean                'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean                'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Momentum_1st_Occur   'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Momentum_1st_Occur   'The lowest possible grade of ITC in the overall grade system
 
  Dim Lowest_Seq_Max(2)                                         'for use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                 'Used for index of iteration. The upcase J is used to keep the editor's auto-correct feature 
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
 
 'Reset
  TAU_SSITC = 0

  '1. Relative Non-Stationarity
  'Possible grade for Relative Non-Stationarity (Steady state test)
  RNS_category(1) = (RNS  < 0.15)
  RNS_category(2) = ((RNS >= 0.15) AND (RNS < 0.30))
  RNS_category(3) = (RNS  < 0.30)
  RNS_category(4) = ((RNS >= 0.30) AND (RNS < 0.75))
  RNS_category(5) = (RNS  < 0.75)
  RNS_category(6) = ((RNS >= 0.75) AND (RNS < 1.00))
  RNS_category(7) = ((RNS >= 1.00) AND (RNS  < 2.50))
  RNS_category(8) = ((RNS >= 2.50) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Momentum_1st_Occur = -J *RNS_category(J)
    If (RNS_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Chracteristic
  Coriolis_parameter = 2*Omega*SIN(lat)                    'Omega: earth anglular velocity

  Select Case stability
  Case Is <= -0.032
    ITCu = 4.15*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)
    ITCw = 2.00*ABS(stability)^0.125                      'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0
    ITCu = 2.7                                            'Table 9.1 (Foken et al. 2004)
    ITCw = 1.3                                            'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0
    ITCu = 0.44*LN(ABS(Coriolis_parameter)/U_star) + 6.3  'Table 9.2 (Foken et al. 2004)
    ITCw = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 9.2 (Foken et al. 2004)

  Case Is >= 0.4
    ITCu = -(Sigma_u/U_star)/9.1                          'Model unavailiable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
    ITCw = -(Sigma_w/U_star)/9.1                          'Model unavailiable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect

  ITCu = ABS((ITCu - (Sigma_u/U_star))/ITCu)            'In fraction
  ITCw = ABS((ITCw - (Sigma_w/U_star))/ITCw)            'In fraction

  If (NOT (Planar_Fit)) Then
    'If double rotation, the max of ITC_u and ITC_w is used as ITC_u_w.
    MaxSpa(ITC_u_w, 2, ITCu)                            'Max is used for momentum flux related to uw and vw
  Else
    'If planar fit, only ITC_w is used as ITC_u_w.
    ITC_u_w = ITCw
  EndIf

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_u_w < 0.30)
  ITC_category(2) = (ITC_u_w < 0.30)
  ITC_category(3) = ((ITC_u_w >= 0.30) AND (ITC_u_w < 0.75))
  ITC_category(4) = (ITC_u_w < 0.30)
  ITC_category(5) = ((ITC_u_w >= 0.30) AND (ITC_u_w < 1.00))
  ITC_category(6) = ((ITC_u_w >= 0.75) AND (ITC_u_w < 1.00))
  ITC_category(7) = ((ITC_u_w >= 1.00) AND (ITC_u_w < 2.50))
  ITC_category(8) = ((ITC_u_w >= 2.50) AND (ITC_u_w < 10.00))

  For J = 1 To 8
    ITC_Momentum_1st_Occur = -J *ITC_category(J)
    If (ITC_Momentum_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Momentum_1st_Occur = 0) OR (ITC_Momentum_1st_Occur =0)) Then        'Any in category 9 (0 used for 9 now)
    TAU_SSITC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Momentum_1st_Occur)
    TAU_SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_u_w = NaN)) AND (TAU_SSITC = 9)) Then  TAU_SSITC = NaN

EndSub

'c. Data quality grading for scalar flux using steady state test, integral turbulence characteristics, and horizontal wind orientation relative to the CSAT coordinate system 
'   Foken et al. (2012) 
   
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  Sigma_w               W_SIGMA
'  U_star                USTAR
'  Sigma_Ts              T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  wnd_dir               WD_SONIC
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov     Relative Non-Stationarity
'  QC                    Fc_QC, LE_QC, or H_QC                            Quality Classes 1 to 9.

Sub Data_Quality_SSITC_w_WndDir_Scalar (stability, Sigma_w, U_star, Sigma_Ts, T_star, lat, wnd_dir, RNS, QC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Chracteristics) for variance of T_SONIC. 
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC. 
  Dim ITC_ww                               'ITC for variance of vertical wind. 

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(3)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occurrence     'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occurrence     'The lowest possible grade of ITC in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(3) = Wnd_Scalar_1st_Occurrence     'The lowest possible grade of wind direction in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The upcase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
    
  'Reset
  QC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS < 0.15)
  RNS_category(2) = ((RNS >= 0.15) AND (RNS < 0.30))
  RNS_category(3) = (RNS < 0.30)
  RNS_category(4) = ((RNS >= 0.30) AND (RNS < 0.75))
  RNS_category(5) = (RNS < 0.75)
  RNS_category(6) = ((RNS >= 0.75) AND (RNS < 1.00))
  RNS_category(7) = ((RNS >= 1.00) AND (RNS < 2.50))
  RNS_category(8) = ((RNS >= 2.50) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occurrence = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Chracteristic
  Coriolis_parameter = 2*Omega*SIN(lat)                      'Omega: earth anglular velocity

  'Test on developed turbulence conditions for sensible heat flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 4.2 (Foken et al. 2012)

  Case Is > -0.032 AND Is <= 0
    ITC_ww = 1.3                                             'Table 4.2 (Foken et al. 2012)

  Case Is < 0.4 AND Is > 0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1  'Table 4.3 (Foken et al. 2012)

  Case Is >= 0.4
    ITC_ww = -(Sigma_w/U_star)/9.1                          'Model unavailiable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  ITC_ww = ABS((ITC_ww - (Sigma_w/U_star))/ITC_ww)          'In fraction

  Select Case stability
  Case Is < -1
    ITC_TsTs = ABS(stability)^(-1/3)                        'Table 4.2 (Foken et al. 2012)

  Case Is <= -0.062 AND Is >= -1
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 4.2 (Foken et al. 2012)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 4.2 (Foken et al. 2012)

  Case  Is >= 0.02 AND Is < 1
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 4.2 (Foken et al. 2012)

  Case Is >=1
    ITC_TsTs = -(Sigma_Ts/ABS(T_star))/9.1                  'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - Sigma_Ts/ABS(T_star))/ITC_TsTs)   'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.30)
  ITC_category(2) = (ITC_wTs < 0.30)
  ITC_category(3) = ((ITC_wTs >= 0.30) AND (ITC_wTs < 0.75))
  ITC_category(4) = (ITC_wTs < 0.30)
  ITC_category(5) = ((ITC_wTs >= 0.30) AND (ITC_wTs < 1.00))
  ITC_category(6) = ((ITC_wTs >= 0.75) AND (ITC_wTs < 1.00))
  ITC_category(7) = ((ITC_wTs >= 1.00) AND (ITC_wTs < 2.50))
  ITC_category(8) = ((ITC_wTs >= 2.50) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occurrence = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occurrence = J) Then
      ExitFor
    EndIf
  Next J

  '3. Wind direction
  'The lowest possible grade of wind direction in the overall grade system
  If ((wnd_dir <= 151) OR (wnd_dir >= 209)) Then
    Wnd_Scalar_1st_Occurrence = 1
  ElseIf (((wnd_dir > 151) AND (wnd_dir <= 170)) OR ((wnd_dir >= 190) AND (wnd_dir < 209)))
    Wnd_Scalar_1st_Occurrence = 7
  ElseIf ((wnd_dir > 170) AND (wnd_dir < 190))
    Wnd_Scalar_1st_Occurrence = 0
  EndIf

  '1st case
  If  (RNS_Scalar_1st_Occurrence = 0) OR (ITC_Scalar_1st_Occurrence =0) OR (Wnd_Scalar_1st_Occurrence = 0) Then        'Any in category 9 (0 used for 9, here)
    QC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 3, RNS_Scalar_1st_Occurrence)
    QC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN) OR (wnd_dir = NaN)) AND (QC = 9)) Then  QC = NaN
EndSub


'd. Data quality grading for scalar flux using steady state test and integral turbulence characteristics. 
'   Foken et al. (2004) 
   
'         Variable Notation
'  SUBROUTINE            MAIN PROGRAM
'  stability             ZL
'  Sigma_w               W_SIGMA
'  U_star                USTAR
'  Sigma_Ts              T_SONIC_SIGMA
'  T_star                TSTAR
'  lat                   latitude
'  RNS                   RN_WT_SONIC_cov, RN_WCO2_Cov, or RN_WH2O_Cov     Relative Non-Stationarity
'  SSITC                 Fc_SSITC, LE_SSITC, or H_SSITC                   Quality Classes 1 to 9.

Sub Data_Quality_SSITC_wo_WndDir_Scalar (stability, Sigma_w, U_star, Sigma_Ts, T_star, lat, RNS, SSITC)
  ' Test on developed turbulence conditions
  Dim ITC_TsTs                             'ITC (Integral Turbulence Chracteristics) for variance of T_SONIC. 
  Dim ITC_wTs                              'ITC for variance of vertical wind speed with T_SONIC. 
  Dim ITC_ww                               'ITC for variance of vertical wind. 

  Dim Coriolis_parameter

  Dim RNS_category(8) As Boolean           'Categorize the Relative Non-Stationarity into possible grade categories in the overall grade system
  Dim ITC_category(8) As Boolean           'Categorize the ITC into possible grade categories in the overall grade system

  Dim   Lowest_Seq_1st_Occurrence(2)
  Alias Lowest_Seq_1st_Occurrence(1) = RNS_Scalar_1st_Occur          'The lowest possible grade of Relative Non-Stationarity in the overall grade system
  Alias Lowest_Seq_1st_Occurrence(2) = ITC_Scalar_1st_Occur          'The lowest possible grade of ITC in the overall grade system

  Dim Lowest_Seq_Max(2)                                              'For use of instruction MaxSpa. Hold the max in "Lowest_Seq_1st_Occurrence()"

  Dim J As Long                                                      'Used for index of iteration. The upcase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.
    
  'Reset
  SSITC = 0

  '1. Relative Non-Stationarity
  'Possible Grade for relative non-stationarity (Steady state test)
  RNS_category(1) = (RNS < 0.15)
  RNS_category(2) = ((RNS >= 0.15) AND (RNS < 0.30))
  RNS_category(3) = (RNS < 0.30)
  RNS_category(4) = ((RNS >= 0.30) AND (RNS < 0.75))
  RNS_category(5) = (RNS < 0.75)
  RNS_category(6) = ((RNS >= 0.75) AND (RNS < 1.00))
  RNS_category(7) = ((RNS >= 1.00) AND (RNS < 2.50))
  RNS_category(8) = ((RNS >= 2.50) AND (RNS  < 10.0))

  For J = 1 To 8
    RNS_Scalar_1st_Occur = -J *RNS_category(J)
    If (RNS_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '2. Integral Turbulence Chracteristic
  Coriolis_parameter = 2*Omega*SIN(lat)                      'Omega: earth anglular velocity

  'Test on developed turbulence conditions for sensible heat flux using the integral turbulence characteristic
  Select Case stability
  Case Is <= -0.032
    ITC_ww = 2.00*ABS(stability)^0.125                       'Table 9.1 (Foken et al. 2004)

  Case Is > -0.032 AND Is <= 0
    ITC_ww = 1.3                                             'Table 9.1 (Foken et al. 2004)

  Case Is < 0.4 AND Is > 0
    ITC_ww = 0.21*LN(ABS(Coriolis_parameter)/U_star) + 3.1   'Table 9.1 (Foken et al. 2004)

  Case Is >= 0.4
    ITC_ww = -(Sigma_w/U_star)/9.1                          'Model unavailiable in this stability range. Assume relative ITC to be 10.1 for grade 9 due to a very stable condition
  EndSelect
  ITC_ww = ABS((ITC_ww - (Sigma_w/U_star))/ITC_ww)          'In fraction

  Select Case stability
  Case Is < -1
    ITC_TsTs = ABS(stability)^(-1/3)                        'Table 9.1 (Foken et al. 2004)

  Case Is <= -0.062 AND Is >= -1
    ITC_TsTs = ABS(stability)^(-0.25)                       'Table 9.1 (Foken et al. 2004)

  Case Is < 0.02 AND Is > -0.062
    ITC_TsTs = 0.5*ABS(stability)^(-0.50)                   'Table 9.1 (Foken et al. 2004)

  Case  Is >= 0.02 AND Is < 1
    ITC_TsTs = 1.4*stability^(-0.25)                        'Table 9.1 (Foken et al. 2004)

  Case Is >=1
    ITC_TsTs = -(Sigma_Ts/ABS(T_star))/9.1                  'Classify it into grade 9 when ZL >= 1
  EndSelect

  ITC_TsTs = ABS((ITC_TsTs - Sigma_Ts/ABS(T_star))/ITC_TsTs)   'in fraction

  ITC_wTs = IIF ( (ITC_TsTs > ITC_ww), ITC_TsTs, ITC_ww)

  'Possible grade for the Integral Turbulence Characteristics
  ITC_category(1) = (ITC_wTs < 0.30)
  ITC_category(2) = (ITC_wTs < 0.30)
  ITC_category(3) = ((ITC_wTs >= 0.30) AND (ITC_wTs < 0.75))
  ITC_category(4) = (ITC_wTs < 0.30)
  ITC_category(5) = ((ITC_wTs >= 0.30) AND (ITC_wTs < 1.00))
  ITC_category(6) = ((ITC_wTs >= 0.75) AND (ITC_wTs < 1.00))
  ITC_category(7) = ((ITC_wTs >= 1.00) AND (ITC_wTs < 2.50))
  ITC_category(8) = ((ITC_wTs >= 2.50) AND (ITC_wTs < 10.00))

  For J = 1 To 8
    ITC_Scalar_1st_Occur = -J *ITC_category(J)
    If (ITC_Scalar_1st_Occur = J) Then
      ExitFor
    EndIf
  Next J

  '1st case
  If  ((RNS_Scalar_1st_Occur = 0) OR (ITC_Scalar_1st_Occur =0)) Then        'Any in category 9 (0 used for 9, here)
    SSITC = 9

  '2nd case
  Else
    MaxSpa (Lowest_Seq_Max(1), 2, RNS_Scalar_1st_Occur)
    SSITC = Lowest_Seq_Max(1)
  EndIf

  '3rd case
  If (((RNS = NaN) OR (ITC_wTs = NaN)) AND (SSITC = 9)) Then  SSITC = NaN
EndSub
'*** End of subroutines for data quality classification ***

'*** Beginning of subroutines for footprint characteristics ***
  
' 1. Footprint of Kljun et al. (2004): Footprint characteristics
 
'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  U_star                 USTAR
'  Sigma_w                W_SIGMA
'  height_aerodynamic     z
'  Obukhov                MO_LENGTH
'  roughness              z0
'  upwnd_dist             upwnd_dist_intrst             Upwind range of interest (measurement targeted range)
'  FP_win_range           FTPRNT_DIST_INTRST            Percentage of measured scalar flux from upwind range of interest
'  x_max                  FETCH_MAX                     Upwind location of source/sink that contributes most to the measured flux
'  FP_90pct_range         FETCH_90                      Upwind range within which the source/sink contributes 90% to the measured flux
'  FP_55pct_range         FETCH_55                      Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_40pct_range         FETCH_40                      Upwind range within which the source/sink contributes 40% to the measured flux

Sub FootprintCharacteristics_Kljun(U_star, Sigma_w, height_aerodynamic, Obukhov, roughness, upwnd_dist, FP_win_range, x_max, FP_90pct_range, FP_55pct_range,FP_40pct_range)
  '*** Variables used inside subroutine
  'Model parameters
  Dim k1, k2, k3, k4           'Parameters in the model of Kljun et al (2004)
  Dim h_PBL                    'Planetary Boudary-Layer height

  'Composit variables repeatedly used in iterational computation
  Dim zh_ratio                 'Ratio of aerodynamic height to planetary boundary-layer height (height_aerodynamic/h_PBL)
  Dim suz                      'For repeately used variable of ((Sigma_w/U_star)^0.8)/height_aerodynamic
  Dim k1_suz_zh                'For repeately used variable of k1*[((Sigma_w/U_star)^0.8)*(1-height_aerodynamic/h_PBL)/height_aerodynamic]

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e. x_inflection_L  < x_max) where x is the upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e. x_inflection_R > x_max) where x is the upwind distance to measurement station
  Dim x_L                      'x at the left boundary of an integration interval where x is the upwind distance to measurement station
  Dim x_R                      'x at the right boundary of an integration interval where x is the upwind distance to measurement station
  Dim Integration_interval     'Interval for numerical integration (i.e. x_R - x_L)

  'Variables for use of Boole's Rule for numerical integration
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim Interval_count           'Used to calculate the number of intervals needed for numerical integration after FP_90pct_range was calculated, but before upwnd_dist is reached
  Dim J As Long                'Used for index of iteration. The upcase J is used to keep the editor's auto-correct feature
  'from changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

  'Calculate paramerters in Kljun et al (2004)].
  k1 = 0.175/(3.418 - LN(roughness))     'pgs. 515 & 516, left top panel in Fig. 7 and eq. (13). Email from Dr. Kljun on Feb 10, 2015
  k2 = 3.68254                           'pgs. 515 & 516, right top panel in Fig. 7 and eq.(14). Calculated from eq.(10) using k1 and k3
  k3 = 4.277*(3.418 - LN(roughness))     'pgs. 515 & 516, left bottom panel in Fig. 7 and eq.(15). Email from Dr. Kljun on Feb 10, 2015
  k4 = 1.685*(3.418 - LN(roughness))     'pgs. 515 & 516, right bottom panel in Fig. 7 and eq.(16). Email from Dr. Kljun on Feb 10, 2015

  If ((U_star <> NaN) AND (Sigma_w <> NaN) AND (Obukhov <> NaN)) Then 
  'Estimate planetary boudary-layer (PBL) height using data in the MO_LENGTH and h colums in Table I in Kljun et al (2004)
  Select Case Obukhov
  Case Is <= 0
    'h_PBL = 1000 m when Obukhov is -infinity. h_PBL = 1200 m at Obukhov = -650. Assume when Obukhov is <-650, h_PBL will decreases at the same rate
    'as h_PBL decreases when -650 < Obukhov <-30. Thus h_PBL reaches the limit of 1000 m at Obukhov = -1013.3; therefore, h_PBL = 1000 m if Obukhov <= -1013.3.
    If (Obukhov < -1013.3) Then
      h_PBL = 1000                                        'Set h_PBL = 1000 m as long as Obukhov < -1013.3 m.
    ElseIf (Obukhov <= -650) Then
      h_PBL = 1200 - 200*((Obukhov + 650)/(-1013.3+650))
    ElseIf (Obukhov <= -30) Then
      h_PBL = 1500 - 300*((Obukhov + 30)/(-650+30))
    ElseIf (Obukhov <= -5) Then
      h_PBL = 2000 - 500*((Obukhov + 5)/(-30+5))
    ElseIf (Obukhov <= 0) Then
      h_PBL = 2000 + 20* (Obukhov + 5)                    'Extrapolation to Obukhov --> -0.
    EndIf

  Case Is > 0
    'h_PBL = 1000 m when Obukhov is +infinity, and h_PBL = 800 m at Obukhov = 1000. Assume that h_PBL becomes higher with Obukhov at the same rate
    'as in the Obukhov range of 130 to 1000. Thus h_PBL reaches the limit of 1000 m at Obukhov = 1316.4; therefore, h_PBL = 1000 m if Obukhov > 1316.4
    If (Obukhov > 1316.4) Then
      h_PBL = 1000                                        'Set h_PBL = 1000 m as long as Obukhov > 1316.4 m.
    ElseIf (Obukhov >= 1000) Then
      h_PBL = 800 + 200*((Obukhov - 1000)/(1316.4-1000))
    ElseIf (Obukhov >= 130) Then
      h_PBL = 250 + 550*((Obukhov -130)/(1000 - 130))
    ElseIf (Obukhov >= 84) Then
      h_PBL = 200 + 50*((Obukhov - 84)/(130 -84))
    ElseIf (Obukhov > 0) Then
      h_PBL = 200 - (84 - Obukhov)*(50/46)               'Extrapolation to Obukhov --> +0
    EndIf
  EndSelect

  'Calculate variables repeatedly used inside iteration loops
  zh_ratio  = height_aerodynamic/h_PBL
  suz       = ((Sigma_w/U_star)^0.8)/height_aerodynamic
  k1_suz_zh = k1*suz*(1-zh_ratio)

  'Upwind location of source/sink that contributes most to the measured flux
  x_max = (k3 - k4)/suz
  x_inflection_L = x_max*(k3*((SQR(k2) - 1)/SQR(k2))-k4)/(k3-k4)     'x at the left inflection point of footprint (i.e. < x_max)
  x_inflection_R = x_max*(k3*((SQR(k2) + 1)/SQR(k2))-k4)/(k3-k4)     'x at the right inflection point of footprint (i.e. > x_max)

  'reset variables
  FP_cumulative  = 0
  FP_win_range   = 0
  FP_90pct_range = 0
  FP_55pct_range = 0
  FP_40pct_range = 0

  '***Calculate footprint characteristics: FP_win_range, FP_90pct_range, FP_55pct_range, and FP_40pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting point of footprint defined (-k4/suz) to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footptint inflection point (x_inflection_R) then further to 
  '      [x_inflection_R + (x_inflection_R - x_max)] or unitil cumulative footprint reaches 90% whichever is reached first. 
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at culumutive footprint > 90% and then until the distance of interest is reached
  '      but limited x_max + 200*height_aerodynamic (x_200z).
  ' 5th: If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's Rule

    '1st numerical integration segment: Upwind range until x reaches left inflection point

    '*** Starting calculations 
    ' Preparation for use of x_L and x_R inside an iteration
    x_R  = - k4/suz                                                        'Initialization. This value will be used for the starting point of integration
    Integration_interval = (x_inflection_L - x_R)/NMBR_INT_INTERV_SEGMENT  'Use x at the left inflection point as a ending boundary of the 1st numerical integration segment
    FP_R = 0                                                               'Pre-calculation

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                                              'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maxmum footprint
    Integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   'For numerical integration, use x at the left inflection point as the starting boundary and x_max as the ending boundary

    'Upwind range within x_max
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = (suz*x_R + k4)/k3                                             'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and then further
    'to [x_inflection_R + (x_inflection_R -x_max)] or until 90% of footprint is found
    Integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT  'For numerical integration, use x_max as the starting boundary and x at the right inflection point as the middle boundary

    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT                                    'Using the fine resolution for integration even beyong x_inflection_R to to [x_inflection_R + (x_inflection_R -x_max)]
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                                'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If (FP_cumulative >= 0.9) AND (FP_90pct_range = 0) Then
        FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        Exit For
      EndIf
    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or culumutive footprint > 90%
    'Use lower integration resolution, but more accurate numerical integration method of Boole's Rule
    Integration_interval = 4*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue to calculate
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 200*height_aerodynamic))
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's Rule for numerical integration ***
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      FP_M1 = (suz*(x_L + 0.25*Integration_interval) + k4)/k3             'Pre-calculation
      FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1 - FP_M1))

      FP_M2 = (suz*(x_L + 0.50*Integration_interval) + k4)/k3             'Pre-calculation
      FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1 - FP_M2))

      FP_M3 = (suz*(x_L + 0.75*Integration_interval) + k4)/k3             'Pre-calculation
      FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1 - FP_M3))

      'Footprint value at the right boundary of an integration interval
      FP_R = (suz*x_R + k4)/k3                                            'Pre-calculation
      FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

      'Boole's Rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2+ 32*FP_M3+ 7*FP_R)/90

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0)) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

     'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0)) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend

    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf 
    
    'Assign FP_90pct_range as NaN if culmulative footprint can not reach 0.9 within x_max + 200*height_aerodynamic
    If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = NaN
    EndIf

    '5th numerical integration segment.
    'If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
    'or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic. 
    
    If (x_R < upwnd_dist) Then

      ' Control the integration w/in 25 iterations after above integrations
      If ((upwnd_dist - x_R) < (100*height_aerodynamic)) Then

        Interval_count       = INT((upwnd_dist - x_R)/Integration_interval)
        Integration_interval = (upwnd_dist - x_R)/Interval_count           'Rescale the intergration interval

        For J = 1 To Interval_count                                        'To Upwnd_dist, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + Integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's Rule for numerical integration *****
          'Footprint value in the left boundary of integration interval
          FP_L = FP_R

          FP_M1 = (suz*(x_L + 0.25*Integration_interval) + k4)/k3          'Pre-calculation
          FP_M1 = k1_suz_zh*(FP_M1^k2)*EXP(k2*(1 - FP_M1))

          FP_M2 = (suz*(x_L + 0.50*Integration_interval) + k4)/k3          'Pre-calculation
          FP_M2 = k1_suz_zh*(FP_M2^k2)*EXP(k2*(1 - FP_M2))

          FP_M3 = (suz*(x_L + 0.75*Integration_interval) + k4)/k3          'Pre-calculation
          FP_M3 = k1_suz_zh*(FP_M3^k2)*EXP(k2*(1 - FP_M3))

          'Footprint value in the right boundary of integration interval
          FP_R = (suz*x_R + k4)/k3                                         'Pre-calculation
          FP_R = k1_suz_zh*(FP_R^k2)*EXP(k2*(1 - FP_R))

          'Boole's Rule used for an individual interval to cumulate the footprint
          FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2+ 32*FP_M3+ 7*FP_R)/90

          'Try to find the 90% footprint distance again
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = NaN)) Then
            FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf
        Next J

        Select Case FP_cumulative
        Case Is < 1.00
          FP_win_range = 100*FP_cumulative
        Case Is >=1
          FP_win_range = 99
        EndSelect

      Else
        FP_win_range = 99
      EndIf

    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_90pct_range = NaN
    FP_55pct_range = NaN
    FP_40pct_range = NaN
  EndIf
EndSub

' 2. Footprint of Kormann and Meixner (2001)

'         Variable Notation
'  SUBROUTINE             MAIN PROGRAM
'  U_star                 USTAR
'  height_aerodynamic     z
'  Stability              ZL
'  U_total                WS_rslt
'  upwnd_dist             upwnd_dist_intrst            Upwind range of interest (measurement target)
'  FP_win_range           FTPRNT_DIST_INTRST           Percentage of measured scalar flux from upwind range of interest
'  x_max                  FETCH_MAX                    Upwind location of source/sink that contributes most to the measured flux
'  FP_90pct_range         FETCH_90                     Upwind range within which the source/sink contributes 90% to the measured flux
'  FP_55pct_range         FETCH_55                     Upwind range within which the source/sink contributes 55% to the measured flux
'  FP_40pct_range         FETCH_40                     Upwind range within which the source/sink contributes 40% to the measured flux

Sub FootprintCharacteristics_KormannMeixner (U_star, height_aerodynamic, stability, U_total, upwnd_dist, FP_win_range, x_max, FP_90pct_range, FP_55pct_range, FP_40pct_range)
  'Parameters in the vertical profiles of horizontal wind and eddy diffusivity
  Dim m_KM                     'Exponent of vertical profile of horizontal wind in footprint of Kormann and Meixner (2001)
  Dim n_KM                     'Exponent of vertical profile of eddy diffusivity in footprint of Kormann and Meixner (2001)
  Dim wnd_const                'Wind constant in the vertical profile of horizontal wind

  'Composite variables
  Dim r_KM                     'Shape factor (r_KM =2 + m_KM - n_KM) in footprint of Kormann and Meixner (2001)
  Dim Xi                       'wnd_const/(k*r_KM^2) where k is von Kerman constant (0.41)
  Dim Mu                       '(m_KM + 1)/r_KM
  Dim Gamma_Mu                 'Gamma function of Mu
  Dim xgz                      '((Xi^Mu)*(height_aerodynamic^(m_KM +1)))/Gamma_Mu
  Dim xz                       'Xi*height_aerodynamic^r_KM

  'Working variables
  Dim FP_cumulative            'Cumulative_footprint
  Dim FP_cumulative_prev       'Cumulative_footprint in a previous iteration
  Dim x_inflection_L           'x at the left inflection point of footprint (i.e. x_inflection_L < x_max) where x is upwind distance to measurement station
  Dim x_inflection_R           'x at the right inflection point of footprint (i.e. x_inflection_R > x_max) where x is upwind distance to measurement station
  Dim x_L                      'x at the left boundary of integration interval where x is upwind distance to measurement station
  Dim x_R                      'x at the right boundary of integration interval where x is upwind distance to measurement station
  Dim Integration_interval     'Interval for numerical integration (i.e. x_R - x_L)

  'Variables for use of Boole's rule
  Dim FP_L                     'footprint at x = x_L
  Dim FP_M1                    'footprint at x = x_L + 0.25*(x_R - x_L)
  Dim FP_M2                    'footprint at x = x_L + 0.50*(x_R - x_L)
  Dim FP_M3                    'footprint at x = x_L + 0.75*(x_R - x_L)
  Dim FP_R                     'footprint at x = x_R

  Dim Interval_count           'Used to calculate interval number after FP_90pct_range calculated, but before Upwnd_dist is reached
  Dim J As Long                'Used for index of iteration. The upcase J is used to keep the editor's auto-correct feature
  'From changing the case of J in units as lowcase (e.g. J/s m^2) throughout the program.

   If ((U_star <> NaN) AND (stability <> NaN) AND (U_total <> NaN)) Then
     
  'Calculate the exponent of vertical profile of horizontal wind and the exponent of vertical profile of eddy diffusivity
  If (stability > 0) Then
    'Similarity functions are defined in a range of ZL from -2 to 2 (pages 28, 41~43, Kaimal & Finnigan 1994). Extened to +/-4 as shown in Fig 5.23 in Stull (1988)
   Select Case Stability 
     Case Is <= 4.0    
       m_KM = (U_star/(k*U_total))*(1 + 5*stability)         'Exponent of vertical profile of horizontal wind
       n_KM = 1/(1 + 5*stability)                            'Exponent of vertical profile of eddy diffusivity
     
     Case Is > 4
       m_KM = (U_star/(k*U_total))*(1 + 5*4)                 'Exponent of vertical profile of horizontal wind
       n_KM = 1/(1 + 5*4)                                    'Exponent of vertical profile of eddy diffusivity
   EndSelect
  Else
    Select Case stability
     Case Is >= -4.0  
       m_KM = (U_star/(k*U_total))/((1 - 16*stability)^0.25) 'Exponent of vertical profile of horizontal wind
       n_KM = (1-24*stability)/(1 - 16*stability)            'Exponent of vertical profile of eddy diffusivity
   
     Case Is < -4.0
       m_KM = (U_star/(k*U_total))/((1 - 16*(-4))^0.25)      'Exponent of vertical profile of horizontal wind
       n_KM = (1-24*(-4))/(1 - 16*(-4))                      'Exponent of vertical profile of eddy diffusivity
    EndSelect
  EndIf

  'Calculate the wind constant in the vertical profile of horizontal wind
  wnd_const = U_total/(height_aerodynamic^m_KM)             'Wind constant

  'Calculate the composite variables
  r_KM = 2 + m_KM - n_KM                                    'Shape factor

  Xi = wnd_const/(k*r_KM*r_KM)
  Mu = (m_KM + 1)/r_KM

  Gamma_Mu = SQR(2*PI/Mu)*(((Mu + 1/(12*Mu - 0.1/Mu))/EXP(1))^Mu)        'Gamma fuction of Mu [see Nemes (2007)]

  xgz = ((Xi^Mu)*(height_aerodynamic^(m_KM +1)))/Gamma_Mu
  xz  = Xi*(height_aerodynamic^r_KM)

  'Turnning and inflection points
  x_max          = xz/(Mu + 1)                                            'Upwind location of source/sink that contributes most to the measured flux
  x_inflection_L = x_max*(1 - 1/SQR(Mu + 2))                              'x at the left footprint inflection point
  x_inflection_R = x_max*(1 + 1/SQR(Mu + 2))                              'x at the right footprint inflection point

  'Reset variables
  FP_cumulative  = 0
  FP_win_range   = 0
  FP_90pct_range = 0
  FP_55pct_range = 0
  FP_40pct_range = 0

  '***Calculate footprint characteristics: FP_win_range, FP_90pct_range, FP_55pct_range, and FP_40pct_range
  ' Use five numerical integration segments to calculate the footprint characteristics
  ' 1st: starting segment from 0 (+ Delt-->0)  to the left footprint inflection point (x_inflection_L)
  ' 2nd: the left footprint inflection point to the footprint maximum (x_max)
  ' 3rd: the footprint maximum to the right footptint inflection point (x_inflection_R) then further to 
  '      [x_inflection_R + (x_inflection_R - x_max)] or unitil cumulative footprint reaches 90% whichever is reached first. 
  ' 4th: from x > [x_inflection_R + (x_inflection_R - x_max)] or x at culumutive footprint > 90% and then until the distance of interest is reached, 
  '      but limited x_max + 200*height_aerodynamic (x_200z).
  ' 5th: If upwind range of interest has not been reached, this segment is integrated from x at FP_90 = 90% (x_90)
  '      or x_max + 200*height_aerodynamic (x_200z) to upwind distance of interest, but limited to x_90 (or x_200z) + 100*height_aerodynamic.  

  ' Use a high resolution of integration intervals for the first three segments 
  '     a lower resolution for the 4th and 5th segments, but high precision numerical method of Boole's rule

   '1st numerical integration segment: Upwind range within the left inflection point
   'In numerical integration, use x at the left footprint inflection point as the ending boundary of this segment
    Integration_interval = x_inflection_L/NMBR_INT_INTERV_SEGMENT  
    x_R  = 0                                                        'Reset
    FP_R = 0                                                        'Reset
    
    'Upwind range within the left inflection point
    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '2nd numerical integration segment: Upwind range from the left footprint inflection point to the maximum footprint
    'In this segment, use x at the left inflection point as the starting boundary and x_max as the ending boundary
    Integration_interval = (x_max - x_inflection_L)/NMBR_INT_INTERV_SEGMENT   

    For J = 1 To NMBR_INT_INTERV_SEGMENT
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integral interval
      FP_L = FP_R

      'Footprint value at the right boundary of integral interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Next J

    '3rd numerical integration segment: Upwind range from the maximum footprint to the right footprint inflection point and further to
    ' [x_inflection_R + (x_inflection_R -x_max)] or to 90% footprint whichever is first reached.
    'In this segment, use x_max as the starting boundary and x at the right inflection point as the boundary of middle interval
    Integration_interval = (x_inflection_R - x_max)/NMBR_INT_INTERV_SEGMENT   

    'Upwind range within two times of range from x_max to the right inflection point
    'The fine resolution of integration is used even beyong x_inflection_R to [x_inflection_R + (x_inflection_R -x_max)] or until 90% footprint is reached
    For J = 1 To 2*NMBR_INT_INTERV_SEGMENT   
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      'Footprint value at the left boundary of integration interval
      FP_L = FP_R

      'Footprint value at the right boundary of integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The trapezoidal rule used for an individual interval to cumulate footprint
      FP_cumulative += Integration_interval*(FP_L + FP_R)/2

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If (FP_cumulative >= 0.4) AND (FP_40pct_range = 0) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If (FP_cumulative >= 0.55) AND (FP_55pct_range = 0) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 90% footprint distance
      If (FP_cumulative >= 0.9) AND (FP_90pct_range = 0) Then
        FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
        Exit For
      EndIf

    Next J

    '4th numerical integration segment: x > [x_inflection_R + (x_inflection_R - x_max)] or culumutive footprint > 90%
    'Use lower intergration resolution, but the more accurate numerical integration method of Boole's rule
    Integration_interval = 4*height_aerodynamic

    'If upwind range of 90% footprint is not reached. Continue, but limited to x_max + 200*height_aerodynamic
    While ((FP_cumulative < 0.9) AND (x_R - x_max < 200*height_aerodynamic))
      x_L = x_R
      x_R = x_R + Integration_interval
      FP_cumulative_prev = FP_cumulative

      '*** Boole's rule *****
      'Footprint value at the left boundary of an integration interval
      FP_L = FP_R

      'Footprint value at the 1st, 2nd, and 3rd quarter integration interval
      FP_M1 = xgz*EXP(-xz/(x_L + 0.25*Integration_interval))/((x_L + 0.25*Integration_interval)^(Mu + 1))
      FP_M2 = xgz*EXP(-xz/(x_L + 0.50*Integration_interval))/((x_L + 0.50*Integration_interval)^(Mu + 1))
      FP_M3 = xgz*EXP(-xz/(x_L + 0.75*Integration_interval))/((x_L + 0.75*Integration_interval)^(Mu + 1))

      'Footprint value at the right boundary of an integration interval
      FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

      'The Boole's rule used for an individual interval to cumulate the footprint
      FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2 + 32*FP_M3 +7*FP_R)/90

      'Find the footprint w/in the range of interest
      If ((x_L < upwnd_dist) AND (x_R >= upwnd_dist)) Then
        FP_win_range = 100*(FP_cumulative_prev + (FP_cumulative - FP_cumulative_prev)*(upwnd_dist - x_L)/Integration_interval)
      EndIf

      'Find the 40% footprint distance
      If ((FP_cumulative >= 0.4) AND (FP_40pct_range = 0)) Then
        FP_40pct_range = x_R - Integration_interval*(FP_cumulative - 0.4)/(FP_cumulative - FP_cumulative_prev)
      EndIf

      'Find the 55% footprint distance
      If ((FP_cumulative >= 0.55) AND (FP_55pct_range = 0)) Then
        FP_55pct_range = x_R - Integration_interval*(FP_cumulative - 0.55)/(FP_cumulative - FP_cumulative_prev)
      EndIf

    Wend

    'Find the 90% footprint distance
    If ((FP_cumulative >= 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
    EndIf

    ' Assign FP_90pct_range as NaN if culmulative footprint can not reach 0.9 within x_max + 200*height_aerodynamic
    If ((FP_cumulative < 0.90) AND (FP_90pct_range = 0)) Then
      FP_90pct_range = NaN
    EndIf

    ' 5th numerical integration segment:
    ' If upwind range of interest has not been reached, this segment is integrated
    ' from x at FP_90 = 90% (x_90) or x_max + 200*height_aerodynamic (x_200z)(if FP_90 is not reached) to upwind distance of interest, 
    ' but limited to x_90 (or x_200z) + 100*height_aerodynamic. 
    
    If (x_R < upwnd_dist) Then

      'Control the integration w/in 25 iterations after above integrations
      If ((upwnd_dist - x_R) < (100*height_aerodynamic)) Then

        Interval_count       = INT((upwnd_dist - x_R)/Integration_interval)
        Integration_interval = (upwnd_dist - x_R)/Interval_count               'Rescale integration interval

        For J = 1 To  Interval_count                                           '100*height_aerodynamic after above integration, the cumulative footprint is enough
          x_L = x_R
          x_R = x_R + Integration_interval
          FP_cumulative_prev = FP_cumulative

          '*** Boole's rule *****
          'Footprint value at the left boundary of integration interval
          FP_L = FP_R

          'Footprint value at the right boudary of the 1st, 2nd, and 3rd quarter integration interval
          FP_M1 = xgz*EXP(-xz/(x_L + 0.25*Integration_interval))/((x_L + 0.25*Integration_interval)^(Mu + 1))
          FP_M2 = xgz*EXP(-xz/(x_L + 0.50*Integration_interval))/((x_L + 0.50*Integration_interval)^(Mu + 1))
          FP_M3 = xgz*EXP(-xz/(x_L + 0.75*Integration_interval))/((x_L + 0.75*Integration_interval)^(Mu + 1))

          'Footprint value at the right boundary of integration interval
          FP_R = xgz*EXP(-xz/x_R)/(x_R^(Mu + 1))

          FP_cumulative += Integration_interval*(7*FP_L + 32*FP_M1 + 12*FP_M2 + 32*FP_M3 +7*FP_R)/90
          
          'Try FP_90pct_range again in case that FP_90pct_range is not resolved
          If ((FP_cumulative >= 0.9) AND (FP_90pct_range = NaN)) Then
            FP_90pct_range = x_R - Integration_interval*(FP_cumulative - 0.9)/(FP_cumulative - FP_cumulative_prev)
          EndIf

        Next J

        Select Case FP_cumulative
        Case Is < 1.00
          FP_win_range = 100*FP_cumulative
        Case Is >=1
          FP_win_range = 99
        EndSelect

      Else
        FP_win_range = 99
      EndIf

    EndIf

  Else
    x_max          = NaN
    FP_win_range   = NaN
    FP_90pct_range = NaN
    FP_55pct_range = NaN
    FP_40pct_range = NaN
  EndIf
EndSub
'*** End of subroutines for footprint characteristics ***

#If (SENSOR_FW) Then
'*** Beginning self-defined function for time constant of FW sensor ****
 
'         Variable Notation 
'  SUBROUTINE             MAIN PROGRAM
'  FW_D                   FW_diameter
'  FW_temperature         fw_avg
'  U_total                WS_rslt
'  density_moist_air      rho_a_avg

Sub Time_Const_Thermocouple_E(FW_D, FW_temperature, U_total, density_moist_air, Cp_air, time_const)
  Const C_TC_E   =  420.7734       'Specific heat of junction of thermocouple E [J/(kg deg C)]
  Const rho_TC_E =  8825           'Specific gravity (material density) of junction of thermocouple E [kg/m^3]

  Dim K_air                        'Thermal conductivity of air [W/(m deg C)]
  Dim mu_air                       'Viscosity of air [kg/(m s)]
  Dim Re                           'Reynold number (adimensional).
  Dim Nu                           'Nusselt Number (adimensional)
  Dim Pr                           'Prandtl number (adimensional)
  Dim h_tc                         'Convective heat transfer coefficient [W/(m^2 deg C)]

  K_air  = 2.42508e-2 + 7.038086e-5*FW_temperature     'Table 1 Montgomery (1947)
  mu_air = 1.716800e-5 + 4.982100e-8*FW_temperature    'Table 1 Montgomery (1947)

  Re = (density_moist_air*(0.5*FW_D)*U_total)/mu_air   'Reynold number
  Nu = 2.0 +0.181*Re^0.67                              'Nusselt Number     

  Pr = Cp_air*mu_air/K_air                             'Prandtl number 
  
  h_tc = (K_air*Nu)/(0.5*FW_D)                         'Convective heat transfer coefficient

  time_const = ((0.5*FW_D*rho_TC_E*C_TC_E)/h_tc)       'Time constant
EndSub
#EndIf

' Calculate separation of scalar sensor sensing center to CSAT measurement center
'    1. Separation distance normal to wind direction (effective separation distance)
'    2. Separation distance along with wind direction (effective lag distance)
 
'         Variable Notation  
'  SUBROUTINE             MAIN PROGRAM
'  wnd_dir                WD_SONIC
'  separation_x           separation_x_IRGA or separation_x_FW
'  separation_y           separation_y_IRGA or separation_y_FW
'  separation_lat_dis     separation_lat_dist_IRGA or separation_lat_dist_FW
'  separation_lag_dis     separation_lag_dist_IRGA or separation_lag_dist_FW

Sub Separation_Lag_Lateral_Distances (wnd_dir, separation_x, separation_y, separation_lat_dis, separation_lag_dis)
  separation_lag_dis =  separation_x*COS(wnd_dir) + separation_y*SIN(wnd_dir)
  separation_lat_dis = -separation_x*SIN(wnd_dir) + separation_y*COS(wnd_dir)
EndSub

'********************'
'*** MAIN PROGRAM ***'
'*********************'
BeginProg
  #If (SENSOR_HFP) Then

  'Load calibrations of soil heat flux plate.
  For i = 1 To NMBR_HFP
    Read shf_plate_cal(i)
  Next i

 #EndIf

  ' *** Beginning to store and read station variables in CPU ***
  SemaphoreGet (1)
  stn_conf_array_file = FileOpen ("CPU:stn_conf_array.dat", "rb", 0)                         'Open file and check if a file exists.
  stn_conf_array_file_size = FileSize (stn_conf_array_file)
  FileClose (stn_conf_array_file)                                                            'Close file after check
  SemaphoreRelease (1)

  If (stn_conf_array_file_size <> 4*NMBR_STN_VAR + 2) Then           'CPEC station configuration file does not exist.
    ' Set default values of station variables (Default values of 0 are listed for code readibilty)
    sonic_azimuth      = 0
    latitude           = 41.766           'Latitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_NS      = 1                '"1" for north and "-1" for south. Campbell Scientific Campus is located in Noth Hemisphere
    longitude          = 111.855          'Longitude of Campbell Scientific Campus, Logan, UT, USA
    hemisphere_EW      = -1               '"1" for east and "-1" for west. Campbell Scientific Campus is located in West Hemisphere
    height_measurement = 2.5
    displacement_user  = 0                '"0" indicates that the user DOES NOT have preferred zero displacement height
    height_canopy      = 0.5
    surface_type       = GRASS
    roughness_user     = 0                '"0" indicates that the user DOES NOT have preferred roughness length

    Select Case SENSOR_IRGASON
    Case TRUE
      separation_x_irga = 0              'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
      separation_y_irga = 0              'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
    Case FALSE
      separation_x_irga = 0.04066        'Range: 0.04066 ~0.09126 m:  Coordinate x of EC150 IRGA measurement center in the CSAT3A coordinate system
      separation_y_irga = 0.02905        'Range: 0.02905 ~0.03348 m:  Coordinate y of EC150 IRGA measurement center in the CSAT3A coordinate system
    EndSelect

    #If (SENSOR_FW) Then
    separation_x_FW = 0.35807-0.3520      'Coordinate x of fine wire thermocouple junction in the CSAT coordinate system (0.35200 is the default length of FW sensor) 
    separation_y_FW = 0.03526             'Coordinate y of fine wire thermocouple junction in the CSAT coordinate system
    FW_diameter     = FW05DIA             'Diameter of fine wire thermocouple
    #EndIf

    #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    soil_bulk_density = 1300              'Default soil bulk density (kg/m^3)
    Cds               =  870              'Default specific heat of dry mineral soil [J/(kg K)] [Table 8.2 on page 118 in Campbell & Norman (1998)]
    thick_abv_HFP    =    0.08           'Default depth of HFP01 or HFP01SC below soil surface (m)
    #EndIf

    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:sys_conf_var.dat", 0)         'Store the default values to the file.

  Else

    Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:sys_conf_var.dat", 1)         'Read the stored values from the file.

  EndIf
  
  'IF IRGASON, but previously CSAT3A+EC150, automatically reset
  If (SENSOR_IRGASON) Then
    separation_x_irga = 0              'Coordinate x of IRGASON IRGA measurement center in the CSAT coordinate system
    separation_y_irga = 0              'Coordinate y of IRGASON IRGA measurement center in the CSAT coordinate system
  EndIf
  
   '*** Beginning to calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***
  Call Displacement_Roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
  '*** End of calculate zero displacement height, roughness length, and aerodynamic height for use inside the scan ***

  For i = 13 To 16
      If  (NOT (stn_conf_array(i) > 0)) Then 
      stn_conf_array(i) = 100*z            'Default value of 100*z for all sectors in different directions
    EndIf 
  Next 

  z_prev = z
  Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)    'Keep current values of stn_conf_array() in stn_conf_array_prev() for later reference as previou values
  surface_type_text = surface_type_array(surface_type)
  ' *** End to store and read station variables in CPU ***

  ' *** Beginning to store and read planar fit angles in CPU ***
  SemaphoreGet (1)  
  planar_fit_angle_conf_array_file      = FileOpen ("CPU:planar_fit_angle_conf_array.dat", "rb", 0)  'Open the file and check if a file exists
  planar_fit_angle_conf_array_file_size = FileSize (planar_fit_angle_conf_array_file)                'Size of the planar fit angle configuration file stored on the CPU.
  FileClose (planar_fit_angle_conf_array_file)                                                       'Close file after check
  SemaphoreRelease (1)

  If (planar_fit_angle_conf_array_file_size <> (4*8 + 2)) Then
    Move (planar_fit_angle_conf_array(1,1), 8 , 0, 1)                                                'Default values of 0 are listed for code reading
    Calfile (planar_fit_angle_conf_array(1, 1), 8, "CPU:sys_planar_fit_angles.dat", 0)               'Store the default values to the file
  Else
    Calfile (planar_fit_angle_conf_array(1, 1), 8, "CPU:sys_planar_fit_angles.dat", 1)               'Read the values from the file
    For i =1 To 4
      If (planar_fit_angle_conf_array (i, 1) <> 0) OR (planar_fit_angle_conf_array (i, 2) <> 0) Then
        Planar_Fit_flg = TRUE
        ExitFor
      EndIf
    Next i
  EndIf

  Move (planar_fit_angle_conf_array_prev(1,1), 8, planar_fit_angle_conf_array(1,1), 8)                'Keep current values PF planar_fit_angle_conf_array() in planar_fit_angle_prev_array() for later reference as previou values
  ' *** End of storing and reading Planar Fit Angles in CPU ***

  #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
  ' Variables used to calculate the number of seconds from the beginning of the program to the end of the first averaging interval (time interval offset)
  RealTime(realtime_array(1))
  Offset_intv_Delta_ht_storage = ((3600*realtime_array(4) + 60*realtime_array(5) + realtime_array(6)) MOD (60*OUTPUT_INTERVAL))
  #EndIf
    
  'Set the SDM clock speed.
  SDMSpeed (SDM_PER)
  
  #If (PERIPHERAL_CDM_A116) Then
    ' Add CDM-A116 as a CPI module 
    CPIAddModule (CDM_MODEL, CDM_SN, CPI_DEVICE_DSCRPTN, CPI_ADDR_CDM)
  #EndIf   

  '*************************** SCAN LOOP  **************************************************
  Scan (SCAN_INTERVAL, mSec, SCAN_BUFFER_SIZE, 0)
    '*** Beginning of CSI IRGA + CSAT measurements ***
       
    #If (PERIPHERAL_CDM_A116) Then
    ' *** Beginning of CDM-A116 pannel temperature measurement ***
    CDM_PanelTemp (CDM_MODEL, CPI_ADDR_CDM, panel_tmpr_CDM_A116_1, NMBR_PANEL_TMPR_CDM, CDM_1ST_PANEL_TMPR_CHAN, FIRST_NOTCH_FREQ_MAIN_SCAN)
    '*** End of CDM-A116 pannel temperature measurement ***      
    #EndIf     
    #If (SENSOR_FW) Then

    '*** Beginning of FW measurements ***
    diag_FW_raw = 0
    CDM_TCDiff (CDM_MODEL, CPI_ADDR_CDM, FW_raw, 1, mV200, FW_ANALOG_INPUT, TypeE, panel_tmpr_CDM_A116_1, TRUE, 500, FIRST_NOTCH_FREQ_MAIN_SCAN, 1, 0)
    If (FW_raw = NaN) OR (FW_raw > 80) OR (FW_raw < -50) Then diag_FW_raw = -1
    '*** End of FW measurements ***
    #EndIf
    
    '*** Beginning of CSI IRGA + CSAT measurements ***
    'Get EC100 data
    EC100 (sonic_irga_raw(1), EC100_SDM_ADDR, 1)                          '1st to 5th elements: Sonic data and 6th to 12rd elements: IRGA, air temperature, and pressure data
    CallTable delay_3d                                                    'Sonic data: Ux, Uy, Uz, Ts, and diag_sonic 
    CallTable delay_cs                                                    'IRGA data: CO2, H2O, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, and H2O_sig_strgth
 
    #If (SENSOR_FW) Then
     CallTable delay_fw
    #EndIf
      
    If (sonic_irga_raw(8) = NAN) Then                                     'The EC150 diagnostic word (diag_irga) is sonic_irga_raw(8).
      NAN_cnt += 1
    Else
      If (NAN_cnt > 4) Then config_ec100_flg = TRUE
      NAN_cnt = 0
    EndIf

    If (sonic_irga_raw(8) <> NAN) Then

      If (config_ec100_flg) Then
        Call Config (ec100_setting_array(1,1), 10, get_ec100_config_flg)   'Get gas analyzer configuration on compile.
        CallTable ec100_config                                             'Record current EC100 configuration 

        Call Config (config_ec100_array(1, 1), 6, config_ec100_flg)        'Configure EC100 with default settings as user preferred.
        Call Config (ec100_setting_array(1,1), 10, get_ec100_config_flg)   'Get gas analyzer configuration again.
        CallTable ec100_config                                             'Record EC100 re-configuration 
      
        press_source   = ec100_setting_array(2, 2)
        heater         = ec100_setting_array(8, 2)
        IRGA_power_off = ec100_setting_array(9, 2)  
        shadow_corr    = ec100_setting_array(10, 2)     

      ElseIf (set_press_source_flg) Then
        press_source_array(1, 2) = press_source
        Call Config (press_source_array(1, 1), 1, set_press_source_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)   'Get gas analyzer configuration.
        CallTable ec100_config                                             'Record EC100 re-configuration 
        press_source = ec100_setting_array(2, 2)

      ElseIf (do_zero_flg) Then
        Call Config (zero_array(1,1), 1, do_zero_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)   'Get gas analyzer configuration.
        CallTable ec100_config                                              'Record EC100 re-configuration 
        
      ElseIf (do_CO2_span_flg) Then
        span_CO2_array(1, 2) = CO2_span_gas
        Call Config (span_CO2_array(1, 1), 2, do_CO2_span_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)   'Get gas analyzer configuration.
        CallTable ec100_config                                              'Record EC100 re-configuration 

      ElseIf (do_H2O_span_flg)
        span_H2O_array(1, 2) = Td_span_gas
        Call Config (span_H2O_array(1, 1), 2, do_H2O_span_flg)

        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)  'Get gas analyzer configuration.
        CallTable ec100_config                                             'Record EC100 re-configuration 
        
      ElseIf (set_heater_flg)  Then
        heater_option_array(1, 2) = heater 
        Call Config (heater_option_array(1, 1), 1, set_heater_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)   'Get gas analyzer configuration.
        CallTable ec100_config                                              'Record EC100 re-configuration 
        heater = ec100_setting_array(8, 2)        

      ElseIf (set_IRGA_power_flg) Then
        IRGA_power_array(1, 2) = IRGA_power_off
        Call Config (IRGA_power_array(1, 1), 1, set_IRGA_power_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)   'Get gas analyzer configuration.
        CallTable ec100_config                                              'Record EC100 re-configuration 
        IRGA_power_off = ec100_setting_array(9, 2)  
        
      ElseIf (set_shadow_corr_flg) Then
        shadow_corr_array(1, 2) = shadow_corr
        Call Config (shadow_corr_array(1, 1), 1, set_shadow_corr_flg)
        
        Call Config (ec100_setting_array(1, 1), 10, get_ec100_config_flg)   'Get gas analyzer configuration.
        CallTable ec100_config                                              'Record EC100 re-configuration 
        shadow_corr = ec100_setting_array(10, 2)  

      EndIf

    EndIf
    '*** End of CSI IRGA + CSAT measurements ***
      
    'This is placed here after all fast sensors finish their measurements because PulseCount() is not allowed in any conditional statements.
    #If (SENSOR_TE525mm) Then   
    '*** Beginning of Precipitation measurements ***
    PulseCount (P, 1, TE525_PULSE_INPUT, 1, 0, TE525_MULT, 0)
    '*** End of Precipitation measurements ***
    #EndIf
    
    If (scan_count >= (OFFSET + MAX_LAG)) Then

      '*** Beginning of CSAT sonic head processing ***
      'Load in CSAT sonic head data that has been lagged by EC100_REC_BCK scans
      GetRecord (dly_data_out(1),delay_3d, EC100_REC_BCK)

      Ts = dly_data_out(4)                               'sonic(1): Ts
      Move (Ux, 3, dly_data_out(1), 3)                   'sonic(2), sonic(3), sonic(4) : Ux, Uy, Uz
      diag_sonic = dly_data_out(5)                       'sonic(5): diag_sonic
      
      U_rslt = SQR(Ux*Ux + Uy*Uy + Uz*Uz)

      'Extract the six warning flags from the sonic diagnostic word
      diag_sonic_tmp = IIF ((diag_sonic <> NAN) AND (diag_sonic <> -1), diag_sonic, &h3f)
      mask = &h1
      For i = 1 To 6
        diag_bits_sonic(i) = diag_sonic_tmp AND mask
        mask = mask*2
      Next i

      'Turn on the intermediate processing disable flag when any CSAT sonic head warning flag is high.
      sonic_disable_f = (diag_sonic <> 0)

      Ts_K = Ts + T_0C_K

      ' Call Table for 5-minute and 30-minute table
      CallTable comp_cov_3d_5min                                                             'for Steady State Test
      CallTable comp_cov_3d                                                                  'for half-hourly data

      ' The data for Steady State Test (SST)
      If (comp_cov_3d_5min.Output(1, 1)) Then
        GetRecord (Ux_Avg_SST, comp_cov_3d_5min, 1)

        If (NOT (Planar_Fit_flg)) Then
          'Double coordinate rotations
          gamma_5min = WD_SONIC_SST                                                          'Rotation angle about z-axis
          alpha_5min = -ATN2(Uz_Avg_SST, SQR(Ux_Avg_SST*Ux_Avg_SST+Uy_Avg_SST*Uy_Avg_SST))   'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alpha_5min, gamma_5min, _
          Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST, _
          U_SST,      V_SST,      W_SST,      U_Var_SST,  V_Var_SST,  W_Var_SST,  UV_Cov_SST,   UW_Cov_SST,   VW_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          TsUx_Cov_SST,     TsUy_Cov_SST,     TsUz_Cov_SST, _
          UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC 

        Else
          'Planar Fit Rotation
          If (WD_SONIC_SST <= 60)      Then
            alpha_5min = alpha_PF_60_300
            beta_5min  = beta_PF_60_300
          ElseIf (WD_SONIC_SST <= 170) Then
            alpha_5min = alpha_PF_60_170
            beta_5min  = beta_PF_60_170
          ElseIf (WD_SONIC_SST <= 190)  Then
            alpha_5min = alpha_PF_170_190
            beta_5min  = beta_PF_170_190
          ElseIf (WD_SONIC_SST <= 300)  Then
            alpha_5min = alpha_PF_190_300
            beta_5min  = beta_PF_190_300
          Else
            alpha_5min = alpha_PF_60_300
            beta_5min  = beta_PF_60_300
          EndIf

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alpha_5min, beta_5min, _
          Ux_Avg_SST, Uy_Avg_SST, Uz_Avg_SST, Ux_Var_SST, Uy_Var_SST, Uz_Var_SST, UxUy_Cov_SST, UxUz_Cov_SST, UyUz_Cov_SST, _
          U_SST,      V_SST,      W_SST,      U_Var_SST,  V_Var_SST,  W_Var_SST,  UV_Cov_SST,   UW_Cov_SST,   VW_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
                      
          'Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          TsUx_Cov_SST,     TsUy_Cov_SST,     TsUz_Cov_SST, _
          UT_SONIC_Cov_SST, VT_SONIC_Cov_SST, WT_SONIC_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC 
        EndIf

        If (UW_Cov_SST <> NaN) AND (VW_Cov_SST <> NaN) AND (WT_SONIC_Cov_SST <> NaN) Then
          RN_UW_cov       += UW_Cov_SST
          RN_VW_cov       += VW_Cov_SST
          RN_WT_SONIC_cov += WT_SONIC_Cov_SST

          nmbr_interval_qc_csat += 1
        EndIf

      EndIf

      If (comp_cov_3d.Output(1, 1) AND comp_cov_3d_5min.Output(1, 1))Then
        GetRecord (Ux_Avg, comp_cov_3d, 1)                                'Ux_avg is the 1st element of cov_out_sonic
        T_SONIC       = Ts_Avg                                            'For output in AeriFlux format 
        Ts_SIGMA      = SQR(Ts_SIGMA)
        T_SONIC_SIGMA = Ts_SIGMA        

        '*** Coordinate rotations ***
        If (NOT (Planar_Fit_flg)) Then
          'Double coordinate rotations
          gamma = WD_SONIC                                                'Rotation angle about z-axis
          alpha = -ATN2(Uz_Avg, SQR(Ux_Avg*Ux_Avg + Uy_Avg*Uy_Avg))       'Rotation angle about intermediate y-axis (range of -90 to 90 degrees)

          ' Rotation for momentum variables
          Call Rotation12_Momentum(alpha, gamma, _
          Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov, _
          U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
          'After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W

          Ux_SIGMA = SQR(Ux_SIGMA)
          Uy_SIGMA = SQR(Uy_SIGMA)
          Uz_SIGMA = SQR(Uz_SIGMA)

          'Rotation for the covariance of sonic temperature with velocities
          Call Rotation12_Scalar_Covariance(alpha, gamma, _
          TsUx_Cov,     TsUy_Cov,     TsUz_Cov, _
          UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
        Else
          'Planar Fit Rotation
          If (WD_SONIC <= 60)       Then
            alpha = alpha_PF_60_300
            beta  = beta_PF_60_300
          ElseIf (WD_SONIC <= 170)  Then
            alpha = alpha_PF_60_170
            beta  = beta_PF_60_170
          ElseIf (WD_SONIC < 190)   Then
            alpha = alpha_PF_170_190
            beta  = beta_PF_170_190
          ElseIf (WD_SONIC < 300)   Then
            alpha = alpha_PF_190_300
            beta  = beta_PF_190_300
          Else
            alpha = alpha_PF_60_300
            beta  = beta_PF_60_300
          EndIf

          ' Rotations for momentum variables
          Call Rotation23_Momentum(alpha, beta, _
          Ux_Avg, Uy_Avg, Uz_Avg, Ux_SIGMA, Uy_SIGMA, Uz_SIGMA, UxUy_Cov, UxUz_Cov, UyUz_Cov, _
          U,      V,      W,      U_SIGMA,  V_SIGMA,  W_SIGMA,  UV_Cov,   UW_Cov,   VW_Cov)
          'After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
         
          Ux_SIGMA = SQR(Ux_SIGMA)
          Uy_SIGMA = SQR(Uy_SIGMA)
          Uz_SIGMA = SQR(Uz_SIGMA)
         
         'Rotations for the covariance of sonic temperature with velocities
          Call Rotation23_Scalar_Covariance(alpha, beta, _
          TsUx_Cov,     TsUy_Cov,     TsUz_Cov, _
          UT_SONIC_Cov, VT_SONIC_Cov, WT_SONIC_Cov)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, Uz by W, and Ts by T_SONIC
        EndIf
        '*** End of coordinate rotations ***

        'Rotate the CSAT sonic head RHC system so the negative x-axis points north
        WD = (360 + sonic_azimuth - WD_SONIC) MOD 360

        'Compute specific turbulence kinetic energy
        TKE = 0.5*(U_SIGMA + V_SIGMA + W_SIGMA)

        'Compute the standard deviation from the variance after rotation
        U_SIGMA = SQR (U_SIGMA)
        V_SIGMA = SQR (V_SIGMA)
        W_SIGMA = SQR (W_SIGMA)

        '*** Freq corrections for UW_Cov, VW_Cov, and wTs_cov_R ***
        'Compute online fluxes after rotations.
        USTAR_R =  SQR(SQR((UW_Cov*UW_Cov) + (VW_Cov*VW_Cov)))

        ' Preparation for freq corection to UW_Cov, VW_Cov, and WT_SONIC_cov
        ' Monin-Obukhov length
        MO_LENGTH = -USTAR_R*USTAR_R*USTAR_R*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov)

        ' Atmospheric boundary-layer stability
        ZL = z/MO_LENGTH

        FreqFactor_UW_VW_Prev  = 0
        Call  FreqFactorCSAT_uw_vw_BA_LA(z, ZL, WS_RSLT, FreqFactor_UW_VW)

        UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
        VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
        USTAR = SQR(SQR ((UW_Cov_fc*UW_Cov_fc) + (VW_Cov_fc*VW_Cov_fc)))

        FreqFactor_WT_SONIC_Prev = 0
        Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)

        WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

        ' Recalculate Monin-Obukhov length
        MO_LENGTH = -USTAR*USTAR*USTAR*(Ts_Avg+T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

        ' Recalculate atmospheric boundary-layer stability
        ZL_prev = ZL
        ZL      = z/MO_LENGTH

        iteration_FreqFactor = 1
        While (((ABS (FreqFactor_UW_VW_Prev -FreqFactor_UW_VW) >= ACCURACY_FREQ_FACTOR) OR _
          (ABS (FreqFactor_WT_SONIC_Prev - FreqFactor_WT_SONIC) >= ACCURACY_FREQ_FACTOR)) AND ((ZL > 0) AND (iteration_FreqFactor <= 10)))

          ZL_prev                  = ZL
          FreqFactor_UW_VW_Prev    = FreqFactor_UW_VW
          FreqFactor_WT_SONIC_Prev = FreqFactor_WT_SONIC

          Call  FreqFactorCSAT_uw_vw_BA_LA (z, ZL, WS_RSLT, FreqFactor_UW_VW)
          UW_Cov_fc = FreqFactor_UW_VW * UW_Cov
          VW_Cov_fc = FreqFactor_UW_VW * VW_Cov
          USTAR = SQR(SQR (UW_Cov_fc*UW_Cov_fc + VW_Cov_fc*VW_Cov_fc))

          Call  FreqFactorCSAT_wTs_BA_LA (z, ZL, WS_RSLT, tran_func_LA_data_Dijk(1,1), FreqFactor_WT_SONIC)
          WT_SONIC_Cov_fc = FreqFactor_WT_SONIC * WT_SONIC_Cov

          ' Monin-Obukhov length
          MO_LENGTH = -USTAR*USTAR*USTAR*(T_SONIC + T_0C_K)/(k*g0*WT_SONIC_Cov_fc)

          ' Atmospheric boundary-layer stability
          ZL = z/MO_LENGTH

          iteration_FreqFactor += 1
        Wend
        '*** End of freq corrections for UW_Cov, VW_Cov, and wT_SONIC_cov ***

        '*** Beginning of data quality classification for momentum flux ***
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_UW_VW_cov = ABS(((RN_UW_cov + RN_VW_cov)/nmbr_interval_qc_csat - UW_Cov - VW_Cov)/(UW_Cov + VW_Cov))  'in fraction
        RN_UW_cov = 0
        RN_VW_cov = 0
        
        Call Data_Quality_SSITC_w_WndDir_Momentum  (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude, WD_SONIC, RN_UW_VW_cov, TAU_QC)
        Call Data_Quality_SSITC_wo_WndDir_Momentum (Planar_Fit_flg, ZL, U_SIGMA, W_SIGMA, USTAR, latitude,           RN_UW_VW_cov, TAU_SSITC_TEST)
        '*** End of data quality classification for momentum flux ***

        '*** Footprint characteristics of measured fluxes ***
        'Update roughness length when a user does not specify z0 and wind is sufficiently strong during a neutral condition
        If ((ABS(ZL) < 0.02) AND (roughness_user = 0) AND (WS_RSLT > 3) AND (TAU_QC <= 6)) Then z0 = z*EXP(-k*WS_RSLT/USTAR)

        'Determining upwind distance of interest
        If (WD_SONIC <= 60) Then
          UPWND_DIST_INTRST = dist_intrst_60_300
        ElseIf (WD_SONIC <= 170) Then
          UPWND_DIST_INTRST = dist_intrst_60_170
        ElseIf (WD_SONIC < 190)  Then
          UPWND_DIST_INTRST = dist_intrst_170_190
        ElseIf (WD_SONIC < 300)  Then
          UPWND_DIST_INTRST = dist_intrst_190_300
        Else
          UPWND_DIST_INTRST = dist_intrst_60_300
        EndIf

        'Footprint selection
        If ((ZL >= -200) AND (ZL <= 1) AND (USTAR >= 0.2) AND (z >= 1)) Then
          'Kljun et al (2004)
          FTPRNT_EQUATION = "Kljun et al"
          'Calculate footprint charactetistics
          Call FootprintCharacteristics_Kljun(USTAR, W_SIGMA, z, MO_LENGTH, z0, UPWND_DIST_INTRST, FTPRNT_DIST_INTRST, FETCH_MAX, FETCH_90, FETCH_55, FETCH_40)
        Else
          'Kormann and Meixner (2001)
          FTPRNT_EQUATION = "KormannMeixner"
          'Calculate footprint charactetistics
          Call FootprintCharacteristics_KormannMeixner(USTAR, z, ZL, WS_RSLT, UPWND_DIST_INTRST, FTPRNT_DIST_INTRST, FETCH_MAX, FETCH_90, FETCH_55, FETCH_40)
        EndIf
        '*** End of footprint characteristics of measured fluxes ***
      EndIf
      '*** End of CSAT sonic head processing ***

      '*** Beginning of IRGA processing ***
      'Load in the IRGA data that has been lagged by EC100_REC_BCK scans.
      mask = &h1
      For i = MAX_LAG To - MAX_LAG Step -1
        array_index = MAX_LAG + 1 - i                                        'Convert i = 2, 1, 0, -1, -2 to array_index = 1, 2, 3, 4, 5

        GetRecord (dly_data_out(1), delay_CS, (EC100_REC_BCK + i))
        If (i = 0) Then Move (CO2_density, 7, dly_data_out(1), 7)            'CO2_density, H2O_density, diag_irga, amb_tmpr, amb_press, CO2_sig_strgth, H2O_sig_strgth
        
        'Extract the diagnostic word from each record of lagged data, used to exclude data from covariance calculation in Tables: comp_cov_CO2, comp_cov_H2O, and comp_cov_cs_5min.
        diag_irga_tmp = IIF ((dly_data_out(3) <> NAN) AND (dly_data_out(3) <> -1),dly_data_out(3), &h3fffff)
        irga_bad_data_flg_array(array_index) = mask AND diag_irga_tmp
        
        If (NOT sonic_disable_f) AND (NOT irga_bad_data_flg_array(array_index)) Then
          T_tmp= (2*Ts_K*dly_data_out(5))/(dly_data_out(5) + SQR(dly_data_out(5)*(dly_data_out(5) +1.28*Rv*dly_data_out(2)*Ts_K)))
        
        ElseIf (irga_bad_data_flg_array(array_index) AND (NOT (diag_irga_tmp AND &H400)))    '&H400 for amb_temp flag 
          T_tmp = dly_data_out(4) + T_0C_K
               
        ElseIf (irga_bad_data_flg_array(array_index) AND (diag_irga_tmp AND &H400))          '&H400 for amb_temp flag 
          T_tmp = NaN
        ElseIf (sonic_disable_f) AND (NOT irga_bad_data_flg_array(array_index))
          T_tmp = dly_data_out(4) + T_0C_K
        
        EndIf          
         
       'Compute the molar number of dry air 
        divisor = (dly_data_out(5)/(R*T_tmp))-(dly_data_out(2)/18)

        'Load the arrays that hold the input data for the covariance instructions.
        Move (cov_array_CO2(array_index, 1), 1, dly_data_out(1),1)                           'CO2_density in mg m-3
        Move (cov_array_CO2(array_index, 2), 3, Ux, 3)
        CO2_bad_rng_sig_array (array_index) = ((dly_data_out(6) < CO2_SIG_STRGTH_THRESHOULD) OR (dly_data_out(1) <0) OR (dly_data_out(1) > CO2_RNG_TOP_LIMIT))
        cov_array_CO2(array_index, 5)       = dly_data_out(1)/(0.04401*divisor)              'CO2 in umol mol-1 (See http://www.carbontracker.eu/glossary.html) 

        Move (cov_array_H2O(array_index, 1), 1, dly_data_out(2),1)                           'H2O_density in g m-3  
        Move (cov_array_H2O(array_index, 2), 3, Ux, 3)
        H2O_bad_rng_sig_array (array_index) = ((dly_data_out(7) < H2O_SIG_STRGTH_THRESHOULD) OR (dly_data_out(2) <0) OR (dly_data_out(2) > H2O_RNG_TOP_LIMIT))
        cov_array_H2O(array_index, 5)       = dly_data_out(2)/(0.01802*divisor)              'H2O in mmol mol-1 (See http://www.carbontracker.eu/glossary.html) 
       
      Next i

      'Call tables for lag maximuzation
      CallTable comp_cov_CO2
      CallTable comp_cov_H2O

      'Extract the twenty two flags from the IRGA diagnostic word
      diag_irga_tmp = IIF ((diag_irga <> NAN) AND (diag_irga <> -1),diag_irga, &h3fffff)
      For i = 1 To 22
        diag_bits_irga(i) = diag_irga_tmp AND mask
        mask = mask*2
      Next i

      'Filter data in the covariance instruction if the IRGA reports bad data.
      irga_disable_f = irga_bad_data_f

      'Call table for data used for data quality grading
      CallTable Comp_cov_CS_5min
      
      '***Compute water vapor pressure, dry air density, moist air density, saturate water pressure, RH and dew poit temperature  

      'Using 107 temperature, H2O, and pressure 
      'water vapor pressure, dry air density, and moist air density 
      amb_e     = H2O_density*Rv*(amb_tmpr + T_0C_K )                                                 'Ideal gas equation (kPa)
      amb_rho_d = (amb_press - amb_e)/((amb_tmpr + T_0C_K )*Rd)                                       'g/m^3
      amb_rho_a = (amb_rho_d + H2O_density)/1000                                                      'kg/m^3

      'Saturation water pressure at current temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(amb_tmpr + 30.6 - 0.38*amb_press)^2)   'Eq. 6 from Appendix A of flux program manual

      Select Case amb_tmpr                                                                            'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        amb_e_sat = 0.61121*Enhance_Factor1*EXP(17.368*amb_tmpr/(amb_tmpr + 238.88))
      Case Is < 0
        amb_e_sat = 0.61121*Enhance_Factor1*EXP(17.966*amb_tmpr/(amb_tmpr + 247.15))
      EndSelect

      'Relative humidity
      amb_RH = 100 * amb_e/amb_e_sat
      
      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_Factor2 = 1.00072 + 3.46e-5*amb_press                                                  'Eq. 9 from Appendix A of flux program manual

      x_tmp           = LN(amb_e/(0.61121*Enhance_Factor2))                                          'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gu           = 240.97*x_tmp/(17.502-x_tmp)

      'Accurate dew point temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gu + 30.6 - 0.38*amb_press)^2)      'Eq. 6 from Appendix A of flux program manual
      x_tmp           = LN(amb_e/(0.61121*Enhance_Factor1))                                           'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gu                                                                               'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0
        amb_T_DP = 238.88*x_tmp/(17.386 - x_tmp)
      Case Is < 0
        amb_T_DP = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

     'Using sonic temperature, H2O, and pressure 

      If (Ts_K <> NaN) Then
        'Compute fast response air temperature from sonic temperature and IRGASON vapor density.
        x_tmp = SQR(((1-epsilon)*Rd*H2O_density*Ts_K + epsilon*amb_press)^2 - 4*epsilon*(1-1.511494*epsilon)*Rd*H2O_density*amb_press*Ts_K)  
        Tc_K  = ((1 - epsilon)*Rd*H2O_density*Ts_K + epsilon*amb_press - x_tmp)/(2*(1 - 1.511494*epsilon)*Rd*H2O_density)   'Eq 21 
      Else
        Tc_K = NaN                                                               'Tc_K in K
      EndIf
       
      'Calculate water vapor pressure using sonic and IRGA measurements
      e     = H2O_density*Rv*Tc_K                                                'Ideal gas equation (kPa)
      rho_d = (amb_press - e)/(Tc_K*Rd)                                          'g/m^3
      rho_a = (rho_d + H2O_density)/1000                                         'kg/m^3
    
      'Convert Tc in K to Tc in C
      Tc = Tc_K - T_0C_K                                                         'Tc in C

      'Saturation water pressure at current temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Tc + 30.6 - 0.38*amb_press)^2)   'Eq. 6 from Appendix A of flux program manual

      Select Case Tc                                                                            'Eq. 5 from Appendix A of flux program manual
      Case Is >= 0
        e_sat = 0.61121*Enhance_Factor1*EXP(17.368*Tc/(Tc + 238.88))
      Case Is < 0
        e_sat = 0.61121*Enhance_Factor1*EXP(17.966*Tc/(Tc + 247.15))
      EndSelect

      'Relative humidity
      RH = 100 * e/e_sat
      
      'Dew point temperature for general use for accurately computing the final dew point temperature
      Enhance_Factor2 = 1.00072 + 3.46e-5*amb_press                                              'Eq. 9 from Appendix A of flux program manual

      x_tmp           = LN(e/(0.61121*Enhance_Factor2))                                          'For dew point temperature, assume that e is saturation water vapor pressure
      Td_gu           = 240.97*x_tmp/(17.502-x_tmp)

      'Accurate dew point temperature
      Enhance_Factor1 = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gu + 30.6 - 0.38*amb_press)^2) 'Eq. 6 from Appendix A of flux program manual
      x_tmp           = LN(e/(0.61121*Enhance_Factor1))                                          'For dew point temperature, assume that e is saturation water vapor pressure

      Select Case Td_gu                                                                          'Eq. 11 from Appendix A of flux program manual
      Case Is >= 0
        T_DP = 238.88*x_tmp/(17.386 - x_tmp)
      Case Is < 0
        T_DP = 247.15*x_tmp/(17.966 - x_tmp)
      EndSelect

      'Compute the molar mixing ratio of CO2 and H2O.
      divisor = (amb_press/(R*Tc_K))-(H2O_density/18)
      CO2_mixratio = CO2_density/(0.04401*divisor)
      H2O_mixratio = H2O_density/(0.01802*divisor)

      CallTable comp_mean

      If (comp_cov_cs_5min.Output(1, 1)) Then
        GetRecord (CO2_density_var_SST, comp_cov_cs_5min, 1)

        If (NOT (Planar_Fit_flg)) Then
          'Rotation for the covariance of CO2 with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          UxCO2_Cov_SST, UyCO2_Cov_SST, UzCO2_Cov_SST, _
          UCO2_Cov_SST,  VCO2_Cov_SST,  WCO2_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
          
          'Rotation for the covariance of H2O with velocities
          Call Rotation12_Scalar_Covariance(alpha_5min, gamma_5min, _
          UxH2O_Cov_SST, UyH2O_Cov_SST, UzH2O_Cov_SST, _
          UH2O_Cov_SST,  VH2O_Cov_SST,  WH2O_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
        Else
          'Rotations for the covariance of CO2 with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          UxCO2_Cov_SST, UyCO2_Cov_SST, UzCO2_Cov_SST, _
          UCO2_Cov_SST,  VCO2_Cov_SST,  WCO2_Cov_SST)
         'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
          
          'Rotations for the covariance of H2O with velocities
          Call Rotation23_Scalar_Covariance(alpha_5min, beta_5min, _
          UxH2O_Cov_SST, UyH2O_Cov_SST, UzH2O_Cov_SST, _
          UH2O_Cov_SST,  VH2O_Cov_SST,  WH2O_Cov_SST)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W 
        EndIf

        If ((WCO2_Cov_SST <> NaN) AND (WH2O_Cov_SST <> NaN)) Then
          RN_WCO2_Cov += WCO2_Cov_SST
          RN_WH2O_Cov += WH2O_Cov_SST
          nmbr_interval_qc_irga += 1
        EndIf

      EndIf

      If (comp_cov_CO2.Output(1,1) AND comp_cov_H2O.Output(1,1) AND comp_mean.Output(1,1) AND comp_cov_cs_5min.Output(1, 1))  Then
        GetRecord (CO2_Avg_lag_b2, comp_cov_CO2, 1)
        GetRecord (H2O_Avg_lag_b2, comp_cov_H2O, 1)
        GetRecord (TA_1_1_1,       comp_mean,    1)

        VPD = 10*(e_sat_Avg - e_Avg)                  'Water vapor pressue deficit in hPa. "10" is used to convert unit of kPa to hKa

        'Rotate CO2-related covariance
        wCO2_Cov_major_sign = 0                       'Variable indicating the major direction (sign) of CO2 flux

        For i = 1 To (2* MAX_LAG + 1)
          array_index = 7*(i-1) + 5
          If (NOT (Planar_Fit_flg)) Then
            'Double rotations
            'Rotation for the covariance of CO2 with velocities
            Call Rotation12_Scalar_Covariance(alpha, gamma, _
            Cov_out_CO2(array_index), Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
            UCO2_VCO2_Cov_lag(i, 1),  UCO2_VCO2_Cov_lag(i, 2),      WCO2_Cov_lag (i))
            'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
          Else
            'Planar Fit rotations
            'Rotation for the covariance of CO2 with velocities
            Call Rotation23_Scalar_Covariance(alpha, beta, _
            Cov_out_CO2(array_index), Cov_out_CO2(array_index + 1), Cov_out_CO2(array_index + 2), _
            UCO2_VCO2_Cov_lag(i, 1),  UCO2_VCO2_Cov_lag(i, 2),      WCO2_Cov_lag (i))
           'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
          EndIf

          wCO2_Cov_major_sign += WCO2_Cov_lag (i)

        Next i

        ' Calculate the separation distance normal (lateral) to wind and separation distance along wind
        Call Separation_Lag_Lateral_Distances (WD_SONIC, separation_x_irga, separation_y_irga, separation_lat_dist_irga, separation_lag_dist_irga)
        separation_lag_scan_irga = 1000*(separation_lag_dist_irga/WS_RSLT)/SCAN_INTERVAL   'in scan

        WCO2_Cov = NaN
        Select Case wCO2_Cov_major_sign
        Case Is >=0

          If separation_lag_scan_irga <= -2    Then             'Find max of wCO2_cov_R
            MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (1))

          ElseIf separation_lag_scan_irga < 0  Then             'Search three elements in the array to ensure maximization.
            MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (2))
            lag_irga = lag_irga + 1

          ElseIf separation_lag_scan_irga = 0  Then
            WCO2_Cov = WCO2_Cov_lag (3)
            lag_irga = MAX_LAG + 1

          ElseIf separation_lag_scan_irga < 2  Then
            MaxSpa (WCO2_Cov, 2, WCO2_Cov_lag (3))
            lag_irga = lag_irga + 2

          Else
            MaxSpa (WCO2_Cov, 3, WCO2_Cov_lag (3))              'Search three elements in the array to ensure maximization.
            lag_irga = lag_irga + 2
          EndIf

        Case Is < 0

          If separation_lag_scan_irga <= -2     Then            'Find min of wCO2_cov_R
            MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (1))

          ElseIf separation_lag_scan_irga < 0   Then            'Search three elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (2))
            lag_irga = lag_irga + 1

          ElseIf separation_lag_scan_irga = 0   Then
            WCO2_Cov = WCO2_Cov_lag (3)
            lag_irga = MAX_LAG + 1

          ElseIf separation_lag_scan_irga < 2   Then            'Search three elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WCO2_Cov, 2, WCO2_Cov_lag (3))
            lag_irga = lag_irga + 2

          Else
            MinSpa (WCO2_Cov, 3, WCO2_Cov_lag (3))
            lag_irga = lag_irga + 2
          EndIf
        EndSelect

        If (WCO2_Cov = NaN) Then lag_irga = MAX_LAG + 1       'Lag_IRGA is not evaluated inside SELECT CASE if WCO2_Cov = NaN. In this case, data w/o lag delay in cov_out_CO2 are kept.

        'For final storage in flux file
        'Covariance values related to CO2 and H2O before coordinate rotation can be found using lag-IRGA
        array_index =  7*(lag_irga - 1) + 1
        Move (CO2, 7, Cov_out_CO2(array_index), 7)
        CO2_SIGMA         = SQR (CO2_SIGMA)
        CO2_density_SIGMA = SQR (CO2_density_SIGMA)
        
        Move (H2O, 7, Cov_out_H2O(array_index), 7)
        CO2_SIGMA         = SQR (CO2_SIGMA)
        H2O_density_SIGMA = SQR (H2O_density_SIGMA)
        
        'Covariance of horizontal wind (after coordinate rotations) and CO2 using lag-IRGA
        UCO2_Cov = UCO2_VCO2_Cov_lag(lag_irga, 1)
        VCO2_Cov = UCO2_VCO2_Cov_lag(lag_irga, 2)

        'Rotate covariance related to H2O
        If (NOT (Planar_Fit_flg)) Then
          'Double rotations
          ' Rotation for the covariance of H2O with velocities
          Call Rotation12_Scalar_Covariance(alpha, gamma, _
          UxH2O_Cov, UyH2O_Cov, UzH2O_Cov, _
          UH2O_Cov,  VH2O_Cov,  WH2O_Cov)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
            
        ElseIf (Planar_Fit_flg) Then
          ' Planar Fit rotations
          ' Rotation for the covariance of H2O with velocities
          Call Rotation23_Scalar_Covariance(alpha, beta, _
          UxH2O_Cov, UyH2O_Cov, UzH2O_Cov, _
          UH2O_Cov,  VH2O_Cov,  WH2O_Cov)
          'Note: After coordniate rotations, Ux is denoted by U, Uy by V, and Uz by W
            
        EndIf

        'Convert lag_IRGA as an array index in sequential number as a lag number in scan (compare to CSAT data, negative: backward and positive: forward)
        lag_irga  = lag_irga  - (MAX_LAG + 1)

        ' Calculate the frequency correction factor for wCO2_cov_R and WH2O_Cov
        Call FreqFactorCSOPEC_wco2_wh2o_BA_LA_SP (z, ZL, WS_RSLT, separation_lat_dist_irga, FreqFactor_WCO2_WH2O)
        WCO2_Cov_fc = FreqFactor_WCO2_WH2O*WCO2_Cov
        WH2O_Cov_fc = FreqFactor_WCO2_WH2O*WH2O_Cov

        'Momentum flux after coordinater rotation and frequency corrections
        TAU = rho_a_Avg*USTAR^2
        
        'Correct sonic temperature flux for humidity and calculate sensible heat flux
        WT_SONIC_Cov_fc_SND = WT_SONIC_Cov_fc*(1- 0.51*(H2O_density_Avg/(1e3*rho_a_Avg)))-0.51*(T_SONIC + T_0C_K)*WH2O_Cov_fc/(1e3*rho_a_Avg)     'eq. 2.53 in van Dijk (2002)
      
        Cp = (Cpd*rho_d_Avg + Cpw*H2O_density_Avg)/(rho_d_Avg + H2O_density_Avg)  'Specific heat of moist air
        H  = Cp*rho_a_Avg*WT_SONIC_Cov_fc_SND

         TSTAR = - WT_SONIC_Cov_fc_SND/USTAR

        'Apply WPL correction after coordinate rotation and freq corrections
        'IRGA Webb et al. (1980) term for carbon dioxide Eq. (24).
        sigma_wpl    = H2O_density_Avg/rho_d_Avg
        CO2_E_WPL_fc = MU_WPL*CO2_density_Avg*WH2O_Cov_fc/rho_d_Avg
        CO2_T_WPL_fc = (1 + (MU_WPL*sigma_wpl))*CO2_density_Avg*WT_SONIC_Cov_fc_SND/(TA_2_1_1+T_0C_K)

        FC_mass  = WCO2_Cov_fc + CO2_E_WPL_fc + CO2_T_WPL_fc                     'in mg/(m^2 s)
        FC = 22.72237*FC_mass                                                    '"22.72237" converts mg/(m^2 s) to umol/(m^2 s)

        'IRGA Webb et al. (1980) term for water vapor Eq. (25).
        H2O_E_WPL_fc  = MU_WPL*sigma_wpl*WH2O_Cov_fc
        H2O_T_WPL_fc  = (1 + (MU_WPL*sigma_wpl))*H2O_density_Avg*WT_SONIC_Cov_fc_SND/(TA_2_1_1+T_0C_K)

        Lv  = 2501 - 2.365*TA_2_1_1                                             'Stull (1989)
        LE  = Lv* (WH2O_Cov_fc + H2O_E_WPL_fc + H2O_T_WPL_fc)

        Bowen_ratio = H/LE

        '*** Data quality classification for scalar fluxes ***
        'Sensible heat flux
        'Calculate the measures of relative non-stationarity (Steady State Test)
        RN_WT_SONIC_cov  = ABS((RN_WT_SONIC_cov/nmbr_interval_qc_csat - WT_SONIC_Cov)/WT_SONIC_Cov)     'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WT_SONIC_cov, H_QC)           'Quality classification for sensible heat flux
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WT_SONIC_cov, H_SSITC_TEST)   'Quality classification for sensible heat flux
        RN_WT_SONIC_cov = 0
        nmbr_interval_qc_csat = 0

        'CO2 flux
        'Calculate measures of relative non-stationarity (Steady State Test)
        RN_WCO2_Cov = ABS((RN_WCO2_Cov/nmbr_interval_qc_irga - WCO2_Cov)/WCO2_Cov)  'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WCO2_Cov, FC_QC)               'Quality classification for CO2 flux
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WCO2_Cov, FC_SSITC_TEST)       'Quality classification for CO2 flux
        RN_WCO2_Cov   = 0

        'H2O flux
        'Calculate measures of relative non-stationarity (Steady State Test)
        RN_WH2O_Cov = ABS((RN_WH2O_Cov/nmbr_interval_qc_irga - WH2O_Cov)/WH2O_Cov)  'in fraction
        Call Data_Quality_SSITC_w_WndDir_Scalar  (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude, WD_SONIC, RN_WH2O_Cov, LE_QC)               'Quality classification for latent heat flux
        Call Data_Quality_SSITC_wo_WndDir_Scalar (ZL, W_SIGMA, USTAR, T_SONIC_SIGMA, TSTAR, latitude,           RN_WH2O_Cov, LE_SSITC_TEST)       'Quality classification for latent heat flux
        RN_WH2O_Cov   = 0
        nmbr_interval_qc_irga = 0
        '*** End of data quality classification for scalar fluxes ***

      EndIf
      '*** End of IRGA processing ***
        
      #If (SENSOR_TMPR_RH) Then
      '*** Beginning of temperature and humidity processing ***
      CallTable stats_tmpr_rh
            
      If (stats_tmpr_rh.Output(1,1)) Then
        GetRecord (TA_3_1_1, stats_tmpr_rh, 1)
        rho_a_probe_Avg = (rho_d_probe_Avg + H2O_probe_Avg)/1000                   'kg/m^3
      EndIf
      '*** End of temperature and humidity probe processing ***
     #EndIf 
     
     #If (SENSOR_NR_LITE) Then

      '*** Beginning of NR Lite processing ***
      hor_wind_raw = SQR (sonic_irga_raw(1)*sonic_irga_raw(1) + sonic_irga_raw(2)*sonic_irga_raw(2))
      AvgRun (hor_wind, 1 , hor_wind_raw, NMBR_WND_SAMPLES)                        'Maintain a three second running mean of horizontal wind.
      AvgRun (hor_wind_diag, 1, sonic_irga_raw(5), NMBR_WND_SAMPLES)               'Only correct for wind when hor_wind_diag has been non-zero for past 3 seconds.
      '*** End of NR Lite processing ***

      #EndIf
      #If (SENSOR_Rn) Then
      CallTable stats_net_radiation

      'Get Rn for the current averaging interval ***
      If (stats_net_radiation.Output(1,1)) Then

        GetRecord (Rn, stats_net_radiation, 1)

      EndIf
      #EndIf

      #If (SENSOR_HFP) Then

      '*** Beginning of table for soil heat flux plate ***
      CallTable stats_SHF
      '*** End of table for soil heat flux plate ***

      '*** Beginning of calculating the change in heat storage of soil above soil heat flux plate ***
      If (stats_SHF.Output(1,1)) Then

        GetRecord (shf_plate_avg(1), stats_SHF, 1)

        #If (((SENSOR_TCAV) OR (SENSOR_CS65X)) AND (SENSOR_CS6XX)) Then
        AvgSpa(G_surface, NMBR_HFP, shf_plate_avg(1))                           'G_surface is used as a temporary variable

        #If (SENSOR_TCAV) Then
        AvgSpa(Tsoil_current_Avg, NMBR_TCAV, Tsoil_current (1))
        #EndIf
        #If ((NOT SENSOR_TCAV) AND (SENSOR_CS65X)) Then
        AvgSpa(Tsoil_current_Avg, NMBR_CS6xx, Tsoil_current (1))
        #EndIf

        AvgSpa(soil_wtr_current_Avg, NMBR_CS6xx, soil_wtr_current (1))
        
        SG = ((Tsoil_current_Avg + T_0C_K)*Cds*soil_bulk_density + ((Tsoil_current_Avg + T_0C_K)*soil_wtr_current_Avg)*1000*Cw)*thick_abv_HFP

        SG_delta = ((Tsoil_current_Avg - Tsoil_prev_Avg)*Cds*soil_bulk_density + _
        (Tsoil_current_Avg*soil_wtr_current_Avg - Tsoil_prev_Avg*soil_wtr_prev_Avg)*1000*Cw)*thick_abv_HFP/(60*OUTPUT_INTERVAL - Offset_intv_delta_ht_storage)

        Offset_intv_delta_ht_storage = 0   'Reset time interval offset

        G_surface = G_surface + SG_delta

        Tsoil_prev_Avg    = Tsoil_current_Avg
        soil_wtr_prev_Avg = soil_wtr_current_Avg

        #If (SENSOR_Rn) Then
        'CNR1, NR01, CNR4: smallest sensitivity is 10 uV/(W/m^2), CR6 resolution at the measurement range (+/-200 mV) is 0.05 uV.
        'Radiation < 0.005 W/m^2 can not be resolved by CR6. The value of 0.05 is used for this threshould although this is approximation.
        If  (ABS(Rn - G_surface) > 0.005) Then
          energy_closure = (LE + H)/(Rn - G_surface)
        Else
          energy_closure = 1
        EndIf
 
        #EndIf
        #EndIf

      EndIf
      #EndIf
      #If (SENSOR_FW) Then

      '*** Beginning of FW processing ***
      'Load in the FW data that has been lagged by OFFSET scans.
      For i = MAX_LAG To - MAX_LAG Step -1
        array_index = MAX_LAG + 1 - i                                           'Convert i = 2, 1, 0 -1, -2 to array_index = 1, 2, 3, 4, 5

        GetRecord (dly_data_FW_out(1), delay_fw, (OFFSET +i))

        'Load the arrays that hold the input data for the covariance instructions.
        Cov_array_FW(array_index, 1) = dly_data_FW_out(1)                       'fw
        Move (Cov_array_FW(array_index, 2), 3, Ux, 3)
        
        FW_bad_data_flg(array_index) = (dly_data_FW_out(2) = -1)
               
              
      Next i

      FW = Cov_array_FW(MAX_LAG + 1, 1)                                          'W with no lag will be stored To Time_Series table

      CallTable comp_cov_fw

      If (comp_cov_fw.Output(1,1)) Then
        GetRecord (FW_Avg_lag_b2, comp_cov_fw, 1)

        wFW_cov_major_sign =0

        For i = 1 To (2* MAX_LAG + 1)
          array_index = 7*(i -1) + 3
          If (NOT (Planar_Fit_flg)) Then
            ' Double rotations
            ' Rotation for the covariance of FW temperature with wind velocities
            Call Rotation12_Scalar_Covariance(alpha, gamma, _
            Cov_out_FW(array_index), Cov_out_FW(array_index + 1), Cov_out_FW(array_index + 2), _
            UFW_VFW_Cov_lag(i, 1),   UFW_VFW_Cov_lag(i, 2),       WFW_Cov_lag (i))
            
          Else
            ' Planar fit rotations
            ' Rotation for the covariance of FW temperature with velocities
            Call Rotation23_Scalar_Covariance(alpha, beta, _
            Cov_out_FW(array_index), Cov_out_FW(array_index + 1), Cov_out_FW(array_index + 2), _
            UFW_VFW_Cov_lag(i, 1),   UFW_VFW_Cov_lag(i, 2),       WFW_Cov_lag (i))
          EndIf

            WFW_cov_major_sign += WFW_Cov_lag(i)
        Next i

        'Calculate the separation distances normal (lateral) to wind and separation distances along wind
        Call Separation_Lag_Lateral_Distances (WD_SONIC, separation_x_FW, separation_y_FW, separation_lat_dist_FW, separation_lag_dist_FW)
        separation_lag_scan_FW = 1000*(separation_lag_dist_FW/WS_rslt)/SCAN_INTERVAL   ' in scan

        WFW_Cov = NaN
        Select Case WFW_cov_major_sign
        Case Is >=0
          If (separation_lag_scan_FW <= -2)     Then      'Find max of WFW_Cov
            MaxSpa (WFW_Cov, 2, WFW_Cov_lag(1))

          ElseIf (separation_lag_scan_FW <= 2)  Then      'Search three elements in the array to ensure maximization.
            MaxSpa (WFW_Cov, 3, WFW_Cov_lag(2))
            lag_FW = lag_FW + 1
          
          Else
            MaxSpa (WFW_Cov, 2, WFW_Cov_lag(4))           'Search three elements in the array to ensure maximization.
            lag_FW = lag_FW + 3
          EndIf

        Case Is < 0
          If (separation_lag_scan_FW <= -2)      Then      'Find min of WFW_Cov
            MinSpa (WFW_Cov, 2, WFW_Cov_lag(1))

          ElseIf (separation_lag_scan_FW <= 2)   Then      'Search three elements in the array to ensure maximization in terms of absolute value.
            MinSpa (WFW_Cov, 3, WFW_Cov_lag(2))
            lag_FW = lag_FW + 1
          
          Else
            MinSpa (WFW_Cov, 2, WFW_Cov_lag (4))           'Search three elements in the array to ensure maximization in terms of absolute value.
            lag_FW = lag_FW + 3
          EndIf

        EndSelect
                       
        If (WFW_Cov = NaN) Then lag_FW = MAX_LAG + 1       'Lag_FW is not evaluated inside SELECT CASE if WFW_Cov = NaN. In this case, data w/o lag delay in cov_out_fw are kept.

        ' For final storage in flux table
        ' FW Covariance before coordinate rotation can be found using lag-variable
        array_index = 7*(lag_FW - 1)
        FW_Avg      = Cov_out_FW(array_index + 1)
        FW_SIGMA    = SQR(Cov_out_FW(array_index + 2))
        UxFW_Cov    = Cov_out_FW(array_index + 3)
        UyFW_Cov    = Cov_out_FW(array_index + 4)
        UzFW_Cov    = Cov_out_FW(array_index + 5)
        
                               
        nmbr_smpl_FW = Cov_out_FW(array_index + 7)
        
        ' FW Covariance after coordinate rotation also can be found using lag-variable
        UFW_Cov = UFW_VFW_Cov_lag(lag_FW, 1)
        VFW_Cov = UFW_VFW_Cov_lag(lag_FW, 2)

        'Convert lag_FW in sequential number for array index to that in scan number. Compare to CSAT data, negative: backward and positive: forward.
        lag_FW  = lag_FW  - (MAX_LAG + 1)

        'Calculate FW time constant
        Call Time_Const_Thermocouple_E(FW_diameter, FW_Avg, WS_RSLT, rho_a_Avg, Cp, time_const_FW)
        'time_const_FW = Time_Const_Thermocouple_E(FW_diameter, T_TS100_Avg, WS_rslt, rho_a_TS100_Avg)
        
        'Temperary
        separation_lat_dist_FW = SQR(separation_x_FW*separation_x_FW + separation_y_FW*separation_y_FW) 
        
        Call FreqFactorCSATFW_wT_BA_LA_TC_SP (z, ZL, WS_RSLT, separation_lat_dist_FW, time_const_FW, FreqFactor_WFW)
        WFW_Cov_fc = FreqFactor_WFW*WFW_Cov
         
        H_FW = Cp*rho_a_Avg*WFW_Cov_fc
             
      EndIf
      '*** End of FW processing ***
      #EndIf
      
      process_time = (Status.ProcessTime(1,1))/1000                              'in ms 
      buff_depth   = Status.BuffDepth(1,1)

      'Save time series data.
      CallTable Time_Series

      'Save averaged and calculated data.
      CallTable Flux_AmeriFluxFormat
     
      CallTable Flux_CSFormat
     
      #If (NOT ONE_FULL_TABLE) Then
      CallTable Flux_Notes
      #EndIf
               
      slowsequence_disable_flg = TRUE
      If (slowsequence_finished_flg) Then
        slowsequence_finished_flg = FALSE
        slowsequence_disable_flg  = FALSE
      EndIf

    Else
      scan_count += 1
    EndIf
    CallTable diagnostic

  NextScan

  SlowSequence

  Scan (SLOWSEQUENCE_SCAN_INTERVAL, mSec, 3, 0)

    'Measure battery voltage.
    Battery (batt_volt)
    
    'Measure CR6 panel temperature
    PanelTemp (panel_tmpr, FIRST_NOTCH_FREQ_SLOW_SEQU)
            
    #If (SENSOR_Rn) Then
    '*** Beginning of net radiation measurements ***

    #If (SENSOR_NR_LITE) Then

    '*** Beginning of NR Lite measurements ***
    CDM_VoltDiff(CDM_MODEL, CPI_ADDR_CDM, Rn_meas, 1, mV200, NR_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, NRLITE_CAL, 0)

    'Apply calibration and wind correction to net radiometer measurement.
    If ((hor_wind_diag = 0) AND (hor_wind > 5)) Then
      Rn_raw = Rn_meas*(1 + (0.021286*(hor_wind - 5)))
    Else
      Rn_raw = Rn_meas
    EndIf
    '*** End of NR Lite measurements ***
    #EndIf

    #If (SENSOR_NR01) OR (SENSOR_CNR4) Then

    '*** Beginning of a 4-way radiometer measurements *** 
    CDM_VoltDiff(CDM_MODEL, CPI_ADDR_CDM, R_SW_in, 4, mV200, NR_ANALOG_INPUT,     TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    #EndIf
    #If (SENSOR_NR01) Then

    'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
    R_SW_in       = R_SW_in*NR01_SW_IN_CAL
    SW_IN         = R_SW_in                                               'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
    R_SW_out      = R_SW_out*NR01_SW_OUT_CAL
    R_LW_in_meas  = R_LW_in*NR01_LW_IN_CAL
    R_LW_out_meas = R_LW_out*NR01_LW_OUT_CAL

    Rn_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas

    If (R_SW_in >0) AND (R_SW_in >= R_SW_out) Then
      albedo = 100*(R_SW_out/R_SW_in)                                     'in %
    Else
      albedo = 0
    EndIf

    'Correct long-wave radiation.
    CDM_Resistance(CDM_MODEL, CPI_ADDR_CDM, T_nr, 1, mV200, T_NR_ANALOG_INPUT, X3, 1, 1675, TRUE, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    T_nr = T_nr/100
    PRT (T_nr, 1, T_nr, 1, T_0C_K)

    'Compute net radiation, albedo, downwelling and upwelling longwave radiation.
    R_LW_in  = R_LW_in_meas  + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)

    '*** End of a 4-way radiometer measurements ***

    #EndIf
    #If (SENSOR_CNR4) Then

    'Compute net radiation, albedo, downwelling and upwelling long-wave radiation.
    R_SW_in       = R_SW_in*CNR4_SW_IN_CAL
    SW_IN         = R_SW_in                                               'for use of the same variable in AmeriFlux format for SW incoming radiation from different sensors  
    R_SW_out      = R_SW_out*CNR4_SW_OUT_CAL
    R_LW_in_meas  = R_LW_in*CNR4_LW_IN_CAL
    R_LW_out_meas = R_LW_out*CNR4_LW_OUT_CAL
  
    Rn_raw = R_SW_in - R_SW_out + R_LW_in_meas - R_LW_out_meas

    If (R_SW_in >0) AND (R_SW_in >= R_SW_out) Then
      albedo = R_SW_out/R_SW_in
    Else
      albedo = 0
    EndIf

    'Correct longwave radiation.
    CDM_BrHalf (CDM_MODEL, CPI_ADDR_CDM, X_cnr4, 1, mV1000, 2*T_NR_ANALOG_INPUT -1, X3, 1, 1000, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    ln_R = LOG (1000*X_cnr4/(1-X_cnr4))
    T_nr = (1/(A_SHH+B_SHH*ln_R+C_SHH*ln_R*ln_R*ln_R))

    R_LW_in  = R_LW_in_meas  + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    R_LW_out = R_LW_out_meas + (Sigma_SB*T_nr*T_nr*T_nr*T_nr)
    '*** End of a 4-way radiometer measurements ***
    #EndIf

    '*** End of net radiation measurements ***

    #EndIf
    #If (SENSOR_HFP01) Then

    '*** Beginning of HFP01 measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, shf_plate(1), NMBR_HFP, mV200C, SHF_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, shf_plate_cal(),0)
    '*** End of HFP01 measurements ***

    #EndIf
    #If ( SENSOR_HFP01SC = TRUE ) Then

    '*** Beginning of HFP01SC measurements ***
    CDM_VoltSe (CDM_MODEL, CPI_ADDR_CDM, shf_mV(1), NMBR_HFP, mV200, SHF_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    
    'Apply HFP01SC soil heat flux plate calibration.
    For i_slow = 1 To NMBR_HFP
      shf_plate(i_slow) = shf_mV(i_slow)*shf_plate_cal(i_slow)
    Next i_slow

    'Power the HFP01SC heaters.
    CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 1, cdm_sw12_state, 0)
    #If (NMBR_HFP > 2)
    CDM_SW12 (CDM_MODEL, CPI_ADDR_CDM, 2, cdm_sw12_state, 0)
    #EndIf 
      
    'Measure voltage across the heater (V_Rf).
    CDM_VoltSe  (CDM_MODEL, CPI_ADDR_CDM, V_Rf(1), NMBR_HFP, mV5000, SHF_HEATER_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 0.001, 0)

    'SHF_HEATER_ANALOG_INPUT + NMBR_HFP
    'Maintain filtered values for calibration.
    AvgRun (shf_mV_run(1), NMBR_HFP, shf_mV(1), 10)
    AvgRun (V_Rf_run(1),   NMBR_HFP, V_Rf(1),   10)

    'Begin HFP01SC calibration one minute into very CAL_INTERVAL minutes.
    If (IfTime (1, CAL_INTERVAL, Min)) Then
      shf_cal_on_f = TRUE
      Move (shf_mV_0(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      cdm_sw12_state = TRUE
    EndIf

    If (IfTime (4, CAL_INTERVAL, Min)) Then
      Move (shf_mV_180(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      Move (V_Rf_180(1), NMBR_HFP, V_Rf_run(1), NMBR_HFP)
      cdm_sw12_state = FALSE
    EndIf

    'End HFP01SC calibration sequence.
    If (IfTime(END_CAL, CAL_INTERVAL, Min)) Then
      Move (shf_mV_end(1), NMBR_HFP, shf_mV_run(1), NMBR_HFP)
      'Compute new HFP01SC calibration factors.
      For i_slow = 1 To NMBR_HFP
        If (V_Rf_180(i_slow) <> NaN) AND (shf_mV_0(i_slow) <> NaN) AND (shf_mV_180 <> NaN) 
        shf_plate_cal(i_slow) = V_Rf_180(i_slow)*V_Rf_180(i_slow)*128.7/ABS (((shf_mV_0(i_slow)+shf_mV_end(i_slow))/2)-shf_mV_180(i_slow))
        EndIf
      Next i_slow
      shf_cal_on_f = FALSE
    EndIf
    '*** End of HFP01SC measurements ***
    #EndIf
    #If (SENSOR_TCAV) Then

    '*** Beginning of TCAV measurements ***
    CDM_TCDiff (CDM_MODEL, CPI_ADDR_CDM, Tsoil(1), NMBR_TCAV, mV200, TCAV_ANALOG_INPUT, TypeE, panel_tmpr_CDM_A116_3, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    Move(TS_1_1_1, NMBR_TCAV, Tsoil(1),  NMBR_TCAV)                       'To stor the data in AmeriFlux standard  
    
    #If ((SENSOR_HFP) AND  (SENSOR_CS6XX) AND ((SENSOR_TCAV) OR (SENSOR_CS65X))) Then
    AvgRun (Tsoil_current(1), NMBR_TCAV, Tsoil(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If (Tsoil_prev_Avg = NaN) Then                                        'As soon as program starts
      AvgSpa (Tsoil_prev_Avg, NMBR_TCAV, Tsoil(1))
    EndIf
    #EndIf
    '*** End of TCAV measurements ***

    #EndIf
    #If (SENSOR_CS616) Then

    '*** Beginning of CS616 measurements ***
    CS616 (cs616_wcr(1), NMBR_CS6xx, CS616_ANALOG_INPUT, CS616_POWER_CTRL, NMBR_CS6xx, 1, 0)

    #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
    If (NMBR_CS6xx >= NMBR_TCAV) Then
      Move(Tsoil_for_CS616_correct(1), NMBR_CS6xx, Tsoil(1), NMBR_TCAV)
    Else
      Move(Tsoil_for_CS616_correct(1), NMBR_CS6xx, Tsoil(1), 1)
    EndIf
    #EndIf

    'Apply temperature correction to CS616 period and find volumetric water content.
    For i_slow = 1 To NMBR_CS6xx

      #If ((SENSOR_CS616) AND (SENSOR_TCAV)) Then
      If ( (10 <= Tsoil_for_CS616_correct(i_slow)) AND (Tsoil_for_CS616_correct(i_slow) <= 40) ) Then
        cs616_T(i_slow) = cs616_wcr(i_slow)+(20-Tsoil_for_CS616_correct(i_slow))*(0.526+cs616_wcr(i_slow)*(-0.052+cs616_wcr(i_slow)*0.00136))
      Else
        cs616_T(i_slow) = cs616_wcr(i_slow)
      EndIf
      soil_wtr_T(i_slow) = -0.0663+cs616_T(i_slow)*(-0.0063+cs616_T(i_slow)*0.0007)
      SWC_array(i_slow)  = 100*soil_wtr_T(i_slow)             
      #EndIf

      #If ((SENSOR_CS616) AND (NOT SENSOR_TCAV)) Then
      soil_wtr(i_slow) = -0.0663+cs616_wcr(i_slow)*(-0.0063+cs616_wcr(i_slow)*0.0007)
      SWC_array(i_slow)  = 100*soil_wtr(i_slow) 
      #EndIf

    Next i_slow

    #If ((SENSOR_HFP) AND  (SENSOR_CS616) AND (SENSOR_TCAV)) Then
    AvgRun (soil_wtr_current(1), NMBR_CS6xx, soil_wtr_T(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If soil_wtr_prev_Avg = NaN Then                              'As soon as program started
      AvgSpa (soil_wtr_prev_Avg, NMBR_CS6xx, soil_wtr_T(1))
    EndIf
    #EndIf
    '*** End of CS616 measurements ***
    #EndIf
    #If (SENSOR_CS65X) Then

    '*** Beginning of CS65X measurements ***
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CS65X_SDI12_Address_1, "M!", 1, 0)
    cs65x_wc(1)   = cs65x_raw(1)                                      
    cs65x_ec(1)   = cs65x_raw(2)
    cs65x_tmpr(1) = cs65x_raw(3)
    #If (NMBR_CS6xx = 2) Then
    SDI12Recorder (cs65x_raw(1), CS65X_SDI12_PORT, CS65X_SDI12_Address_2, "M!", 1, 0)
    cs65x_wc(2)   = cs65x_raw(1)                                   
    cs65x_ec(2)   = cs65x_raw(2)
    cs65x_tmpr(2) = cs65x_raw(3)
    #EndIf
      
    'Soil temperature values measured from CS65X are used to report soil temperature if a TCAV sensor is not used  
    #If (SENSOR_CS65X) AND (NOT SENSOR_TCAV) Then
    Move (TS_1_1_1, NMBR_CS6xx, cs65x_tmpr(1), NMBR_CS6xx)
    #EndIf 
  
    'Correct volumetric soil moisture content using CS65x soil temperature  
    For i_slow = 1 To NMBR_CS6xx
      'SWC_1_1_1 if NMBR_CS6xx =1 and  SWC_1_1_1  and SWC_2_1_1 if NMBR_CS6xx = 2  
      SWC_array(i_slow) = cs65x_wc(i_slow)*(1.32 - 1.6*cs65x_wc(i_slow) + 2.4* cs65x_wc(i_slow)*cs65x_wc(i_slow)) _
                          + cs65x_tmpr(i_slow)*cs65x_wc(i_slow)*(0.0029 + 0.0014*cs65x_wc(i_slow) - 0.0044*cs65x_wc(i_slow)*cs65x_wc(i_slow)) _
                          - 0.0002*cs65x_tmpr(i_slow) - 0.046    ' Page 23 in the mannual for CS650 & CS655 Wtater content reflectometer (Revision 2/16)
    Next i_slow 
    
      
    #If (SENSOR_HFP) Then    

    AvgRun (soil_wtr_current(1), NMBR_CS6xx, SWC_array(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If (soil_wtr_prev_Avg = NaN) Then
      AvgSpa (soil_wtr_prev_Avg, NMBR_CS6xx, SWC_array(1))
    EndIf

    #If ((SENSOR_CS65X) AND ( NOT SENSOR_TCAV)) Then
    AvgRun (Tsoil_current(1), NMBR_CS6xx, cs65x_tmpr(1), NMBR_SOIL_T_WTR_DEL_SAMPLES)

    If (Tsoil_prev_Avg = NaN) Then                         'As soon as program starts
      AvgSpa (Tsoil_prev_Avg, NMBR_CS6xx, cs65x_tmpr(1))
    EndIf
    #EndIf
    #EndIf
      
    'Convert volumetric fraction to percent 
    For i_slow = 1 To NMBR_CS6xx
      SWC_array(i_slow) = 100*SWC_array(i_slow)                   'Conversion into percent for output 
    Next 

    '*** End of CS65X measurements ***
    #EndIf

    #If (SENSOR_LI200X) OR (SENSOR_CS300) Then

    '*** Beginning of pyranometer measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, SW_IN_pyran, 1, PYRAN_VOLTAGE_RANG, PYRAN_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    If SW_IN_pyran <=0 Then
      SW_IN = 0                                                       
    Else
      SW_IN =PYRAN_MULT*SW_IN_pyran + PYRAN_OFFSET                        
    EndIf
    '*** End of pyranometer measurements ***
    #EndIf
    #If (SENSOR_LI190SB) Then

    '*** Beginning of LI190SB measurements ***
    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, PPFD_IN, 1, QUANTUM_VOLTAGE_RANGE, QUANTUM_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    If (PPFD_IN <= 0) Then
      PPFD_IN = 0
    Else
      PPFD_IN = QUANTUM_MULT*PPFD_IN + QUANTUM_OFFSET
    EndIf
    '*** End of LI190SB measurements ***
    #EndIf
      
     #If (SENSOR_TMPR_RH) Then

    '*** Beginning of temperature and humidity probe measurements ***
    VoltDiff (T_probe,2,mV1000,TMPR_RH_ANALOG_INPUT,True,500,FIRST_NOTCH_FREQ_SLOW_SEQU,1,0)
    T_probe  = T_probe*TMPR_T_MULT + TMPR_T_OFFSET
    RH_probe = RH_probe*TMPR_RH_MULT + TMPR_RH_OFFSET
    '*** End of temperature and humidity probe measurements ***
      
    '*** Beginning of temperature and humidity probe processing ***
      'Saturation water pressure at current temperature
       Enhance_factor1_probe = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(T_probe + 30.6 - 0.38*amb_press)^2)     'Eq. 6 from Appendix A of flux program manual

       Select Case T_probe                                                                                    'Eq. 5 from Appendix A of flux program manual
         Case Is >= 0
           e_sat_probe = 0.61121*Enhance_factor1_probe*EXP(17.368*T_probe/(T_probe + 238.88))
         Case Is < 0
           e_sat_probe = 0.61121*Enhance_factor1_probe*EXP(17.966*T_probe/(T_probe + 247.15))
        EndSelect
    
       e_probe = (RH_probe*e_sat_probe)/100
    
       H2O_probe   = e_probe/((T_probe + T_0C_K)*Rv)                        'g/m^3
       rho_d_probe = (amb_press - e_probe)/((T_probe + T_0C_K)*Rd)          'g/m^3
     
       'Dew point temperature for general use for accurately computing the final dew point temperature
        Enhance_factor2_probe = 1.00072 + 3.46e-5*amb_press                                                       'Eq. 9 from Appendix A of flux program manual

        x_tmp_probe           = LN(e_probe/(0.61121*Enhance_factor2_probe))                                       'For dew point temperature, assume that e is saturation water vapor pressure
        Td_gu_probe           = 240.97*x_tmp_probe/(17.502-x_tmp_probe)

        'Accurate dew point temperature
         Enhance_factor1_probe  = 1.00041 + amb_press*(3.48e-5 + 7.4e-9*(Td_gu_probe + 30.6 - 0.38*amb_press)^2)  'Eq. 6 from Appendix A of flux program manual

         x_tmp_probe            = LN(e_probe/(0.61121*Enhance_factor1_probe))                                     'For dew point temperature, assume that e is saturation water vapor pressure

         Select Case Td_gu_probe                                                                                  'Eq. 11 from Appendix A of flux program manual
           Case Is >= 0
             T_DP_Probe = 238.88*x_tmp_probe/(17.386 - x_tmp_probe)
           Case Is < 0
             T_DP_Probe = 247.15*x_tmp_probe/(17.966 - x_tmp_probe)
          EndSelect      

    #EndIf

    #If (SENSOR_SI111) Then

    '*** Beginning of SI111 measurements ***
    CDM_Therm109 (CDM_MODEL, CPI_ADDR_CDM, T_SI111_body, 1, 2*SI111_ANALOG_INPUT + 1, SI111_EXCITATION, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1.0, 0)     'T_SI111_body in C
    m_SI111 = m0_SI111 + m1_SI111*T_SI111_body + m2_SI111*T_SI111_body*T_SI111_body                                                                'parameter in target temp equation  
    b_SI111 = b0_SI111 + b1_SI111*T_SI111_body + b2_SI111*T_SI111_body*T_SI111_body                                                                'parameter in target temp equation  

    CDM_VoltDiff (CDM_MODEL, CPI_ADDR_CDM, T_CANOPY, 1, mV200, SI111_ANALOG_INPUT, TRUE, 500, FIRST_NOTCH_FREQ_SLOW_SEQU, 1, 0)
    T_CANOPY = ((T_SI111_body + T_0C_K)^4 + m_SI111*T_CANOPY + b_SI111)^0.25 - T_0C_K                                                               'T_CANOPY in C
    '*** End of SI111 measurements ***
    #EndIf

    '*** Beginning of updating files of station variables and planar fit angles ***
    'Determing whether or not the planar fit is used. It is used as long as one planar fit angle is not zero.
    stn_var_check_count += 1

    If  (stn_conf_array_prev(stn_var_check_count) <> stn_conf_array(stn_var_check_count)) Then
           
      Select Case stn_var_check_count
        'Update geo-coordinates
      Case 2, 3, 4, 5
        If (hemisphere_NS = HEMISPHERE_NORTH) Then
          latitude = ABS(latitude)
        Else
          latitude = - ABS(latitude)
        EndIf

        If (hemisphere_EW = HEMISPHERE_EAST) Then
          longitude = ABS(longitude)
        Else
          longitude = -ABS(longitude)
        EndIf

        ' Update Aerodynamic height (z)
      Case 6, 7, 8, 9
        Call Displacement_Roughness_heights (surface_type, displacement_user, roughness_user, height_canopy, height_measurement, d, z0, z)
        surface_type_text = surface_type_array(surface_type)
        
        For i = 13 To 16
          If (stn_conf_array(i) = 100*z_prev) Then 
              stn_conf_array(i) = 100*z                                                          'Default value of 100*z for all sectors in different directions
          EndIf 
        Next 
        
        z_prev = z
 
      EndSelect

      Calfile (stn_conf_array(1), NMBR_STN_VAR, "CPU:sys_conf_var.dat", 0)                       'Store the new values to the file.
      Move(stn_conf_array_prev(1), NMBR_STN_VAR , stn_conf_array(1), NMBR_STN_VAR)               'Update stn_conf_array_prev()

    EndIf

    If stn_var_check_count <= 4 Then

      If (planar_fit_angle_conf_array_prev (stn_var_check_count, 1) <> planar_fit_angle_conf_array (stn_var_check_count, 1)) _
        OR (planar_fit_angle_conf_array_prev (stn_var_check_count, 2) <> planar_fit_angle_conf_array (stn_var_check_count, 2)) Then

        Calfile (planar_fit_angle_conf_array (1,1),8,"CPU:sys_planar_fit_angles.dat",0)  'Store the new values to the file.

        'Keep current values of planar_fit_angle_conf_array() in planar_fit_angle_prev_array() for later use as previous values
        Move (planar_fit_angle_conf_array_prev(stn_var_check_count, 1), 2, planar_fit_angle_conf_array(stn_var_check_count, 1), 2)

        Planar_Fit_flg = FALSE
        For i_slow = 1 To 4
          If (planar_fit_angle_conf_array (i_slow, 1) <> 0) OR (planar_fit_angle_conf_array (i_slow, 2) <> 0) Then
            Planar_Fit_flg = TRUE
            ExitFor
          EndIf
        Next i_slow
      EndIf
    EndIf

    If (stn_var_check_count = NMBR_STN_VAR) Then stn_var_check_count =0
    '*** End of updating files of station variables and planar fit angles ***

    slowsequence_finished_flg = TRUE
  NextScan
EndProg
